/*! ---------------------------------------------------------------------------
    Copyright 2016-2017 Dynatrace
    All rights reserved.
    ---------------------------------------------------------------------------
    This document contains proprietary information belonging to Dynatrace.
    Passing on and copying of this document, use, and communication of its
    contents is not permitted without prior written authorization.
    --------------------------------------------------------------------------- */

"use strict";
(function() {
'use strict';
var y = y || {};
y.scope = {};
y.ASSUME_ES5 = !1;
y.ASSUME_NO_NATIVE_MAP = !1;
y.ASSUME_NO_NATIVE_SET = !1;
y.SIMPLE_FROUND_POLYFILL = !1;
y.defineProperty = y.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(t, a, e) {
  t != Array.prototype && t != Object.prototype && (t[a] = e.value);
};
y.getGlobal = function(t) {
  t = ["object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global, t];
  for (var a = 0; a < t.length; ++a) {
    var e = t[a];
    if (e && e.Math == Math) {
      return e;
    }
  }
  return globalThis;
};
y.global = y.getGlobal(this);
y.polyfill = function(t, a) {
  if (a) {
    var e = y.global;
    t = t.split(".");
    for (var h = 0; h < t.length - 1; h++) {
      var f = t[h];
      f in e || (e[f] = {});
      e = e[f];
    }
    t = t[t.length - 1];
    h = e[t];
    a = a(h);
    a != h && null != a && y.defineProperty(e, t, {configurable:!0, writable:!0, value:a});
  }
};
y.polyfill("Array.prototype.includes", function(t) {
  return t ? t : function(a, e) {
    var h = this;
    h instanceof String && (h = String(h));
    var f = h.length;
    e = e || 0;
    for (0 > e && (e = Math.max(e + f, 0)); e < f; e++) {
      var k = h[e];
      if (k === a || Object.is(k, a)) {
        return !0;
      }
    }
    return !1;
  };
}, "es7", "es3");
module.__DT_NODE_OBFUSCATED_AGENT__ = !0;
const S = (() => {
  function t(a) {
    const c = [], g = f[a];
    if (g.exports === k) {
      h && console.log("resolving " + a);
      g.exports = {_____DynatraceAmdLoaderModuleName:a};
      g.isResolving = !0;
      for (const b of g.dependencies) {
        "require" === b ? c.push(require) : "exports" === b ? c.push(g.exports) : void 0 !== f[b] ? (c.push(t(b)), h && f[b].isResolving && console.log("module " + a + " is dependent on resolving module " + b)) : global.__DT_AMDLOADER_ALLOW_EXTERNALS__ || m.hasOwnProperty(b) || n[b] ? c.push(require(b)) : require("assert")(!1, "forbidden request to external module " + b);
      }
      a = g.generator.apply(void 0, c);
      void 0 !== a && (g.exports = a);
      g.isResolving = !1;
    }
    return g.exports;
  }
  function a() {
    t("src/nodejsagent");
    for (const a in f) {
      t(a);
    }
  }
  function e(g, c) {
    a();
    return f["src/nodejsagent"].exports(g, c);
  }
  const h = process.env.DT_NODE_AMD_LOADER_ENABLE_LOGGING, f = {}, k = {}, n = {semver:!0}, m = process.binding("natives");
  e.amdModuleLoader = {resolve:t, resolveAll:a, moduleMap:f};
  module.exports = e;
  return function(a, c, e) {
    {
      let b = f[a];
      void 0 === b && (b = {generator:e, dependencies:c, exports:k, isResolving:!1}, f[a] = b, h && console.log("creating module " + a));
    }
  };
})();
S("src/lib/util/CoreUtil", ["require", "exports", "util"], function(t, a, e) {
  function h(a) {
    return "function" === typeof a;
  }
  function f(a) {
    return "string" === typeof a;
  }
  function k(a) {
    return null !== a && "object" === typeof a;
  }
  function n(a, g, ...c) {
    if ((c = null != a && null != a[g]) && 2 < arguments.length) {
      a = a[g];
      c = null != a;
      for (let g = 2; g < arguments.length && c; ++g) {
        a = a[arguments[g]], c = null != a;
      }
    }
    return c;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.isError = function(a) {
    return e.isError(a);
  };
  a.isFunction = h;
  a.isBoolean = function(a) {
    return "boolean" === typeof a;
  };
  a.isNumber = function(a) {
    return "number" === typeof a;
  };
  a.isString = f;
  a.isObject = k;
  a.isPrimitive = function(a) {
    return null === a || !k(a) && !h(a);
  };
  a.isEmptyObject = function(a) {
    let g;
    for (g in a) {
      return !1;
    }
    return !0;
  };
  a.pad = function(a, g = 2, c = "0") {
    return (Array(g + 1).join(c) + a).slice(-g);
  };
  a.stripByteOrderMark = function(a) {
    return 65279 === a.charCodeAt(0) ? a.slice(1) : a;
  };
  a.hasProperty = n;
  a.getPropertyByPath = function(a, g) {
    if (null != a && (Array.isArray(g) || (g = g.split(".")), 0 !== g.length)) {
      a = a[g[0]];
      for (let c = 1; c < g.length && null != a; ++c) {
        a = a[g[c]];
      }
      return a;
    }
  };
  a.getOptionalPropertyValue = function(a, g, c) {
    return n(a, g) ? a[g] : c;
  };
  a.getOptionalValue = function(a, g) {
    return void 0 !== a ? a : g;
  };
  a.hasElements = function(a, g = 1) {
    return null != a && a.length >= g;
  };
  a.match = function(a, g) {
    let c;
    if (Array.isArray(a)) {
      for (let d = 0; null == c && d < a.length; ++d) {
        var e = a[d], b = g;
        (f(e) ? e === b : e.test(b)) && (c = a[d]);
      }
    } else {
      f(a) ? a === g && (c = a) : a.test(g) && (c = a);
    }
    return c;
  };
  a.getTimeStamp = process.hrtime;
  a.getDurationMillis = function(a) {
    a = process.hrtime(a);
    return Math.round(1000 * a[0] + a[1] / 1000000);
  };
  a.getDurationMicros = function(a) {
    a = process.hrtime(a);
    return Math.round(1000000 * a[0] + a[1] / 1000);
  };
});
S("src/lib/Debug", ["require", "exports", "assert"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  let h = null != process.env.DT_NODE_AGENT_DEBUG_MODE_ENABLE;
  a.test = function(a) {
    return h && a;
  };
  a.assert = function(a, k) {
    h && e.ok(a, k);
  };
  a.assertStrictEqual = function(a, k, n) {
    h && e.strictEqual(a, k, n);
  };
  a.assertNotStrictEqual = function(a, k, n) {
    h && e.notStrictEqual(a, k, n);
  };
  a.fail = function(a) {
    if (h) {
      throw Error(null != a ? a : "unconditional debug assertion.");
    }
  };
  a.isEnabled = function() {
    return h;
  };
  a.setDebugMode = function(a) {
    h = a;
  };
  a.unitTestMode = !1;
  a.setUnitTestMode = function(e) {
    a.unitTestMode = e;
  };
});
S("src/lib/RunTimeProperty", ["require", "exports", "src/lib/Agent", "src/lib/Debug", "src/lib/util/ErrorUtil"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k {
    constructor(b) {
      this.value = b;
    }
  }
  class n {
  }
  class m {
    constructor() {
      this.entries = new n;
    }
    get(b, d) {
      let c = this.entries[b];
      if (!c) {
        if (e.Agent && e.Agent.nativeAgent) {
          switch(typeof d) {
            case "boolean":
              d = e.Agent.nativeAgent.getBooleanRunTimePropertyValue(b, d);
              break;
            case "number":
              d = e.Agent.nativeAgent.getNumericalRunTimePropertyValue(b, d);
              break;
            case "string":
              d = e.Agent.nativeAgent.getStringRunTimePropertyValue(b, d);
              break;
            default:
              h.fail("unknown property type");
          }
        }
        c = new k(d);
        this.entries[b] = c;
      }
      return c;
    }
    set(b, d) {
      if (null == d) {
        f.logAgentException(new TypeError(`PropertyValuePool.set(${b}) with emtpy value`));
      } else {
        var c = this.entries[b];
        c ? c.value = d : this.entries[b] = new k(d);
      }
    }
    update(b, d) {
      const c = this.entries[b];
      c && (null != d ? c.value = d : f.logAgentException(new TypeError(`PropertyValuePool.update(${b}) with empty value`)));
    }
    updateExistingFromNative(b) {
      for (const d in this.entries) {
        const c = this.entries[d];
        if (null != c.value) {
          const l = b.call(e.Agent.nativeAgent, d, c.value);
          null != l ? c.value = l : f.logAgentException(new TypeError(`Native agent returned no value for Property ${d}`));
        } else {
          f.logAgentException(new TypeError(`Property ${d} has no value`));
        }
      }
    }
    copyEntries() {
      const b = {names:[], defaultValues:[]};
      for (const d in this.entries) {
        this.entries.hasOwnProperty(d) && (b.names.push(d), b.defaultValues.push(this.entries[d].value));
      }
      return b;
    }
  }
  const g = new m, c = new m, r = new m;
  class b {
    onConfigUpdate(d) {
      if ((d = d.rtc) && !b.updateExistingFromNative()) {
        for (const b in d.booleanMap) {
          g.update(b, d.booleanMap[b]);
        }
        for (const b in d.longMap) {
          c.update(b, d.longMap[b]);
        }
        for (const b in d.stringMap) {
          r.update(b, d.stringMap[b]);
        }
      }
    }
    onLifeCycleStateChanged() {
      b.updateExistingFromNative();
    }
    static updateExistingFromNative() {
      return e.Agent.lifeCycleState === e.LifeCycleState.Running && e.Agent.nativeAgent ? (g.updateExistingFromNative(e.Agent.nativeAgent.getBooleanRunTimePropertyValue), c.updateExistingFromNative(e.Agent.nativeAgent.getNumericalRunTimePropertyValue), r.updateExistingFromNative(e.Agent.nativeAgent.getStringRunTimePropertyValue), !0) : !1;
    }
  }
  a.PropertyRtcUpdateListener = b;
  a.parseForRunTimeProperties = function(b) {
    for (const d of Object.getOwnPropertyNames(b)) {
      if (0 === d.indexOf("debugNode") || 0 === d.indexOf("optionNode")) {
        const l = b[d];
        switch(typeof l) {
          case "boolean":
            g.set(d, l);
            break;
          case "number":
            c.set(d, l);
            break;
          case "string":
            r.set(d, l);
        }
      }
    }
  };
  class d {
    constructor(b, d) {
      this.name = b;
      this.valueRef = d;
    }
    get value() {
      return this.valueRef.value;
    }
    static makeName(b, d = "debug") {
      return `${d}Node${b}NodeJS`;
    }
  }
  class l extends d {
    constructor(b, c = !1) {
      b = d.makeName(b);
      super(b, g.get(b, c));
    }
    static getBooleanPropertyPool() {
      return g;
    }
  }
  a.BooleanProperty = l;
  class x extends d {
    constructor(b, c = !1) {
      b = d.makeName(b, "option");
      super(b, g.get(b, c));
    }
    static getBooleanPropertyPool() {
      return g;
    }
  }
  a.BooleanOption = x;
  class p extends d {
    constructor(b, d = 0) {
      super(b, c.get(b, d));
    }
    static getNumberPropertyPool() {
      return c;
    }
  }
  a.NumberSetting = p;
  class q extends d {
    constructor(b, l = 0) {
      b = d.makeName(b, "option");
      super(b, c.get(b, l));
    }
    static getNumberPropertyPool() {
      return c;
    }
  }
  a.NumberOption = q;
  class v extends d {
    constructor(b, c = "") {
      b = d.makeName(b, "option");
      super(b, r.get(b, c));
    }
    static getStringPropertyPool() {
      return r;
    }
  }
  a.StringOption = v;
});
S("src/lib/MethodIdCache", ["require", "exports", "src/lib/Agent", "src/lib/RunTimeProperty", "src/lib/util/CoreUtil"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k {
    constructor() {
      this.fileNameCount = this.methodIdObjectCount = 0;
    }
    toString() {
      return `[${this.fileNameCount} ${this.methodIdObjectCount}]`;
    }
  }
  class n {
    constructor() {
      this.debugFlag = new h.BooleanProperty("MethodIdCache");
      this.disableFlag = new h.BooleanProperty("MethodIdCacheDisabled");
      this.reset();
    }
    get statistics() {
      return this.stats;
    }
    get enabled() {
      return !this.disableFlag.value;
    }
    reset() {
      this.cache = Object.create(null);
      this.stats = new k;
    }
    get(a, g) {
      let c;
      if (this.disableFlag.value) {
        f.isEmptyObject(this.cache) || this.reset(), c = e.Agent.nativeAgent.registerMethod(a, g);
      } else {
        let f = this.cache[g];
        null == f && (f = Object.create(null), this.cache[g] = f, ++this.stats.fileNameCount);
        c = f[a];
        null == c && (c = e.Agent.nativeAgent.registerMethod(a, g), f[a] = c, ++this.stats.methodIdObjectCount, this.debugFlag.value && e.Logger.debug(`MethodRegistryCache: created id ${c} #${this.stats.methodIdObjectCount} from '${a}' '${g}'`), 255 === (this.stats.methodIdObjectCount & 255) && e.Logger.info(`MethodRegistryCache: grown to ${this.stats} entries`));
      }
      return c;
    }
  }
  t = new n;
  a.default = t;
});
S("src/lib/util/Reflection", ["require", "exports", "util"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.cAnonymousFnName = "<anonymous>";
  a.cloneFunctionProperties = function(a, e, k = "") {
    k = e.name ? e.name : k;
    a.name !== k && Object.defineProperty(a, "name", {value:k, enumerable:!1, configurable:!0, writable:!1});
    a.length !== e.length && Object.defineProperty(a, "length", {value:e.length, enumerable:!1, configurable:!0, writable:!1});
  };
  a.copyPromisifyProperties = function(a, f) {
    if (e.promisify) {
      var k = Object.getOwnPropertySymbols(f);
      for (const n of k) {
        a.hasOwnProperty(n) || n !== e.promisify.custom && "Symbol(customPromisifyArgs)" !== n.toString() || (k = Object.getOwnPropertyDescriptor(f, n), Object.defineProperty(a, n, k));
      }
    }
  };
});
S("src/lib/DebugLoggingEntity", "require exports src/lib/Agent src/lib/Debug src/lib/RunTimeProperty src/lib/util/InvocationUtil".split(" "), function(t, a, e, h, f, k) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class n {
    constructor(a) {
      this.debugFlag = new f.BooleanProperty(a, h.unitTestMode);
    }
    get isDebugEnabled() {
      return this.debugFlag.value || null != this.domainDebugFlags && this.domainDebugFlags.some(a => a.value);
    }
    get debugFlagName() {
      return this.debugFlag.name;
    }
    logDebug() {
      this.isDebugEnabled && k.doInvoke(void 0, e.Logger.debug, arguments);
    }
    addToDebugLogDomain(a) {
      null == this.domainDebugFlags && (this.domainDebugFlags = []);
      this.domainDebugFlags.push(new f.BooleanProperty(a, h.unitTestMode));
    }
  }
  a.default = n;
});
S("src/lib/Embedder", ["require", "exports", "src/lib/util/CoreUtil"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.cDtEmbeddedDataSymbolName = Symbol("DynatraceEmbeddedData");
  a.create = function(h) {
    function f(e) {
      return null != e && null != e[a.cDtEmbeddedDataSymbolName] ? e[a.cDtEmbeddedDataSymbolName][h] : void 0;
    }
    function k(e, f) {
      try {
        null == e[a.cDtEmbeddedDataSymbolName] && (e[a.cDtEmbeddedDataSymbolName] = Object.create(null)), e[a.cDtEmbeddedDataSymbolName][h] = f;
      } catch (g) {
        return;
      }
      return f;
    }
    return {get:f, createOrGet:function(a, e) {
      let g = f(a);
      null == g && (g = e(), k(a, g));
      return g;
    }, set:k, clear:function(e) {
      try {
        null != e[a.cDtEmbeddedDataSymbolName] && (e[a.cDtEmbeddedDataSymbolName][h] = void 0);
      } catch (m) {
      }
    }, unlink:function(f) {
      try {
        null != f[a.cDtEmbeddedDataSymbolName] && (f[a.cDtEmbeddedDataSymbolName][h] = void 0, delete f[a.cDtEmbeddedDataSymbolName][h], e.isEmptyObject(f[a.cDtEmbeddedDataSymbolName]) && delete f[a.cDtEmbeddedDataSymbolName]);
      } catch (m) {
      }
    }, hasData:function(f) {
      return e.hasProperty(f, a.cDtEmbeddedDataSymbolName, h);
    }, hasKey:function(f) {
      return e.hasProperty(f, a.cDtEmbeddedDataSymbolName) && null != Object.getOwnPropertyDescriptor(f[a.cDtEmbeddedDataSymbolName], h);
    }};
  };
  a.createPrivate = function(a) {
    function e(a) {
      return null != a ? a[n] : void 0;
    }
    function k(a, g) {
      try {
        Object.defineProperty(a, n, {value:g, enumerable:!1, configurable:!0, writable:!0});
      } catch (c) {
        return;
      }
      return g;
    }
    const n = Symbol(`${"Dynatrace"}_${a}`);
    return {get:e, createOrGet:function(a, g) {
      let c = e(a);
      null == c && (c = g(), k(a, c));
      return c;
    }, set:k, clear:function(a) {
      try {
        a[n] = void 0;
      } catch (g) {
      }
    }, unlink:function(a) {
      try {
        delete a[n];
      } catch (g) {
      }
    }, hasData:function(a) {
      return null != a && null != a[n];
    }, hasKey:function(a) {
      return null != Object.getOwnPropertyDescriptor(a, n);
    }, sym:n};
  };
});
S("src/lib/Patch", "require exports src/lib/util/CoreUtil src/lib/util/InvocationUtil src/lib/util/Reflection src/lib/Agent src/lib/DebugLoggingEntity src/lib/Embedder src/lib/RunTimeProperty".split(" "), function(t, a, e, h, f, k, n, m, g) {
  function c(b, d) {
    const c = b[d];
    return e.isFunction(c) && (!a.FnEmbedder.hasData(c) || !b.hasOwnProperty(d));
  }
  function r(b, d, c) {
    if (null == b.module) {
      k.Logger.info(`module ${b.moduleName} is undefined`);
    } else {
      return c.polymorphicSubstitution && (null == B && (B = (new g.BooleanOption("DisablePolymorphicSubstitutions", !1)).value) && k.Logger.info("Polymorphic substitions are disabled, falling back to regular substitutions"), !B) ? u.install(b, d, c) : D.install(b, d, c);
    }
  }
  function b(b, d, c, l) {
    a.FnEmbedder.set(d, b);
    f.cloneFunctionProperties(d, c, b.functionName);
    f.copyPromisifyProperties(d, c);
    if (null != l) {
      var q = Object.getOwnPropertyNames(c);
      for (const b of q) {
        e.match(l, b) && (q = Object.getOwnPropertyDescriptor(c, b), Object.defineProperty(d, b, q));
      }
    }
    return b;
  }
  function d(b, d, c = a.cDefaultOptions) {
    return r(b, b => d.generateSubstitute(b), c);
  }
  function l(b) {
    return a.FnEmbedder.get(b);
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.FnEmbedder = m.create("patchedFnDesc");
  a.cDefaultOptions = Object.seal({ignoreMissing:!1, ignoreAlreadyPatched:!1, polymorphicSubstitution:!1});
  a.cPolymorphicDefaultOptions = Object.seal({ignoreMissing:!1, ignoreAlreadyPatched:!1, polymorphicSubstitution:!0});
  var x;
  (function(b) {
    b[b.None = 0] = "None";
    b[b.CallbackFirst = 536870912] = "CallbackFirst";
    b[b.CallbackSecond = 536870913] = "CallbackSecond";
    b[b.CallbackSecondInjectMissing = b.CallbackSecond | -2147483648] = "CallbackSecondInjectMissing";
    b[b.CallbackThird = 536870914] = "CallbackThird";
    b[b.CallbackLast = 536936447] = "CallbackLast";
    b[b.CallbackLastInjectMissing = b.CallbackLast | -2147483648] = "CallbackLastInjectMissing";
    b[b.Promise = 1073741824] = "Promise";
    b[b.CallbackFirstOrPromise = b.CallbackFirst | 1073741824] = "CallbackFirstOrPromise";
    b[b.CallbackLastOrPromise = b.CallbackLast | 1073741824] = "CallbackLastOrPromise";
  })(x = a.AsyncTrackingMode || (a.AsyncTrackingMode = {}));
  (function(b) {
    b.getCallbackIndex = function(b, d) {
      if (0 === (b & 536870912)) {
        return -1;
      }
      b &= 536870911;
      return 65535 === b ? d.length - 1 : b;
    };
    b.makeCallbackTrackingMode = function(b, d = !1) {
      return b | 536870912 | (d ? -2147483648 : 0);
    };
    b.isCallbackStyle = function(b) {
      return 0 !== (b & 536870912);
    };
    b.isPromiseStyle = function(b) {
      return 0 !== (b & 1073741824);
    };
    b.doInjectMissingCallback = function(b) {
      return 0 !== (b & -2147483648);
    };
  })(x = a.AsyncTrackingMode || (a.AsyncTrackingMode = {}));
  class p {
    constructor(b, d, c = x.None, l) {
      this.moduleName = b;
      this.module = d;
      this.asyncTrackingMode = c;
      this.apiRealm = l;
    }
  }
  a.ModuleSpec = p;
  class q extends p {
    constructor() {
      var b = arguments[1];
      if (e.isString(b)) {
        b = arguments[1];
        const d = arguments[2];
        let c, l;
        3 < arguments.length && (e.isString(arguments[3]) ? l = arguments[3] : (c = arguments[3], l = 4 < arguments.length ? arguments[4] : void 0));
        super(b, d, c, l);
      } else {
        super(b.moduleName, b.module, b.asyncTrackingMode, b.apiRealm);
      }
      this.functionName = arguments[0];
    }
    get qualifiedName() {
      return `${this.moduleName}.${this.functionName}`;
    }
    toString() {
      return this.qualifiedName;
    }
  }
  a.FunctionSpec = q;
  class v {
    constructor(b) {
      this.functionName = b.functionName;
      this.apiRealm = b.apiRealm;
      this.asyncTrackingMode = b.asyncTrackingMode;
      this.qualifiedName = b.qualifiedName;
      v.monitor(this, b);
    }
    get methodNodeName() {
      null == this.theMethodNodeName && this.setFunctionInfo(k.Agent.nativeAgent.getFunctionInfo(this.origFn));
      return this.theMethodNodeName;
    }
    get scriptFile() {
      null == this.theScriptFile && this.setFunctionInfo(k.Agent.nativeAgent.getFunctionInfo(this.origFn));
      return this.theScriptFile;
    }
    get lineNumber() {
      null == this.theLineNumber && this.setFunctionInfo(k.Agent.nativeAgent.getFunctionInfo(this.origFn));
      return this.theLineNumber;
    }
    static getOrigFn(b) {
      const d = a.FnEmbedder.get(b);
      return null != d ? d.origFn : b;
    }
    static getResolvedOrigFn(b) {
      const d = a.FnEmbedder.get(b);
      return null != d ? d.resolvedOrigFn : b;
    }
    setFunctionInfo(b) {
      this.theMethodNodeName = b.functionName;
      this.theScriptFile = b.fileName;
      this.theLineNumber = b.lineNumber;
    }
    static dummyPatchMonitor() {
    }
  }
  a.PatchedFnDescriptor = v;
  v.monitor = v.dummyPatchMonitor;
  class D extends v {
    constructor(b, d, c) {
      super(b);
      this.origFn = d;
      this.isOverride = c;
    }
    static install(d, c, l) {
      const q = d.module[d.functionName];
      if (e.isFunction(q)) {
        var g = null != q && null == Object.getOwnPropertyDescriptor(d.module, d.functionName);
        g && k.Logger.info(`overriding ${d.qualifiedName} - consider applying a polymorphic substitution`);
        if (a.FnEmbedder.hasData(q) && d.module.hasOwnProperty(d.functionName)) {
          l.ignoreAlreadyPatched || k.Logger.info(`${d.qualifiedName} is already patched`);
        } else {
          return z.isDebugEnabled && k.Logger.debug(`patching ${d.qualifiedName} [${d.apiRealm}]`), g = new D(d, q, g), c = c(g), d.module[d.functionName] = c, b(g, c, q, l.propertiesToCopy), g;
        }
      } else {
        l.ignoreMissing || k.Logger.info(`${d.qualifiedName} is not a function`);
      }
    }
    restore(b) {
      this.isOverride ? delete b.module[b.functionName] : b.module[b.functionName] = this.origFn;
    }
    get resolvedOrigFn() {
      let b = this.origFn, d = l(b);
      for (; null != d;) {
        b = d.origFn, d = a.FnEmbedder.get(b);
      }
      return b;
    }
    installAlias(b, d) {
      const c = b.module[b.functionName];
      if (v.getOrigFn(c) === d.module[d.functionName]) {
        return d.module[d.functionName] = c, v.monitor(this, d), !0;
      }
      k.Logger.warning(`${b} original function doesn't match to fspecAlias`);
      return !1;
    }
  }
  a.SubstitutedFnDescriptor = D;
  class C extends v {
    constructor(b, d, c) {
      super(b);
      this.theOrigFn = d;
      this.embedder = c;
      this.module = b.module;
    }
    get origFn() {
      var b = Object.getPrototypeOf(this.module);
      b = this.embedder.get(b);
      return null != b ? b : this.theOrigFn;
    }
    restore(b) {
      this.embedder.unlink(b.module);
    }
    get resolvedOrigFn() {
      return this.theOrigFn;
    }
    installAlias(b) {
      k.Logger.warning(`${b} can't install an alias via PolymorphicOverrideFnDescriptor`);
      return !1;
    }
  }
  a.PolymorphicOverrideFnDescriptor = C;
  class u extends v {
    constructor(b, d) {
      super(b);
      this.origFn = d;
      this.embedder = m.createPrivate(b.functionName);
    }
    static install(d, c, a) {
      const g = u.findImplementingProto(d.module, d.functionName);
      if (null == g) {
        k.Logger.info(`cannot install polymorphic dispatcher for ${d.qualifiedName} - function not found`);
      } else {
        var e = l(g[d.functionName]);
        if (null == e) {
          var f = g.constructor && g.constructor.name ? g.constructor.name : `PolymorphicBase of ${d.moduleName}`;
          e = new q(d.functionName, f, g);
          e = new u(e, g[d.functionName]);
          z.isDebugEnabled && k.Logger.debug(`install polymorphic dispatcher for ${d.qualifiedName} on ${f}`);
          f = e.createPolymorphicDispatcher(e);
          g[d.functionName] = f;
          b(e, f, e.origFn, a.propertiesToCopy);
        } else {
          if (!(e instanceof u)) {
            k.Logger.warning(`PolymorphicSubstitution: attempt to apply polymorphic substution to an non-polymorphich substituted function ${d.qualifiedName}`);
            return;
          }
        }
        return e.installOverride(d, c);
      }
    }
    restore(b) {
      const d = u.findImplementingProto(b.module, b.functionName);
      null != d && (d[b.functionName] = this.origFn);
    }
    get resolvedOrigFn() {
      return this.origFn;
    }
    installAlias(b, d) {
      const c = u.findImplementingProto(d.module, d.functionName);
      if (null == c) {
        return k.Logger.info(`cannot install alias ${d.qualifiedName} of ${b.qualifiedName} - function not found`), !1;
      }
      if (c[d.functionName] !== this.origFn) {
        return k.Logger.info(`${d.qualifiedName} is not an alias of ${b.qualifiedName}`), !1;
      }
      c[d.functionName] = b.module[b.functionName];
      v.monitor(this, d);
      return !0;
    }
    installOverride(d, c) {
      if (this.embedder.hasKey(d.module)) {
        k.Logger.warning(`attempt to re-install polymorphic patch for ${d.qualifiedName}`);
      } else {
        z.isDebugEnabled && k.Logger.debug(`patching ${d.qualifiedName} [${d.apiRealm}]`);
        var l = new C(d, this.origFn, this.embedder);
        c = c(l);
        this.embedder.set(d.module, c);
        b(l, c, this.origFn);
        return l;
      }
    }
    createPolymorphicDispatcher(b) {
      const d = this;
      return function() {
        const c = d.embedder.get(this);
        return h.doInvoke(this, null != c ? c : b.origFn, arguments);
      };
    }
    static findImplementingProto(b, d) {
      for (; null != b && null == Object.getOwnPropertyDescriptor(b, d);) {
        b = Object.getPrototypeOf(b);
      }
      return b;
    }
  }
  a.PolymorphicDispatcherFnDescriptor = u;
  const z = new n.default("Patch");
  z.addToDebugLogDomain("Transformers");
  let B;
  a.installAlias = function(b, d) {
    if (b.module[b.functionName] === d.module[d.functionName]) {
      return z.isDebugEnabled && k.Logger.debug(`${d} is already aliased to ${b}`), !0;
    }
    const c = l(b.module[b.functionName]);
    return null != c ? c.installAlias(b, d) : !1;
  };
  a.apply = r;
  a.tag = b;
  a.applyToSingle = d;
  a.applyToAll = function(b, c, l, g = a.cDefaultOptions) {
    b = new q("", b);
    for (const a of c) {
      b.functionName = a, d(b, l, g);
    }
  };
  a.applyToAllFunctions = function(b, l, g, e = a.cDefaultOptions) {
    const a = e.ignoreMissing, f = {};
    a || g.forEach(b => f[b.toString()] = !1);
    const p = new q("", b);
    for (const b of g) {
      c(p.module, b) && (p.functionName = b, d(p, l, e), a || (f[b] = !0));
    }
    !a && g.some(b => !f[b.toString()]) && (l = g.reduce((b, d) => f[d.toString()] ? b : `${b} ${d.toString()}`), k.Logger.info(`no match for [${l}] in module ${b.moduleName}`));
  };
  a.substitute = function(b, d, c = a.cDefaultOptions) {
    return r(b, () => d, c);
  };
  a.isApplied = function(b) {
    return a.FnEmbedder.hasData(b);
  };
  a.getFunctionDescriptor = l;
  a.invokeOriginal = function(b, d, c = []) {
    return h.doInvoke(d, v.getOrigFn(b), c);
  };
  a.invokeResolvedOriginal = function(b, d, c = []) {
    return h.doInvoke(d, v.getResolvedOrigFn(b), c);
  };
});
S("src/lib/FunctionId", ["require", "exports", "src/lib/Agent", "src/lib/MethodIdCache", "src/lib/util/CoreUtil"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k {
    constructor() {
      this.isVirtual = !1;
      if (f.isString(arguments[0])) {
        this.functionName = arguments[0], this.fileName = arguments[1], this.lineNumber = arguments[2], 4 <= arguments.length && (this.apiRealm = arguments[3]), 5 <= arguments.length && (this.isVirtual = arguments[4]);
      } else {
        if (f.isFunction(arguments[0])) {
          var a = e.Agent.nativeAgent.getFunctionInfo(arguments[0]);
          this.functionName = a.functionName;
          this.fileName = a.fileName;
          this.lineNumber = a.lineNumber;
        } else {
          a = arguments[0], this.functionName = a.methodNodeName, this.fileName = a.scriptFile, this.lineNumber = a.lineNumber, this.apiRealm = a.apiRealm;
        }
      }
    }
    toString() {
      return this.functionName;
    }
    get methodId() {
      null == this.theMethodId && (this.theMethodId = h.default.get(this.functionName, this.fileName));
      return this.theMethodId;
    }
  }
  a.FunctionId = k;
  class n extends k {
    constructor(a) {
      super(a.functionName, a.fileName, a.lineNumber, a.apiRealm, !0);
    }
  }
  a.VirtualNodeFunctionId = n;
});
S("src/lib/RuntimeSetting", ["require", "exports", "src/lib/Agent"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class h {
    constructor() {
      this.valuePool = {"ambientSampling.enabled":{value:!1}, "ambientSampling.forceEnable":{value:!1}, "autoSensor.enabled":{value:!1}, "sensor.stringTruncationLimit":{value:250}, "distributedTracing.http.dynatraceTagging":{value:!0}, "distributedTracing.http.traceContext":{value:!1}};
      h.theInstance = this;
    }
    static get instance() {
      if (null == h.theInstance) {
        throw Error("RuntimeSettingsPool: request for setting before proper setup");
      }
      return h.theInstance;
    }
    onConfigUpdate(a) {
      a = a.rtc;
      if (null != a) {
        if (null != a.agentOptionMap) {
          for (const e in this.valuePool) {
            this.setValue(e, a.agentOptionMap[e]);
          }
        }
        if (null != a.distributedTracing && null != a.distributedTracing.http) {
          for (const e of ["dynatraceTagging", "traceContext"]) {
            this.setValue(`distributedTracing.http.${e}`, a.distributedTracing.http[e]);
          }
        }
      }
    }
    getValue(a) {
      return this.valuePool[a];
    }
    setValue(a, f) {
      if (null != f) {
        const h = this.valuePool[a].value;
        typeof h === typeof f ? h !== f && (e.Logger.info(`RuntimeSettings: updating ${a}: ${h} -> ${f}`), this.valuePool[a].value = f) : e.Logger.info(`RuntimeSettings.onConfigUpdate: type mismatch in ${a}: ${f} (${typeof f})`);
      }
    }
  }
  a.RuntimeSettingsPool = h;
  class f {
    constructor(a) {
      this.valueRef = h.instance.getValue(a);
    }
    get value() {
      return this.valueRef.value;
    }
  }
  a.RuntimeSetting = f;
});
S("src/lib/AttachmentBase", ["require", "exports", "src/lib/RuntimeSetting", "src/lib/util/ErrorUtil"], function(t, a, e, h) {
  function f() {
    null == n && (n = new e.RuntimeSetting("sensor.stringTruncationLimit"));
    return n.value;
  }
  function k(c, a) {
    let b = !1;
    c.length > a && (b = !0, c = c.substr(0, a));
    return [c, b];
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  let n;
  class m {
    constructor(c) {
      this.attachment = c;
    }
    string(c, a, b = f()) {
      const [d, l] = k(a, b);
      this.attachment.setFieldString(c, d, l);
    }
    stringCached(c, a, b = f()) {
      const [d, l] = k(a, b);
      this.attachment.setFieldStringCached(c, d, l);
    }
    stringUnavailable(c) {
      this.attachment.setFieldStringUnavailable(c);
    }
    stringCachedOrUnavailable(c, a, b = f()) {
      null != a ? this.stringCached(c, a, b) : this.attachment.setFieldStringUnavailable(c);
    }
    float(c, a) {
      this.attachment.setFieldFloat(c, a);
    }
    integer(c, a) {
      this.attachment.setFieldInteger(c, a);
    }
    keyValue(c, a, b, d = f()) {
      const [l, g] = k(a, d), [e, q] = k(b, d);
      this.attachment.setFieldKeyValue(c, l, g, e, q);
    }
    keyValueCached(c, a, b, d = f()) {
      const [l, g] = k(a, d), [e, q] = k(b, d);
      this.attachment.setFieldKeyValueCached(c, l, g, e, q);
    }
    map(c, a, b, d = f()) {
      for (const l in a) {
        const g = a[l];
        if (null != g && (!b || b(l))) {
          if (Array.isArray(g)) {
            for (const b of g) {
              this.keyValueCached(c, l, `${b}`, d);
            }
          } else {
            this.keyValueCached(c, l, `${g}`, d);
          }
        }
      }
    }
    static setMultiple(c, a) {
      try {
        c.beginFastFieldAccess(), a(new m(c));
      } catch (b) {
        h.logAgentException(b);
      } finally {
        c.endFastFieldAccess();
      }
    }
  }
  a.AttachmentFieldSetter = m;
  class g {
    constructor(c, a, b, d) {
      this.id = a;
      this.attachment = c.getAttachment(a, b, d);
    }
    get valid() {
      return this.attachment.valid;
    }
    setMultipleFields(c) {
      m.setMultiple(this.attachment, c);
    }
    setString(c, a, b = f()) {
      const [d, l] = k(a, b);
      this.attachment.setFieldString(c, d, l);
    }
    setStringCached(c, a, b = f()) {
      const [d, l] = k(a, b);
      this.attachment.setFieldStringCached(c, d, l);
    }
    setKeyValueCached(c, a, b, d = f()) {
      const [l, g] = k(a, d), [e, q] = k(b, d);
      this.attachment.setFieldKeyValueCached(c, l, g, e, q);
    }
    setStringCachedOrUnavailable(c, a, b = f()) {
      if (null != a) {
        const [d, l] = k(a, b);
        this.attachment.setFieldStringCached(c, d, l);
      } else {
        this.attachment.setFieldStringUnavailable(c);
      }
    }
    setStringOrUnavailable(c, a, b = f()) {
      if (null != a) {
        const [d, l] = k(a, b);
        this.attachment.setFieldString(c, d, l);
      } else {
        this.attachment.setFieldStringUnavailable(c);
      }
    }
    toString() {
      return `attachment[#${this.attachment} ${this.id}]`;
    }
  }
  a.AttachmentBase = g;
});
S("src/lib/Stack", ["require", "exports", "src/lib/util/Reflection"], function(t, a, e) {
  function h(a, e) {
    const k = {};
    let g = [];
    const c = Error.stackTraceLimit, r = Error.prepareStackTrace;
    try {
      Error.prepareStackTrace = (b, d) => {
        g = d;
      }, Error.stackTraceLimit = a, Error.captureStackTrace(k, e ? e : h), f.triggerPrepareStackTrace(k);
    } finally {
      Error.stackTraceLimit = c, Error.prepareStackTrace = r;
    }
    return g;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class f {
    static triggerPrepareStackTrace(a) {
      return a.stack;
    }
  }
  a.getCallSites = h;
  a.findTypeName = function(a) {
    return a.isToplevel() ? "" : a.getTypeName() || "";
  };
  a.findFunctionName = function(a) {
    let f;
    (f = a.getFunctionName()) || (f = a.getMethodName());
    return f || e.cAnonymousFnName;
  };
});
S("src/lib/ErrorObject", ["require", "exports", "src/lib/Stack", "src/lib/Debug"], function(t, a, e, h) {
  function f(c) {
    const a = [];
    if (!c || "string" !== typeof c) {
      return a;
    }
    var b = c.split("\n").slice(1);
    c = new g;
    for (const l of b) {
      if (b = l.match(/at (?:(.+)\s+)?\(?(?:(.+?):(\d+):(\d+)|([^)]+))\)?/)) {
        const l = new g;
        var d = b[1];
        d && (c.functionName = d, l.typeName = e.findTypeName(c), l.functionName = e.findFunctionName(c) || (l.typeName ? "<anonymous>" : ""), d = l.functionName.indexOf(" "), 0 < d && (l.functionName = l.functionName.substring(0, d)));
        l.fileName = b[2] || "";
        l.lineNumber = parseInt(b[3], 10) || -1;
        l.columnNumber = parseInt(b[4], 10) || -1;
        a.push(l);
      }
    }
    return a;
  }
  function k(c, a) {
    const b = [];
    c && b.push(c.toString());
    if (a) {
      for (const d of a) {
        b.push("    at " + d.toString());
      }
    }
    return b.join("\n");
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class n {
    constructor(c, a) {
      this.name = "DtCapturedError";
      this.message = `Error '${c}' occurred`;
      c && c.stack ? this.stack = c.stack : Error.captureStackTrace(this, a);
    }
  }
  a.createExceptionObject = function(c, a) {
    return new n(c, a);
  };
  a.getCallStack = function(c) {
    let a = [], b = !1;
    const d = Error.prepareStackTrace;
    try {
      Error.prepareStackTrace = (c, g) => {
        a = g;
        Error.prepareStackTrace = d;
        b = !0;
        return (d || k)(c, g);
      }, m.triggerPrepareStackTrace(c), 0 === a.length && (a = f(c.stack));
    } finally {
      b || (Error.prepareStackTrace = d);
    }
    return a;
  };
  class m {
    static triggerPrepareStackTrace(c) {
      return c.stack;
    }
  }
  class g {
    constructor() {
      this.fileName = this.typeName = this.functionName = "";
      this.columnNumber = this.lineNumber = -1;
      this.receiver = "dummyReceiverValue";
    }
    getFileName() {
      return this.fileName;
    }
    getLineNumber() {
      return this.lineNumber;
    }
    getFunctionName() {
      return this.functionName;
    }
    getTypeName() {
      return this.typeName;
    }
    getColumnNumber() {
      return this.columnNumber;
    }
    getMethodName() {
      return "";
    }
    toString() {
      return (this.typeName ? this.typeName + "." : "") + this.functionName + (this.functionName ? " (" : "") + this.fileName + ":" + this.lineNumber + ":" + this.columnNumber + (this.functionName ? ")" : "");
    }
    isNative() {
      h.fail("not implemented");
      return !1;
    }
    getThis() {
      h.fail("not implemented");
    }
    getFunction() {
      h.fail("not implemented");
    }
    getEvalOrigin() {
      h.fail("not implemented");
    }
    isToplevel() {
      return !1;
    }
    isEval() {
      h.fail("not implemented");
      return !1;
    }
    isConstructor() {
      h.fail("not implemented");
      return !1;
    }
  }
  a.CallSiteObject = g;
});
S("src/lib/util/RuntimeUtil", ["require", "exports", "src/lib/util/CoreUtil", "src/lib/Configuration"], function(t, a, e, h) {
  function f() {
    return "win32" === process.platform;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.isWindows = f;
  a.isLinux = function() {
    return "linux" === process.platform;
  };
  a.hasCaseInsensitiveFilePaths = function() {
    return f();
  };
  a.isDebuggerActive = function() {
    return null != global.v8debug;
  };
  a.isAgentFile = function(a) {
    return a.startsWith(h.Configuration.rootFolder);
  };
  const k = process.binding("natives");
  a.isNodeCoreModule = function(a) {
    return e.hasProperty(k, a);
  };
});
S("src/lib/sensors/ExceptionAttachment", "require exports src/lib/Agent src/lib/AttachmentBase src/lib/Debug src/lib/ErrorObject src/lib/RunTimeProperty src/lib/Stack src/lib/util/RuntimeUtil".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  const c = !f.isEnabled();
  class r extends h.AttachmentBase {
    constructor(b) {
      super(b, e.Agent.correlation.AttachmentId.ATTACHMENT_EXCEPTION_ID, 0, e.Agent.correlation.AttachmentTarget.CurrentNode);
    }
    fillExceptionData(b) {
      if (null != this.attachment) {
        var d = b instanceof Error ? b : k.createExceptionObject(b, this.fillExceptionData);
        this.setMultipleFields(b => {
          this.debugExceptionAttachment && e.Logger.debug(`ExceptionAttachment: processing ${d.name} [${d.message}]`);
          const c = e.Agent.correlation.AttachmentFieldId;
          b.stringCached(c.EXCEPTION_MESSAGE, d.message ? `${d.message}` : "", 1024);
          b.stringCached(c.EXCEPTION_THROWABLE, d.name || "");
          const a = k.getCallStack(d);
          for (const d of a) {
            this.isFilterAgentFrames() && g.isAgentFile(d.getFileName() || "") || (this.debugExceptionAttachment && e.Logger.debug(`ExceptionAttachment: adding stackframe ${d.toString()}`), b.integer(c.EXCEPTION_STACKTRACE_NEXT_LINE, 0), b.stringCached(c.EXCEPTION_STACKTRACE_METHOD, m.findFunctionName(d)), b.stringCached(c.EXCEPTION_STACKTRACE_CLASS, m.findTypeName(d)), b.stringCached(c.EXCEPTION_STACKTRACE_FILE, d.getFileName() || ""), b.integer(c.EXCEPTION_STACKTRACE_LINE_NUMBER, d.getLineNumber() || 
            -1));
          }
        });
      }
    }
    isFilterAgentFrames() {
      return c;
    }
    get debugExceptionAttachment() {
      return r.debugExceptionAttachmentProperty.value;
    }
  }
  a.ExceptionAttachment = r;
  r.debugExceptionAttachmentProperty = new n.BooleanProperty("ExceptionAttachment", !1);
});
S("src/lib/MethodActivation", "require exports src/lib/Agent src/lib/Debug src/lib/RunTimeProperty src/lib/sensors/ExceptionAttachment src/lib/util/CoreUtil".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  const m = Math.pow(2, 32);
  class g {
    constructor(c) {
      this.currentState = 0;
      h.assert(c.spc.open);
      this.spc = c.spc;
      this.functionId = c.functionId;
      this.endSpcOnExit = n.getOptionalValue(c.endSpcOnExit, !1);
      this.creator = n.getOptionalValue(c.creator, e.Agent.correlation.Creator.NONE);
      g.serialNoCounter >= m && (g.serialNoCounter = 1);
      this.serialNo = g.serialNoCounter++;
      this.category = null != c.category ? c.category : this.isVirtual ? e.Agent.correlation.MethodCategory.AsyncCall : e.Agent.correlation.MethodCategory.None;
      null == c.attachmentCreator || this.spc.isIgnoredPath || c.attachmentCreator.createAttachments(this);
      this.isDebugEnabled && e.Logger.debug(`creating MethodActivation(${this.toString(!0)})`);
      switch(c.mode) {
        case 0:
          break;
        case 1:
          this.enter();
          break;
        case 2:
          this.enterAndSuspend();
          break;
        default:
          h.fail(`unexpected MethodActivationCreationMode: ${c.mode}`);
      }
    }
    get stack() {
      const c = [];
      c.push(this);
      let a = this.parentActivation;
      for (; null != a;) {
        c.push(a), a = a.parentActivation;
      }
      return c;
    }
    get valid() {
      return this.spc.open;
    }
    toString(c = !1) {
      let a = `${this.functionId.toString()}:${this.serialNo}`;
      c && (a += `[${this.spc}]`);
      return a;
    }
    enter(c = !1) {
      this.doTransition(c ? 1 : 0);
      h.assert(null == this.parentActivation || 1 === this.parentActivation.currentState);
      let a = !1;
      h.assert(this.spc.open, "enter on closed path");
      this.spc.open && (a = this.spc.isIgnoredPath ? !0 : c ? this.spc.path.methodEnterSuspended(this.serialNo, this.functionId.methodId, this.category, this.isVirtual, this.creator) : this.spc.path.methodEnter(this.serialNo, this.functionId.methodId, this.category, this.isVirtual, this.creator), this.spc.onMethodEnter(this), this.isDebugEnabled && e.Logger.debug(`MethodActivation.enter(${this}): ${a}`));
      return a;
    }
    enterAndSuspend() {
      return this.enter(!0);
    }
    exit(c) {
      this.doTransition(4);
      h.assert(this.spc.open, "exit on closed path");
      this.spc.onMethodExit(this);
      const a = this.spc.isIgnoredPath ? !0 : this.spc.path.methodExit(this.serialNo, this.isVirtual, c);
      this.endSpcOnExit && this.spc.end();
      this.isDebugEnabled && e.Logger.debug(`MethodActivation.exit(${this}): ${a} withCustomTicks: ${null != c}`);
      return a;
    }
    get isExited() {
      return 3 === this.currentState;
    }
    suspend() {
      this.doTransition(2);
      h.assert(this.spc.open, "suspend on closed path");
      const a = this.spc.isIgnoredPath ? !0 : this.spc.path.methodSuspend(this.serialNo);
      this.isDebugEnabled && e.Logger.debug(`MethodActivation.suspend(${this}): ${a}`);
      return a;
    }
    resume() {
      this.doTransition(3);
      h.assert(this.spc.open, "resume on closed path");
      const a = this.spc.isIgnoredPath ? !0 : this.spc.path.methodResume(this.serialNo);
      this.isDebugEnabled && e.Logger.debug(`MethodActivation.resume(${this}): ${a}`);
      return a;
    }
    exitOrException(a, g) {
      return null != a ? this.methodException(a, g) : this.exit(g);
    }
    methodException(a, g) {
      this.doTransition(5);
      h.assert(this.spc.open, "methodException on closed path");
      const b = this.spc.isIgnoredPath;
      if (null != a && !b) {
        const b = new k.ExceptionAttachment(this);
        b.valid && b.fillExceptionData(a);
      }
      this.spc.onMethodExit(this);
      a = b ? !0 : this.spc.path.methodException(this.serialNo, this.isVirtual, g);
      this.endSpcOnExit && this.spc.end();
      this.isDebugEnabled && e.Logger.debug(`MethodActivation.methodException(${this}): ${a}`);
      return a;
    }
    getAttachment(a, g, b) {
      const d = this.spc.isIgnoredPath;
      this.spc.open && !d ? (this.isDebugEnabled && e.Logger.debug(`MethodActivation.getAttachment(${this}, id:${a}, semanticVersion:${g}, target:${b})`), a = this.spc.path.getAttachment(this.serialNo, a, g, b)) : (a = e.Agent.correlation.cInvalidAttachment, d || h.fail("attempt to create attachement on closed path"));
      return a;
    }
    get isVirtual() {
      return this.functionId.isVirtual;
    }
    doTransition(a) {
      let c, b;
      switch(a) {
        case 0:
          c = 0 === this.currentState;
          b = 1;
          break;
        case 1:
          c = 0 === this.currentState;
          b = 2;
          break;
        case 2:
          c = 1 === this.currentState;
          b = 2;
          break;
        case 3:
          c = 2 === this.currentState;
          b = 1;
          break;
        case 4:
        case 5:
          c = 1 === this.currentState || 2 === this.currentState;
          b = 3;
          break;
        default:
          h.fail(`unknown MethodActivationEvent ${a}`), c = !1, b = this.currentState;
      }
      c ? this.currentState = b : (a = `${this.toString(!0)}: MethodActivationEvent ${a} invalid in state ${this.currentState}`, h.fail(a), e.Logger.warning(a));
      return c;
    }
    get isDebugEnabled() {
      return g.cDbgFlag.value;
    }
  }
  a.MethodActivation = g;
  g.serialNoCounter = 1;
  g.cDbgFlag = new f.BooleanProperty("MethodActivation");
});
S("src/lib/sensors/SensorConstants", ["require", "exports"], function(t, a) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.cHttpTaggingHeader = "x-dynatrace";
  a.cHttpTraceParent = "traceparent";
  a.cHttpTraceState = "tracestate";
  a.cAdkCookieName = "dtAdkTag";
  a.CONNECTION_POOL_TYPE_NOT_A_POOL = -1;
  a.CONNECTION_POOL_TYPE_GENERIC = 6;
});
S("src/lib/Tracing", "require exports src/lib/util/CoreUtil src/lib/Agent src/lib/util/ErrorUtil src/lib/RuntimeSetting src/lib/sensors/SensorConstants".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class m {
    constructor(a) {
      this.traceContext = a;
      m.init();
    }
    isDtTagValid() {
      return null != this.traceContext && e.isString(this.traceContext.dtTag);
    }
    isTraceParentValid() {
      return null != this.traceContext && e.isString(this.traceContext.traceParent);
    }
    isTraceStateValid() {
      return null != this.traceContext && e.isString(this.traceContext.traceState);
    }
    useDtTagging() {
      return m.isHttpDtTaggingEnabled.value && this.isDtTagValid();
    }
    useTraceContext() {
      return m.isHttpTraceContextEnabled.value && this.isTraceParentValid();
    }
    get dtTag() {
      return this.traceContext.dtTag;
    }
    get traceParent() {
      return this.traceContext.traceParent;
    }
    get traceState() {
      return this.traceContext.traceState;
    }
    setHttpTaggingHeadersOnRequest(a) {
      try {
        this.useDtTagging() && a.setHeader(n.cHttpTaggingHeader, this.traceContext.dtTag), this.useTraceContext() && (a.setHeader(n.cHttpTraceParent, this.traceContext.traceParent), this.isTraceStateValid() && a.setHeader(n.cHttpTraceState, this.traceContext.traceState));
      } catch (c) {
        f.logAgentException(c);
      }
    }
    getHttpTaggingHeaders() {
      const a = {};
      this.useDtTagging() && (a[n.cHttpTaggingHeader] = this.traceContext.dtTag);
      this.useTraceContext() && (a[n.cHttpTraceParent] = this.traceContext.traceParent, this.isTraceStateValid() && (a[n.cHttpTraceState] = this.traceContext.traceState));
      return a;
    }
    toString() {
      return m.traceContextToString(this.traceContext);
    }
    static traceContextToString(a) {
      return null != a ? `{ dtTag: ${a.dtTag}, traceParent: ${a.traceParent}, traceState: ${a.traceState} }` : "";
    }
    static getTaggingMode() {
      return m.getHttpTaggingMode();
    }
    static getHttpTaggingMode() {
      return m.init() && m.isHttpTraceContextEnabled.value ? m.isHttpDtTaggingEnabled.value ? h.Agent.correlation.TaggingMode.DT_AND_TC : h.Agent.correlation.TaggingMode.TC_ONLY : h.Agent.correlation.TaggingMode.DT_ONLY;
    }
    static init() {
      null == m.isHttpDtTaggingEnabled && (m.isHttpDtTaggingEnabled = new k.RuntimeSetting("distributedTracing.http.dynatraceTagging"));
      null == m.isHttpTraceContextEnabled && (m.isHttpTraceContextEnabled = new k.RuntimeSetting("distributedTracing.http.traceContext"));
      return null != m.isHttpDtTaggingEnabled && null != m.isHttpTraceContextEnabled;
    }
  }
  a.Tracing = m;
});
S("src/lib/util/Validatable", ["require", "exports"], function(t, a) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.validate = function(a) {
    return null != a && a.valid;
  };
});
S("src/lib/SubPathContext", "require exports src/lib/Agent src/lib/Debug src/lib/MethodActivation src/lib/RunTimeProperty src/lib/Tracing src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/Validatable".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  function r() {
    null == d && (d = (new k.BooleanOption("EnableLocalPaths", !0)).value, e.Logger.info(`Usage of LocalPath is ${d ? "enabled" : "disabled"}`));
    return d;
  }
  function b() {
    if (!r()) {
      const b = Error("LocalPath used even it's disabled");
      g.logAgentException(b);
      throw b;
    }
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  let d;
  a.Test_setLocalPathEnabled = function(b) {
    d = b;
  };
  const l = new k.BooleanProperty("SubPathContext");
  class x {
    constructor() {
      this.contextStackListeners = [];
      this.contextStack = [];
    }
    get top() {
      return this.hasItem ? this.contextStack[this.contextStack.length - 1] : void 0;
    }
    pop() {
      if (1 === this.contextStack.length && 0 < this.contextStackListeners.length) {
        for (var b of this.contextStackListeners) {
          b.onLastContextDeactivation();
        }
      }
      b = this.hasItem ? this.contextStack.pop() : void 0;
      l.value && e.Logger.debug(`ContextStack.pop ${b} => ${this.topToString()}`);
      return b;
    }
    push(b) {
      l.value && e.Logger.debug(`ContextStack.push ${this.topToString()} => ${b}`);
      this.contextStack.push(b);
      if (1 === this.contextStack.length && 0 < this.contextStackListeners.length) {
        for (const b of this.contextStackListeners) {
          b.onFirstContextActivation();
        }
      }
    }
    topToString() {
      return this.hasItem ? this.top.toString() : "<empty>";
    }
    clear() {
      this.contextStack = [];
    }
    addContextStackListener(b) {
      h.assert(!this.contextStackListeners.includes(b), "Trying to add the same ContextStackListener twice!");
      this.contextStackListeners.push(b);
    }
    removeContextStackListener(b) {
      b = this.contextStackListeners.indexOf(b);
      -1 < b ? this.contextStackListeners.splice(b, 1) : h.fail("Trying to remove non existing ContextStackListener!");
    }
    get hasItem() {
      return 0 < this.contextStack.length;
    }
  }
  class p {
    constructor(d, a, c, g) {
      this.instanceId = p.instanceCounter++;
      this.theDidInitiatAsyncOpFlag = !1;
      this.sensorId = m.getOptionalValue(a, e.Agent.correlation.SensorId.SENSOR_ID_NODEJS);
      a = m.getOptionalValue(g, n.Tracing.getTaggingMode());
      Array.isArray(d) ? (b(), this.pathHandle = e.Agent.correlation.startLocalPath(this.sensorId, d, a)) : this.pathHandle = e.Agent.correlation.startPath(this.sensorId, d, c, r(), a);
      this.isIgnoredPath = null != this.pathHandle.isIgnoredPath;
      l.value && e.Logger.debug(`created ${this.toString(!0)} | isIgnored=${this.isIgnoredPath}`);
    }
    static getActiveContext() {
      return p.contextStack.top;
    }
    static addContextStackListener(b) {
      p.contextStack.addContextStackListener(b);
    }
    static removeContextStackListener(b) {
      p.contextStack.removeContextStackListener(b);
    }
    toString(b = !1) {
      let d = `SPC:#${this.instanceId.toString(16)}`;
      b && (b = this.getLaf(), d += `[P=${this.pathHandle}, LAF=${null != b ? b : "<>"}, valid=${this.valid}]`);
      return d;
    }
    get activationStack() {
      const b = [];
      let d = this.theCurrentActivation;
      for (; null != d;) {
        b.push(d), d = d.parentActivation;
      }
      return b;
    }
    get currentActivation() {
      return this.theCurrentActivation;
    }
    get didInitiateAsyncOp() {
      return this.theDidInitiatAsyncOpFlag;
    }
    set didInitiateAsyncOp(b) {
      b && b !== this.theDidInitiatAsyncOpFlag && (l.value && e.Logger.debug(`${this} set didInitiatAsyncOp to true`), this.open ? this.theDidInitiatAsyncOpFlag = !0 : h.fail(`${this} set didInitiateAsyncOp on ended path`));
    }
    get valid() {
      return c.validate(this.pathHandle) || null != this.getLaf();
    }
    get open() {
      return null != this.pathHandle;
    }
    get isActive() {
      return p.contextStack.top === this;
    }
    get parentExecutor() {
      return this.theParentExecutor;
    }
    activate() {
      p.contextStack.push(this);
    }
    deactivate() {
      this.isActive ? p.contextStack.pop() : h.fail(`attempt to deactivate inactive SPC this=${this}, active=${p.contextStack.top}`);
    }
    get path() {
      return null != this.pathHandle ? this.pathHandle : e.Agent.correlation.cInvalidPath;
    }
    end() {
      let b = !1;
      null != this.pathHandle ? (l.value && e.Logger.debug(`ending ${this} => LAF=${this.getLaf()}`), b = this.isIgnoredPath ? !0 : this.pathHandle.endPath(), this.pathHandle = void 0) : h.fail(`${this} attempt to end path twice`);
      return b;
    }
    spawnAsyncExecutionSubPath(b, d = 0) {
      b = this.spawnSubPath(b, !1, d);
      this.cleanClosedParentExecutor();
      null == this.theParentExecutor && (this.theParentExecutor = b);
      b.theParentExecutor = this.theParentExecutor;
      return b;
    }
    spawnAsyncInitiatorSubPath(b) {
      b = this.spawnSubPath(b);
      b.theParentExecutor = this;
      b.didInitiateAsyncOp = !0;
      return b;
    }
    spawnSubPath(b, d = !1, a = 0) {
      const c = l.value;
      b = m.getOptionalValue(b, this.sensorId);
      if (r()) {
        if (null != this.pathHandle) {
          var g = this.pathHandle.createLocalLink(d, b);
          c && e.Logger.debug(`${this} created ${d ? "" : "a"}synchronous locallink for new local path L[${g}]`);
        } else {
          null == this.lostAndFoundLocalLink ? (h.fail(`${this} has no lost-and-found-link, is didInitiateAsyncOp set?`), e.Logger.warning(`${this} has no lost-and-found-link, is didInitiateAsyncOp set?`)) : g = this.lostAndFoundLocalLink;
        }
        b = new p(g, m.getOptionalValue(b, this.sensorId));
        1 === a ? b.parentLocalLink = g : 2 === a && (b.lostAndFoundLocalLink = g, b.didInitiateAsyncOp = !0);
      } else {
        let l, q;
        null != this.pathHandle ? ([l, q] = this.createSubPathLink(b, d, a), c && (g = n.Tracing.traceContextToString(q), e.Logger.debug(`${this} created ${d ? "" : "a"}synchronous link for new sub path L[${l}], TC[${g}]`))) : null == this.lostAndFoundTraceContext ? (h.fail(`${this} has no lost-and-found-tag, is didInitiateAsyncOp set?`), e.Logger.warning(`${this} has no lost-and-found-tag, is didInitiateAsyncOp set?`)) : (q = this.lostAndFoundTraceContext, l = e.Agent.correlation.deserializeLinkFromString(this.lostAndFoundTraceContext.dtTag, 
        this.lostAndFoundTraceContext.traceParent, this.lostAndFoundTraceContext.traceState), c && (d = n.Tracing.traceContextToString(q), e.Logger.debug(`instantiating lost&found ${this} => L[${l}], TC[${d}]`)));
        b = new p(l, m.getOptionalValue(b, this.sensorId));
        1 === a ? b.parentTraceContext = q : 2 === a && (b.lostAndFoundTraceContext = q, b.didInitiateAsyncOp = !0);
      }
      c && e.Logger.debug(`${this} spawned ${b} from L(${this})`);
      return b;
    }
    createActivation(b) {
      const d = !this.open || null != this.currentActivation && this.currentActivation.isVirtual, a = d ? this.spawnSubPath() : this;
      if (a.valid) {
        return d && this.forwardParentExecutor(a), new f.MethodActivation({spc:a, endSpcOnExit:d, mode:b.mode, functionId:b.functionId, category:b.category, attachmentCreator:b.attachmentCreator, creator:b.creator});
      }
      l.value && e.Logger.debug(`${this.toString(!0)} ${this.valid ? `spawned(${a.toString()})` : "this"} subpath is not valid.`);
    }
    createCallbackActivation(b, d) {
      if (this.open) {
        if (this.valid) {
          return new f.MethodActivation({spc:this, functionId:b, creator:d, mode:1});
        }
        l.value && e.Logger.debug(`${this.toString(!0)} skip method creation on invalid path`);
      } else {
        if (null == (r() ? this.parentLocalLink : this.parentTraceContext)) {
          l.value && e.Logger.debug(`${this.toString(!0)}: parentLocalLink/parentTag is undefined`), h.fail(`${this} no parentLocalLink/parentTag present; have you requested one during start of path?`);
        } else {
          if (r()) {
            var a = new p(this.parentLocalLink, this.sensorId);
          } else {
            a = e.Agent.correlation.deserializeLinkFromString(this.parentTraceContext.dtTag, this.parentTraceContext.traceParent, this.parentTraceContext.traceState), a = new p(a, this.sensorId);
          }
          if (a.valid) {
            return this.forwardParentExecutor(a), new f.MethodActivation({spc:a, functionId:b, endSpcOnExit:!0, creator:d, mode:1});
          }
          l.value && e.Logger.debug(`${this.toString(!0)}: spawned(${a.toString()}) subpath is not valid.`);
        }
      }
    }
    createAddSerializeLink(b, d) {
      return null != this.pathHandle ? this.pathHandle.createAddSerializeLink(b, this.sensorId, d) : void 0;
    }
    createAddSerializeLinkToBlob(b) {
      return null != this.pathHandle ? this.pathHandle.createAddSerializeLinkToBlob(b, this.sensorId) : void 0;
    }
    onMethodEnter(b) {
      if (l.value) {
        const d = this.activationStack.map(b => b.toString()).join(" < ");
        e.Logger.debug(`${this}.onMethodEnter: push '${b}' to [${d}]`);
      }
      b.parentActivation = this.theCurrentActivation;
      this.theCurrentActivation = b;
    }
    onMethodExit(b) {
      if (l.value) {
        const d = this.activationStack.map(b => b.toString()).join(" < ");
        e.Logger.debug(`${this}.onMethodExit: pop '${b}' from [${d}]`);
      }
      h.assertStrictEqual(this.theCurrentActivation, b);
      this.theDidInitiatAsyncOpFlag && null == b.parentActivation && this.addLostAndFoundLink();
      this.asyncAggregateLink = void 0;
      this.theCurrentActivation = b.parentActivation;
      b.parentActivation = void 0;
    }
    getAsyncAggregateableLink() {
      b();
      if (null != this.lostAndFoundLocalLink) {
        return this.lostAndFoundLocalLink;
      }
      if (null != this.asyncAggregateLink) {
        return this.asyncAggregateLink;
      }
      if (null == this.pathHandle) {
        l.value && e.Logger.debug(`${this}.getAsyncAggregateableLink: can't create Link as there is no pathHandle`);
      } else {
        return this.asyncAggregateLink = this.pathHandle.createLocalLink(!1, e.Agent.correlation.SensorId.SENSOR_ID_NODEJS_LOST_AND_FOUND), l.value && e.Logger.debug(`${this}.getAsyncAggregateableLink: created ${this.asyncAggregateLink}`), this.asyncAggregateLink;
      }
    }
    addLostAndFoundLink() {
      const b = r();
      null == (b ? this.lostAndFoundLocalLink : this.lostAndFoundTraceContext) && (b && null != this.asyncAggregateLink ? this.lostAndFoundLocalLink = this.asyncAggregateLink : null == this.pathHandle ? l.value && e.Logger.debug(`${this} can't create LAF as there is no pathHandle`) : b ? (this.lostAndFoundLocalLink = this.pathHandle.createLocalLink(!1, e.Agent.correlation.SensorId.SENSOR_ID_NODEJS_LOST_AND_FOUND), l.value && e.Logger.debug(`${this} created LAF=${this.lostAndFoundLocalLink}`)) : (this.lostAndFoundTraceContext = 
      this.pathHandle.createAddSerializeLink(!1, e.Agent.correlation.SensorId.SENSOR_ID_NODEJS_LOST_AND_FOUND, n.Tracing.getTaggingMode()), l.value && e.Logger.debug(`${this} created LAF=${n.Tracing.traceContextToString(this.lostAndFoundTraceContext)}`)));
    }
    createSubPathLink(b, d, a) {
      let c;
      if (null != this.pathHandle) {
        const l = this.pathHandle.createLink();
        0 !== a && (c = l.serialize());
        a = l.duplicate();
        this.pathHandle.addLink(d, b, l);
      } else {
        h.fail(`${this} no pathHandle to create a link`), a = e.Agent.correlation.cInvalidLink;
      }
      return [a, c];
    }
    cleanClosedParentExecutor() {
      null == this.theParentExecutor || this.theParentExecutor.open || (this.theParentExecutor = void 0);
    }
    forwardParentExecutor(b) {
      this.cleanClosedParentExecutor();
      b.theParentExecutor = this.theParentExecutor;
    }
    getLaf() {
      return r() ? this.lostAndFoundLocalLink : this.lostAndFoundTraceContext;
    }
  }
  a.SubPathContext = p;
  p.contextStack = new x;
  p.instanceCounter = 0;
});
S("src/lib/util/InvocationUtil", ["require", "exports", "src/lib/SubPathContext"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class h {
    static dynatraceRegularInvoke(a, e, g) {
      switch(g.length) {
        case 0:
          return e.call(a);
        case 1:
          return e.call(a, g[0]);
        case 2:
          return e.call(a, g[0], g[1]);
        case 3:
          return e.call(a, g[0], g[1], g[2]);
        case 4:
          return e.call(a, g[0], g[1], g[2], g[3]);
        case 5:
          return e.call(a, g[0], g[1], g[2], g[3], g[4]);
        default:
          return e.apply(a, g);
      }
    }
    static dynatraceOnServiceExecutionIndicator(a, e, g) {
      switch(g.length) {
        case 0:
          return e.call(a);
        case 1:
          return e.call(a, g[0]);
        case 2:
          return e.call(a, g[0], g[1]);
        case 3:
          return e.call(a, g[0], g[1], g[2]);
        case 4:
          return e.call(a, g[0], g[1], g[2], g[3]);
        case 5:
          return e.call(a, g[0], g[1], g[2], g[3], g[4]);
        default:
          return e.apply(a, g);
      }
    }
  }
  a.doInvoke = h.dynatraceRegularInvoke;
  class f {
    onFirstContextActivation() {
      a.doInvoke = h.dynatraceOnServiceExecutionIndicator;
    }
    onLastContextDeactivation() {
      a.doInvoke = h.dynatraceRegularInvoke;
    }
  }
  e.SubPathContext.addContextStackListener(new f);
  class k {
    constructor(a, e) {
      this.obj = a;
      this.didThrow = e;
    }
    static makeRetVal(a) {
      return new k(a, !1);
    }
    static makeException(a) {
      return new k(a, !0);
    }
    get retVal() {
      return this.didThrow ? void 0 : this.obj;
    }
    get exception() {
      return this.didThrow ? this.obj : void 0;
    }
    rethrow() {
      if (this.didThrow) {
        throw this.obj;
      }
      return this.obj;
    }
  }
  a.SafeInvokeRetVal = k;
  a.safeInvoke = function(e, f, g) {
    try {
      return k.makeRetVal(a.doInvoke(e, f, g));
    } catch (c) {
      return k.makeException(c);
    }
  };
});
S("src/lib/Branding", ["require", "exports", "src/lib/Configuration", "src/lib/Debug"], function(t, a, e, h) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class f {
    get productNameLowerCase() {
      h.assert(0 !== e.Configuration.activeProduct, "Configuration.activeProduct not set");
      return 1 === e.Configuration.activeProduct ? "dt" : "one";
    }
    get productNameCamelCase() {
      h.assert(0 !== e.Configuration.activeProduct, "Configuration.activeProduct not set");
      return 1 === e.Configuration.activeProduct ? "Dt" : "One";
    }
    get prodcutNameAllCaps() {
      h.assert(0 !== e.Configuration.activeProduct, "Configuration.activeProduct not set");
      return 1 === e.Configuration.activeProduct ? "DT" : "ONE";
    }
  }
  t = new f;
  a.Branding = t;
});
S("src/lib/FileLogger", ["require", "exports", "path", "fs", "src/lib/Branding"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k {
    constructor() {
      this.appendFileCallback = () => {
        0 < this.queue.length && this.doWrite();
      };
      this.queue = [];
    }
    init(a, k) {
      let g = !0;
      try {
        const c = e.join(a, "nodejs");
        try {
          h.mkdirSync(c);
        } catch (r) {
        }
        this.logFileName = e.join(c, `${f.Branding.productNameLowerCase}agent_${k}_managed_${process.pid}.log`);
        try {
          h.unlinkSync(this.logFileName);
        } catch (r) {
        }
      } catch (c) {
        this.logFileName = void 0, g = !1;
      }
      return g;
    }
    static findLogFolder(a, f) {
      for (;;) {
        const g = e.join(a, "log");
        try {
          h.statSync(g);
          const c = e.join(a, "agent/lib64");
          h.statSync(c);
          a = g;
          break;
        } catch (c) {
        }
        --f;
        a = e.dirname(a);
        if ("" === a || 0 >= f) {
          a = void 0;
          break;
        }
      }
      return a;
    }
    get fileName() {
      return this.logFileName;
    }
    get initialized() {
      return void 0 !== this.logFileName;
    }
    write(a) {
      this.logFileName && (this.queue.push(a), 1 === this.queue.length && this.doWrite());
    }
    doWrite() {
      null != this.logFileName && h.appendFile(this.logFileName, this.queue.shift(), this.appendFileCallback);
    }
  }
  a.FileLogger = k;
});
S("src/lib/Logger", "require exports util src/lib/Agent src/lib/util/CoreUtil src/lib/util/InvocationUtil src/lib/FileLogger src/lib/Configuration".split(" "), function(t, a, e, h, f, k, n, m) {
  function g(b) {
    return b >= a.control.logLevel;
  }
  function c(b, ...d) {
    return q.doWrite(b, d);
  }
  function r() {
    return q.condWrite(l.INFO, arguments);
  }
  function b() {
    return q.condWrite(l.SEVERE, arguments);
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  var d;
  (function(b) {
    b[b.BUFFERED = 0] = "BUFFERED";
    b[b.NATIVE = 1] = "NATIVE";
    b[b.MANAGED = 2] = "MANAGED";
  })(d = a.Mode || (a.Mode = {}));
  var l;
  (function(b) {
    b[b.INFO = 4] = "INFO";
    b[b.WARNING = 5] = "WARNING";
    b[b.SEVERE = 6] = "SEVERE";
    b[b.DEBUG = 7] = "DEBUG";
    b[b.NONE = 8] = "NONE";
  })(l = a.Level || (a.Level = {}));
  class x {
    constructor(b, d) {
      this.logLevel = b;
      this.msg = d;
      this.timeStamp = Date.now();
    }
  }
  class p {
    constructor() {
      this.logFn = this.writeBufferedLog;
      this.bufferedLogEntries = [];
      this.discardedLogEntryCount = 0;
    }
    get mode() {
      let a;
      switch(this.logFn) {
        case this.writeManagedLog:
          a = d.MANAGED;
          break;
        case this.writeNativeLog:
          a = d.NATIVE;
          break;
        case this.writeBufferedLog:
          a = d.BUFFERED;
          break;
        default:
          a = d.BUFFERED, b("could not determine logger mode");
      }
      return a;
    }
    set mode(a) {
      switch(a) {
        case d.NATIVE:
          a === d.NATIVE && h.Agent.nativeAgent && (this.logFn = this.writeNativeLog, this.updateLogLevelsFromNative(), this.flushLogBuffer());
          break;
        case d.MANAGED:
          this.logFn = this.writeManagedLog;
          this.flushLogBuffer();
          break;
        case d.BUFFERED:
          this.logFn = this.writeBufferedLog;
          break;
        default:
          b("unknown logger mode: " + a);
      }
      c(l.INFO, "switched log mode to %s", d[this.mode]);
    }
    updateLogLevelsFromNative() {
      if (h.Agent.nativeAgent) {
        const b = h.Agent.nativeAgent.consoleLogLevel, d = h.Agent.nativeAgent.fileLogLevel;
        if (a.control.consoleLogLevel !== b || a.control.fileLogLevel !== d) {
          a.control.consoleLogLevel = b, a.control.fileLogLevel = d, r(`update log levels from native consoleLogLevel=${l[a.control.consoleLogLevel]}, fileLogLevel=${l[a.control.fileLogLevel]}`);
        }
      }
    }
    assembleLogHeader(b) {
      const a = new Date;
      return e.format("%d-%s-%s %s:%s:%s.%s UTC [%s] %s [node] ", a.getUTCFullYear(), f.pad(a.getUTCMonth() + 1), f.pad(a.getUTCDate()), f.pad(a.getUTCHours()), f.pad(a.getUTCMinutes()), f.pad(a.getUTCSeconds()), (a.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5), f.pad(process.pid, 8), f.pad(l[b], 8, " "));
    }
    writeManagedLog(b, d) {
      g(b) && (d = this.assembleLogHeader(b) + d, b >= a.control.consoleLogLevel && console.log(d), b >= a.control.fileLogLevel && (this.fileLogger || (this.fileLogger = new n.FileLogger, a.control.getRootLogDir ? this.fileLogger.init(a.control.getRootLogDir, m.Configuration.appName || m.Configuration.scriptName) : (b = n.FileLogger.findLogFolder(process.env.DT_STORAGE ? process.env.DT_STORAGE : m.Configuration.rootFolder, 6)) && this.fileLogger.init(b, m.Configuration.appName || m.Configuration.scriptName)), 
      this.fileLogger && this.fileLogger.write(d + "\n")));
    }
    writeBufferedLog(b, d) {
      if (0 === this.bufferedLogEntries.length) {
        this.discardedLogEntryCount = 0;
      } else {
        if (this.bufferedLogEntries.length >= a.control.bufferedLogEntryCountMax) {
          do {
            this.bufferedLogEntries.shift(), ++this.discardedLogEntryCount;
          } while (this.bufferedLogEntries.length >= a.control.bufferedLogEntryCountMax);
          this.bufferedLogEntries[0].msg = `[${this.discardedLogEntryCount} discarded prior log entries] ${this.bufferedLogEntries[0].msg}`;
        }
      }
      this.bufferedLogEntries.push(new x(b, d));
    }
    flushLogBuffer() {
      this.bufferedLogEntries.forEach(b => {
        const a = `[buffered ${Date.now() - b.timeStamp}ms ago] ${b.msg}`;
        this.logFn(b.logLevel, a);
      });
      this.bufferedLogEntries.length = 0;
    }
    writeNativeLog(b, a) {
      h.Agent.nativeAgent && h.Agent.nativeAgent.log(b, a);
    }
    condWrite(b, a) {
      return g(b) && this.doWrite(b, a);
    }
    doWrite(b, a) {
      a = k.doInvoke(null, e.format, a);
      this.logFn(b, a);
      return !0;
    }
  }
  const q = new p;
  class v {
    constructor() {
      this.bufferedLogEntryCountMax = 100;
      this.currLogLevel = l.INFO;
      this.currConLogLevel = l.NONE;
      this.currFileLogLevel = l.INFO;
    }
    get mode() {
      return q.mode;
    }
    set mode(b) {
      q.mode = b;
    }
    get logLevel() {
      return this.currLogLevel;
    }
    get consoleLogLevel() {
      return this.currConLogLevel;
    }
    set consoleLogLevel(b) {
      this.currConLogLevel = b;
      this.updateLogLevel();
    }
    get fileLogLevel() {
      return this.currFileLogLevel;
    }
    set fileLogLevel(b) {
      this.currFileLogLevel = b;
      this.updateLogLevel();
    }
    updateLoggingOptions(b) {
      b.logdir && (this.rootLogDir = b.logdir.toString());
      if (b.loglevelcon) {
        const a = l[b.loglevelcon.toUpperCase()];
        a ? this.currConLogLevel = a : r(`invalid option loglevelcon=${b.loglevelcon}`);
      }
    }
    get getRootLogDir() {
      return this.rootLogDir;
    }
    updateLogLevel() {
      this.currLogLevel = Math.min(this.currConLogLevel, this.currFileLogLevel);
    }
  }
  a.LogControl = v;
  a.isLoggable = g;
  a.write = c;
  a.info = r;
  a.warning = function() {
    return q.condWrite(l.WARNING, arguments);
  };
  a.severe = b;
  a.debug = function() {
    return q.condWrite(l.DEBUG, arguments);
  };
  a.control = new v;
});
S("src/lib/Configuration", ["require", "exports", "path", "src/lib/Logger", "src/lib/util/CoreUtil"], function(t, a, e, h, f) {
  function k(a) {
    a = a.trim();
    if (a.startsWith("{")) {
      var e = JSON.parse(f.stripByteOrderMark(a));
    } else {
      e = {};
      a = a.split(",");
      for (let b of a) {
        if (b = b.trim(), 0 < b.length) {
          var g = b.split("=");
          if (2 !== g.length) {
            throw Error(`invalid agent option format "${b}"`);
          }
          a = g[0].trim();
          g = g[1].trim();
          var c = +g;
          if (Number.isNaN(c)) {
            var h = g.toLowerCase();
            c = "true" === h;
            h = "false" === h;
            c = c || h ? c : g;
          }
          e[a] = c;
        }
      }
    }
    return e;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.parseAgentOptionString = k;
  a.Configuration = {activeProduct:0, maxSqlStringLen:512, rootFolder:(module.__DT_NODE_OBFUSCATED_AGENT__ ? __dirname : e.dirname(__dirname)) + e.sep, appName:void 0, scriptName:1 < process.argv.length ? e.basename(process.argv[1]) : "", processOptions:function(e) {
    let f;
    try {
      process.env.DT_NODE_OPTIONS_FILE ? (h.info(`acquiring alternative agent options from ${process.env.DT_NODE_OPTIONS_FILE}`), f = t(process.env.DT_NODE_OPTIONS_FILE)) : process.env.DT_NODE_OPTIONS && (h.info(`acquiring alternative agent options from environment: ${process.env.DT_NODE_OPTIONS}`), f = k(process.env.DT_NODE_OPTIONS));
    } catch (g) {
      h.info(`reading alternative options failed with ${g}`);
    }
    if (null != f) {
      for (const a in e) {
        null == f[a] && (f[a] = e[a]);
      }
    } else {
      f = e;
    }
    null != f.tenant ? (a.Configuration.activeProduct = 2, a.Configuration.maxSqlStringLen = 4096) : (a.Configuration.activeProduct = 1, a.Configuration.maxSqlStringLen = 512);
    return f;
  }};
});
S("src/lib/sensors/UriRuleSensorProperty", ["require", "exports", "src/lib/Logger", "src/lib/util/CoreUtil"], function(t, a, e, h) {
  Object.defineProperty(a, "__esModule", {value:!0});
  var f;
  (function(a) {
    a[a.EQUALS = 0] = "EQUALS";
    a[a.CONTAINS = 1] = "CONTAINS";
    a[a.ENDS = 2] = "ENDS";
    a[a.STARTS = 3] = "STARTS";
  })(f || (f = {}));
  (function(a) {
    a.matches = function(e, g, c) {
      switch(c) {
        case a.CONTAINS:
          return e.includes(g);
        case a.ENDS:
          return e.endsWith(g);
        case a.EQUALS:
          return e === g;
        case a.STARTS:
          return e.startsWith(g);
      }
      return !1;
    };
    a.fromString = function(e) {
      switch(e.toLowerCase()) {
        case "equals":
          return a.EQUALS;
        case "ends":
          return a.ENDS;
        case "contains":
          return a.CONTAINS;
        case "starts":
          return a.STARTS;
      }
      throw Error("illegal match string");
    };
  })(f || (f = {}));
  class k {
    constructor(a) {
      let e = !1;
      h.isString(a.uriPattern) && h.isString(a.uriPatternMatch) && (this.uriPattern = a.uriPattern, this.uriPatternMatch = f.fromString(a.uriPatternMatch), e = !0);
      h.isString(a.queryStringPattern) && h.isString(a.queryStringPatternMatch) && (this.queryStringPattern = a.queryStringPattern, this.queryStringPatternMatch = f.fromString(a.queryStringPatternMatch), e = !0);
      if (!e) {
        throw Error("malformed UriRule");
      }
    }
    match(a, e) {
      let g = !0;
      null != this.uriPattern && (g = f.matches(a, this.uriPattern, this.uriPatternMatch));
      null != this.queryStringPattern && (g = g && f.matches(e, this.queryStringPattern, this.queryStringPatternMatch));
      return g;
    }
  }
  a.UriRule = k;
  a.parseUriRules = function(a, f) {
    if (Array.isArray(a)) {
      try {
        const e = [];
        for (const c of a) {
          e.push(new k(c));
        }
        return e;
      } catch (g) {
        e.info(`${f} has malformed UriRules ${g}`);
      }
    }
    return [];
  };
});
S("src/lib/util/HttpHeader", ["require", "exports", "src/lib/util/CoreUtil"], function(t, a, e) {
  function h(b, a) {
    return b === a.normalizedName;
  }
  function f(b, a) {
    return b.length === a.rawName.length && b === a.normalizedName;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class k {
    constructor(b, a) {
      this.normalizedHeaderName = b;
      this.associatedData = a;
    }
    toString() {
      return this.normalizedHeaderName;
    }
  }
  a.HeaderAssociatedData = k;
  class n {
    constructor(b) {
      this.matchHeaderName = (this.normalized = b) ? h : f;
    }
    find(b, a) {
      return b.findIndex(b => this.matchHeaderName(b.toString(), a));
    }
    cloneHeaderValue(b) {
      return Array.isArray(b) ? b.slice() : b;
    }
  }
  a.HeaderContainerManipulator = n;
  class m extends n {
    constructor(b, a, d) {
      super(d);
      this.headers = b;
      this.cloningMode = a;
      this.needsCloning = 0 !== a;
    }
    prepareForHeaderModification() {
      this.needsCloning && (this.headers = this.cloneHeaders(this.headers, 2 === this.cloningMode), this.needsCloning = !1);
    }
  }
  class g {
    get firstValue() {
      const b = this.value;
      return e.isString(b) ? b : b[0];
    }
    appendValue(b) {
      this.owner.prepareForHeaderModification();
      const a = this.value;
      Array.isArray(a) ? a.push(b) : this.value = [a, b];
    }
    get normalizedName() {
      return this.owner.normalized ? this.rawName : this.rawName.toLowerCase();
    }
    doesMatch(b) {
      return this.owner.matchHeaderName(b, this);
    }
  }
  class c extends g {
    constructor(b) {
      super();
      this.owner = b;
      this.currIdx = 0;
    }
    get rawName() {
      return this.owner.headers[this.currIdx][0];
    }
    get value() {
      return this.owner.headers[this.currIdx][1];
    }
    set value(b) {
      this.owner.prepareForHeaderModification();
      this.owner.headers[this.currIdx][1] = b;
    }
    remove() {
      this.owner.prepareForHeaderModification();
      this.owner.headers.splice(this.currIdx, 1);
      --this.currIdx;
    }
  }
  class r extends m {
    constructor(b, a = 0, d = !1) {
      super(b, a, d);
    }
    forEach(b) {
      const a = new c(this);
      let d;
      for (; !d && a.currIdx < this.headers.length;) {
        d = b(a), ++a.currIdx;
      }
      return d;
    }
    forMatching(b, a) {
      const d = new c(this);
      let l;
      for (; !l && d.currIdx < this.headers.length;) {
        const c = this.find(b, d);
        0 <= c && (l = a(d, c, b[c]));
        ++d.currIdx;
      }
      return l;
    }
    addHeaderEntity(b, a) {
      this.prepareForHeaderModification();
      this.headers.push([b, a]);
    }
    cloneHeaders(b, a) {
      let d;
      a ? (d = [], d.length = b.length, b.forEach((b, a) => {
        const c = this.cloneHeaderValue(b[1]);
        d[a] = [b[0], c];
      })) : d = b.slice();
      return d;
    }
  }
  a.HeadersArrayManipulator = r;
  class b extends g {
    constructor(b) {
      super();
      this.owner = b;
    }
    get rawName() {
      return this.currKey;
    }
    get value() {
      return this.owner.headers[this.currKey];
    }
    set value(b) {
      this.owner.prepareForHeaderModification();
      this.owner.headers[this.currKey] = b;
    }
    remove() {
      this.owner.prepareForHeaderModification();
      delete this.owner.headers[this.currKey];
    }
  }
  class d extends m {
    constructor(b, a = 0, d = !1) {
      super(b, a, d);
    }
    forEach(a) {
      const d = new b(this), c = Object.keys(this.headers);
      let l = 0, e;
      for (; !e && l < c.length;) {
        d.currKey = c[l], e = a(d), ++l;
      }
      return e;
    }
    forMatching(a, d) {
      let c;
      const l = new b(this);
      if (this.normalized) {
        for (var e = 0; !c && e < a.length; ++e) {
          var g = a[e], f = g.toString();
          null != this.headers[f] && (l.currKey = f, c = d(l, e, g));
        }
      } else {
        for (e = Object.keys(this.headers), g = 0; !c && g < e.length;) {
          l.currKey = e[g], f = this.find(a, l), 0 <= f && (c = d(l, f, a[f])), ++g;
        }
      }
      return c;
    }
    addHeaderEntity(b, a) {
      this.prepareForHeaderModification();
      this.headers[b] = a;
    }
    cloneHeaders(b, a) {
      let d;
      a ? (d = {}, Object.keys(b).forEach(a => {
        d[a] = this.cloneHeaderValue(b[a]);
      })) : d = Object.assign({}, b);
      return d;
    }
  }
  a.HeadersObjectManipulator = d;
  class l extends g {
    constructor(b) {
      super();
      this.owner = b;
    }
    get rawName() {
      return this.owner.headers[this.currKey][0];
    }
    get normalizedName() {
      return this.currKey;
    }
    get value() {
      return this.owner.headers[this.currKey][1];
    }
    set value(b) {
      this.owner.prepareForHeaderModification();
      this.owner.headers[this.currKey][1] = b;
    }
    remove() {
      this.owner.prepareForHeaderModification();
      delete this.owner.headers[this.currKey];
    }
  }
  class x extends m {
    constructor(b, a = 0) {
      super(b, a, !0);
    }
    forEach(b) {
      const a = new l(this), d = Object.keys(this.headers);
      let c = 0, e;
      for (; !e && c < d.length;) {
        a.currKey = d[c], e = b(a), ++c;
      }
      return e;
    }
    forMatching(b, a) {
      const d = new l(this);
      let c;
      for (let l = 0; !c && l < b.length; ++l) {
        const e = b[l], g = e.toString();
        null != this.headers[g] && (d.currKey = g, c = a(d, l, e));
      }
      return c;
    }
    addHeaderEntity(b, a) {
      this.prepareForHeaderModification();
      this.headers[b] = [b, a];
    }
    cloneHeaders(b, a) {
      let d;
      a ? (d = {}, Object.keys(b).forEach(a => {
        const c = b[a];
        d[a] = [c[0], this.cloneHeaderValue(c[1])];
      })) : d = Object.assign({}, b);
      return d;
    }
  }
  a.ExtendedHeadersObjectManipulator = x;
  class p {
    constructor(b, a = 0, d = !1) {
      this.manipulator = p.createSpecificManipulator(b, a, d);
    }
    get headers() {
      return this.manipulator.headers;
    }
    forEach(b) {
      return this.manipulator.forEach(b);
    }
    forMatching(b, a) {
      return Array.isArray(b) ? this.manipulator.forMatching(b, a) : this.manipulator.forMatching([b], a);
    }
    remove(b, a = !0) {
      b = Array.isArray(b) ? b : [b];
      this.manipulator.forMatching(b, b => {
        b.remove();
        return !a;
      });
    }
    append(b, a) {
      this.manipulator.forMatching([b], b => {
        b.appendValue(a);
        return !0;
      }) || this.manipulator.addHeaderEntity(b, a);
    }
    get(b) {
      let a;
      this.forMatching(b, b => {
        a = b.value;
        return !0;
      });
      return a;
    }
    set(b, a) {
      this.manipulator.forMatching([b], b => {
        b.value = a;
        return !0;
      }) || this.manipulator.addHeaderEntity(b, a);
    }
    static createSpecificManipulator(b, a = 0, c = !1) {
      let l;
      if (Array.isArray(b)) {
        l = new r(b, a, c);
      } else {
        const g = Object.keys(b);
        if (0 < g.length) {
          const d = b[g[0]];
          Array.isArray(d) && 2 === d.length && e.isString(d[0]) && g[0] === d[0].toLowerCase() && (l = new x(b, a));
        }
        null == l && (l = new d(b, a, c));
      }
      return l;
    }
  }
  a.HeaderManipulator = p;
});
S("src/lib/util/HttpUtil", "require exports http src/lib/Agent src/lib/RunTimeProperty src/lib/sensors/SensorConstants src/lib/util/CoreUtil".split(" "), function(t, a, e, h, f, k, n) {
  function m(b) {
    var a = b.length;
    2 <= a && '"' === b[0] && '"' === b[a - 1] && (b = b.substr(1, a - 2));
    if ("_" === b[0] || "unknown" === b) {
      return "";
    }
    if ("[" === b[0]) {
      return a = b.indexOf("]"), -1 !== a ? b.substring(1, a) : b.substr(1);
    }
    a = b.indexOf(":");
    return -1 !== a ? -1 !== b.indexOf(":", a + 1) ? b : b.substr(0, a) : b;
  }
  function g() {
    null == b && (b = new f.NumberSetting("sensor.stringTruncationLimit.webrequest", h.Agent.correlation.AgentConfiguration.DEFAULT_WEBREQUEST_STRING_TRUNCATION_LIMIT));
    return b.value;
  }
  function c(b, a, d, c, e, g, f) {
    if (null != g && (e = e.toLowerCase(), d || -1 !== c.indexOf(e))) {
      if (Array.isArray(g)) {
        for (const d of g) {
          null != d && b.keyValueCached(a, e, `${d}`, f);
        }
      } else {
        b.keyValueCached(a, e, `${g}`, f);
      }
    }
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.outHeadersKey = function() {
    const b = new e.OutgoingMessage;
    return Object.getOwnPropertySymbols(b).find(b => {
      b = b.toString();
      return "Symbol(outHeadersKey)" === b || "Symbol(kOutHeaders)" === b;
    });
  }();
  a.getHeaderNames = function(b) {
    return b.getHeaderNames();
  };
  a.getClientIPDetectionHeaders = function() {
    return n.hasProperty(h.Agent.configuration, "uemConfig", "globalUemConfiguration", "clientIPDetectionHeaders") ? h.Agent.configuration.uemConfig.globalUemConfiguration.clientIPDetectionHeaders : [];
  };
  a.getHostDetectionHeaders = function() {
    return n.hasProperty(h.Agent.configuration, "uemConfig", "globalUemConfiguration", "hostDetectionHeaders") ? h.Agent.configuration.uemConfig.globalUemConfiguration.hostDetectionHeaders : [];
  };
  a.lookupKeyname = function(b, a) {
    a = a.toLowerCase();
    for (const d in b) {
      if (d.toLowerCase() === a) {
        return d;
      }
    }
  };
  a.toStringArrayLc = function(b) {
    const a = [];
    for (const d of b) {
      n.isString(d) && a.push(d.toLowerCase());
    }
    return a;
  };
  a.normalizeHeaders = function(b) {
    const a = {};
    var d = Object.keys(b);
    for (const l of d) {
      var c = b[l];
      if (null != c && 0 !== c.length) {
        switch(d = l.toLowerCase(), d) {
          case "age":
          case "authorization":
          case "content-length":
          case "content-type":
          case "etag":
          case "expires":
          case "from":
          case "host":
          case "if-modified-since":
          case "if-unmodified-since":
          case "last-modified":
          case "location":
          case "max-forwards":
          case "proxy-authorization":
          case "referer":
          case "retry-after":
          case "server":
          case "user-agent":
            null == a[d] && (a[d] = Array.isArray(c) ? c[0] : c);
            break;
          case "set-cookie":
            null == a[d] ? a[d] = Array.isArray(c) ? c : [c] : Array.isArray(c) ? a[d] = a[d].concat(c) : a[d].push(c);
            break;
          default:
            const b = "cookie" === d ? "; " : ", ";
            c = Array.isArray(c) ? c.join(b) : c;
            a[d] = null == a[d] ? c : a[d] + `${b}${c}`;
        }
      }
    }
    return a;
  };
  a.getClientIp = function(b, a) {
    for (var d of a) {
      if (a = b[d.toLowerCase()], null != a) {
        b = a.indexOf(",");
        b = (-1 === b ? a : a.substring(0, b)).toLowerCase();
        d = b.indexOf("for=");
        if (-1 === d) {
          return -1 !== b.indexOf("=") ? "" : m(b);
        }
        a = b.indexOf(";");
        b = -1 === a ? b.substr(d + 4) : b.substring(d + 4, a);
        return m(b);
      }
    }
  };
  a.getHostname = function(b, a) {
    for (let c of a) {
      if (c = c.toLowerCase(), a = b[c], null != a) {
        if ("forwarded" === c) {
          b = a.split(";");
          for (var d of b) {
            if (b = d.split("="), 2 === b.length && -1 !== b[0].toLowerCase().indexOf("host")) {
              b = b[1].split(",");
              for (let a of b) {
                if (a = a.trim().replace(/"/g, ""), 0 < a.length) {
                  return a;
                }
              }
            }
          }
          return "";
        }
        d = a.indexOf(",");
        return -1 === d ? a : a.substring(0, d);
      }
    }
    return b.host || b[":authority"] || "";
  };
  const r = process.binding("pipe_wrap").Pipe;
  a.getRemoteAddress = function(b) {
    return null == b ? "0.0.0.0" : b._handle instanceof r ? "127.0.0.1" : b.remoteAddress || "0.0.0.0";
  };
  a.shallCapturePostRequestParameters = function(b, a, d) {
    if ("POST" !== b || !d.shallCaptureRequestData()) {
      return !1;
    }
    b = a["content-type"];
    return n.isString(b) && "application/x-www-form-urlencoded" === b.toLowerCase() ? !0 : !1;
  };
  let b;
  a.getWebRequestMaxStringLen = g;
  a.fillOutgoingHeaders = function(b, a, d, e, f) {
    const l = g();
    if (Array.isArray(d)) {
      for (const g of d) {
        Array.isArray(g) && 2 === g.length && n.isString(g[0]) && c(b, a, e, f, g[0], g[1], l);
      }
    } else {
      for (const g in d) {
        c(b, a, e, f, g, d[g], l);
      }
    }
  };
  const d = new RegExp(`(?:^|.*; *)${k.cAdkCookieName}=([^;]+)(?:; *)?`);
  a.getTraceContext = function(b) {
    if (null != b) {
      var a = b[k.cHttpTaggingHeader], c = b[k.cHttpTraceParent];
      if (n.isString(c)) {
        var l = b[k.cHttpTraceState];
        l = n.isString(l) ? l : void 0;
      } else {
        c = void 0;
      }
      if (n.isString(a) || null == a && n.isString(c)) {
        return {dtTag:a, traceParent:c, traceState:l};
      }
      b = b.cookie;
      if (n.isString(b) && (b = b.trim().match(d))) {
        return b = b[1].trim(), '"' === b.charAt(0) && (b = b.slice(1, -1)), {dtTag:b, traceParent:c, traceState:l};
      }
    }
  };
});
S("src/lib/sensors/WebRequestSensorProperties", "require exports url src/lib/sensors/UriRuleSensorProperty src/lib/Logger src/lib/util/CoreUtil src/lib/util/HttpUtil".split(" "), function(t, a, e, h, f, k, n) {
  function m(b, a) {
    return Array.isArray(b) ? n.toStringArrayLc(b) : a;
  }
  function g(b, a) {
    return k.isBoolean(b) ? b : a;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const c = [], r = [], b = [], d = [];
  class l {
    constructor(a) {
      this.theCaptureAllRequestHeaders = !1;
      this.theRequestHeadersToCapture = c;
      this.theCaptureAllResponseHeaders = !1;
      this.theResponseHeadersToCapture = r;
      this.theRequestParametersToCapture = b;
      this.theUriRulesWhiteList = this.theCaptureAllRequestParameters = !1;
      this.theUriRules = d;
      this.theEnableHttp2Transformer = !1;
      this.update(a);
    }
    update(a) {
      if (k.hasProperty(a, "sensorProperties")) {
        a = a.sensorProperties;
        this.theCaptureAllRequestHeaders = g(a.captureAllRequestHeaders, !1);
        this.theRequestHeadersToCapture = m(a.requestHeadersToCapture, c);
        this.theCaptureAllResponseHeaders = g(a.captureAllResponseHeaders, !1);
        this.theResponseHeadersToCapture = m(a.responseHeadersToCapture, r);
        var d = a.requestParametersToCapture;
        if (Array.isArray(d)) {
          {
            const b = [];
            for (l of d) {
              k.isString(l) && b.push(l);
            }
            var l = b;
          }
        } else {
          l = b;
        }
        this.theRequestParametersToCapture = l;
        this.theCaptureAllRequestParameters = g(a.captureAllRequestParameters, !1);
        this.theUriRulesWhiteList = g(a.uriRulesWhiteList, !1);
        this.theUriRules = h.parseUriRules(a.uriRules, "WebRequestSensorConfig.sensorProperties");
        this.theEnableHttp2Transformer = g(a.enableHttp2Transformer, !1);
      } else {
        f.info("WebRequestSensorConfig has no sensorProperties field");
      }
    }
    get captureAllRequestHeaders() {
      return this.theCaptureAllRequestHeaders;
    }
    get requestHeadersToCapture() {
      return this.theRequestHeadersToCapture;
    }
    get captureAllResponseHeaders() {
      return this.theCaptureAllResponseHeaders;
    }
    get responseHeadersToCapture() {
      return this.theResponseHeadersToCapture;
    }
    get requestParametersToCapture() {
      return this.theRequestParametersToCapture;
    }
    get captureAllRequestParameters() {
      return this.theCaptureAllRequestParameters;
    }
    get enableHttp2Transformer() {
      return this.theEnableHttp2Transformer;
    }
    get uriRulesWhiteList() {
      return this.theUriRulesWhiteList;
    }
    get uriRules() {
      return this.theUriRules;
    }
    shallCaptureRequestData() {
      return this.captureAllRequestParameters || 0 < this.requestParametersToCapture.length;
    }
    shallCaptureUrl(b) {
      if (!k.isString(b) || 0 === this.theUriRules.length) {
        return !this.theUriRulesWhiteList;
      }
      const a = e.parse(b);
      b = this.theUriRules.some(b => b.match(a.pathname || "", a.query || ""));
      return this.theUriRulesWhiteList ? b : !b;
    }
  }
  a.WebRequestSensorProperties = l;
});
S("src/lib/sensors/SensorConfig", ["require", "exports"], function(t, a) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.cConfigKeyPrefix = "Node.";
  a.cSdkConfigKeyPrefix = "sdk.";
});
S("src/lib/sensors/PredefinedInstrumentationRules", ["require", "exports", "src/lib/Patch"], function(t, a, e) {
  function h() {
    if (null == f) {
      {
        const a = {"Node.Core.FileSystem":{type:"ContextPassing", associatedModules:{fs:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLast, instrumentationStrategy:1, propertiesToCopy:["native"], rules:[{functionNames:"rename ftruncate truncate chown fchown chmod fchmod stat lstat fstat link symlink readlink realpath unlink rmdir mkdir readdir close open utimes futimes fsync write read readFile writeFile appendFile exists fdatasync mkdtemp access".split(" ")}, {functionNames:["lchmod", "lchown", 
        "copyFile", "writev", "opendir"], ignoreMissing:!0}, {subComponentName:"realpath", rules:[{functionNames:["native"], ignoreMissing:!0}]}, {subComponentName:"Dir", patchPrototype:!0, ignoreMissing:!0, rules:[{functionNames:["read", "close"]}]}]}}}, "Node.Core.Process":{type:"ContextPassing", associatedModules:{"implicit:process":{asyncTrackingMode:e.AsyncTrackingMode.CallbackFirst, instrumentationStrategy:1, rules:[{functionNames:["nextTick"]}, {functionNames:["_nextDomainTick"], ignoreMissing:!0}]}}}, 
        "Node.Core.DNS":{type:"ContextPassing", associatedModules:{dns:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLast, rules:[{subComponentName:"Resolver", patchPrototype:!0, nodeVersionCriteria:">=8.3.0", rules:[{functionNames:"resolve resolve4 resolve6 resolveMx resolveTxt resolveSrv resolveNs resolveCname resolveNaptr reverse resolveSoa resolvePtr resolveAny".split(" ")}]}, {functionNames:"lookup resolve resolve4 resolve6 resolveMx resolveTxt resolveSrv resolveNs resolveCname resolveNaptr reverse lookupService resolveSoa resolvePtr".split(" ")}, 
        {functionNames:["resolveAny"], nodeVersionCriteria:">=8.2.0"}]}}}, "Node.Core.Timers":{type:"TimerSensor", associatedModules:{timers:{instrumentationStrategy:1}}}, "Node.Core.Events":{type:"EventEmitterContextPassing", associatedModules:{events:{instrumentationStrategy:1}}}, "Node.Core.Promise":{type:"Promise", associatedModules:{"implicit:Promise":{instrumentationStrategy:1}, bluebird:{instrumentationStrategy:0}, "promise-polyfill":{instrumentationStrategy:0}, q:{instrumentationStrategy:0}, 
        "es6-promise":{instrumentationStrategy:0}, mpromise:{instrumentationStrategy:0}}}, "Node.Core.Crypto":{type:"CryptoSensor", associatedModules:{crypto:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLast, rules:[{functionNames:["pbkdf2", "randomBytes"]}, {functionNames:["randomFill", "scrypt", "generateKeyPair"], ignoreMissing:!0}]}}}, "Node.ModuleSubstitutions":{type:"ModuleSubstitution", associatedModules:{"graceful-fs":{moduleVersionCriteria:"<4.0.0"}}}, "Node.DisabledModules":{type:"DisabledModules", 
        moduleAllowPrereleaseCriteria:!0, associatedModules:{newrelic:{}, appdynamics:{}, longjohn:{}}}, "Node.WebRequest":{type:"WebRequest", associatedModules:{http:{instrumentationStrategy:1}, https:{instrumentationStrategy:1}, http2:{instrumentationStrategy:0, nodeVersionCriteria:"^8.11.2 || ^9.2.1 || >=10"}}}, "Node.ClientWebRequest":{type:"ClientWebRequest", associatedModules:{http:{instrumentationStrategy:1}, https:{instrumentationStrategy:1}, http2:{instrumentationStrategy:0, nodeVersionCriteria:"^8.11.2 || ^9.2.1 || >=10"}}}, 
        "Node.MongoDb":{type:"MongoDb", associatedModules:{mongodb:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLastOrPromise, instrumentationStrategy:0, rules:[{subComponentName:"Collection", patchPrototype:!0, ignoreMissing:!1, apiRealm:"mongodb", rules:[{moduleVersionCriteria:">=1.4.0", functionNames:"insert remove rename save update distinct count drop findAndModify findAndRemove findOne createIndex ensureIndex listIndexes indexInformation dropIndex dropAllIndexes reIndex mapReduce group options isCapped indexExists indexes stats".split(" ")}, 
        {moduleVersionCriteria:">=2.0.0", functionNames:"bulkWrite createIndexes deleteMany deleteOne dropIndexes findOneAndDelete findOneAndReplace findOneAndUpdate insertMany insertOne replaceOne updateMany updateOne".split(" ")}]}, {subComponentName:"Db", patchPrototype:!0, ignoreMissing:!1, apiRealm:"mongodb", rules:[{moduleVersionCriteria:">=1.4.0", functionNames:"db addUser admin authenticate collectionNames collections eval dereference logout removeUser createCollection command dropCollection renameCollection createIndex ensureIndex cursorInfo dropIndex reIndex indexInformation dropDatabase stats".split(" ")}, 
        {moduleVersionCriteria:">=2.0.0", functionNames:["executeDbAdminCommand"]}]}]}, "pattern:mongodb/lib/aggregation_cursor(.js)?$":{}, "pattern:mongodb/lib/mongodb/aggregation_cursor(.js)?$":{}, "pattern:mongodb/lib/command_cursor(.js)?$":{}, "pattern:mongodb/lib/mongodb/command_cursor(.js)?$":{}}}, "Node.MongoDb.ContextPassing":{type:"ContextPassing", associatedModules:{mongodb:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLastOrPromise, instrumentationStrategy:0, rules:[{subComponentName:"Db", 
        patchPrototype:!0, ignoreMissing:!1, rules:[{functionNames:["open", "close"]}]}, {subComponentName:"MongoClient", patchPrototype:!0, ignoreMissing:!0, rules:[{functionNames:["connect", "close", "logout", "isConnected"]}]}]}}}, "Node.Redis":{type:"Redis", associatedModules:{redis:{instrumentationStrategy:0}}}, "Node.Memcached":{type:"Memcached", associatedModules:{memcached:{instrumentationStrategy:0}}}, "Node.Express":{type:"Express", associatedModules:{"pattern:express/lib/router/layer(.js)?$":{}}}, 
        "Node.FinalHandler":{type:"FinalHandler", associatedModules:{finalhandler:{instrumentationStrategy:0}}}, "Node.Restify":{type:"Restify", associatedModules:{"pattern:restify/lib/response(.js)?$":{}}}, "Node.SQLite3":{type:"ContextPassing", associatedModules:{sqlite3:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLast, instrumentationStrategy:0, rules:[{subComponentName:"Database", patchPrototype:!0, ignoreMissing:!1, rules:[{functionNames:"close exec wait loadExtension serialize parallelize configure".split(" ")}]}, 
        {subComponentName:"Statement", patchPrototype:!0, ignoreMissing:!1, rules:[{functionNames:"bind get run all each reset finalize".split(" ")}]}]}}}, "Node.MySql":{type:"MySql", associatedModules:{mysql:{instrumentationStrategy:0}, "pattern:mysql/lib/Pool(.js)?$":{}, "pattern:mysql/lib/Connection(.js)?$":{}, "pattern:mysql/lib/protocol/sequences/Query(.js)?$":{}}}, "Node.MySql2":{type:"MySql2", associatedModules:{mysql2:{instrumentationStrategy:0}, "pattern:mysql2/lib/pool(.js)?$":{}, "pattern:mysql2/lib/connection(.js)?$":{}, 
        "pattern:mysql2/lib/commands/query(.js)?$":{}, "pattern:mysql2/promise(.js)?$":{}}}, "Node.Postgres":{type:"Postgres", associatedModules:{pg:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLastOrPromise, instrumentationStrategy:0, rules:[{subComponentName:"Client", patchPrototype:!0, ignoreMissing:!1}]}, "pattern:pg/lib/client(.js)?$":{}, "pattern:pg/lib/query(.js)?$":{}}}, "Node.CouchbaseDb":{type:"CouchbaseDb", associatedModules:{couchbase:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLast, 
        instrumentationStrategy:0}, "pattern:couchbase/lib/bucket(.js)?$":{moduleVersionCriteria:"<3.0.0"}, "pattern:couchbase/lib/connstr(.js)?$":{moduleVersionCriteria:"<3.0.0"}, "pattern:couchbase/lib/collection(.js)?$":{moduleVersionCriteria:">=3.0.0"}, "pattern:couchbase/lib/connection(.js)?$":{moduleVersionCriteria:">=3.0.0"}, "pattern:couchbase/lib/cluster(.js)?$":{moduleVersionCriteria:">=3.0.0"}}}, "Node.AwsLambda":{type:"AwsLambda", associatedModules:{}}, "Node.AwsSdk":{type:"AwsSdk", associatedModules:{"pattern:aws-sdk/lib/core(?:\\.js|)$":{ruleKey:"AwsSdk.Core"}}}, 
        "Node.RabbitMq":{type:"RabbitMq", associatedModules:{amqplib:{instrumentationStrategy:0}, "amqplib/callback_api":{instrumentationStrategy:0}, "pattern:amqplib/lib/channel(.js)?$":{}, "pattern:amqplib/lib/channel_model(.js)?$":{}, "pattern:amqplib/lib/callback_model(.js)?$":{}}}, "Node.gRPC":{type:"gRPC", associatedModules:{grpc:{patchPrototype:!0, instrumentationStrategy:0}, "pattern:grpc/src/grpc_extension(.js)?$":{}, "pattern:grpc/src/client(.js)?$":{}}}, "Node.GrpcJs":{type:"GrpcJs", associatedModules:{"@grpc/grpc-js":{patchPrototype:!0, 
        instrumentationStrategy:0}, "pattern:@grpc/grpc-js/build/src/make-client(.js)?$":{}, "pattern:@grpc/grpc-js/build/src/channel(.js)?$":{}, "pattern:@grpc/grpc-js/build/src/call-stream(.js)?$":{}}}, "sdk.outgoing.remotecall":{type:"SdkOutgoingRemoteCall", associatedModules:{}}, "sdk.incoming.remotecall":{type:"SdkIncomingRemoteCall", associatedModules:{}}, "sdk.outgoing.messaging":{type:"SdkOutgoingMessaging", associatedModules:{}}, "sdk.incoming.messaging":{type:"SdkIncomingMessaging", associatedModules:{}}, 
        "sdk.database":{type:"SdkDatabase", associatedModules:{}}, "sdk.scav":{type:"SdkScav", associatedModules:{}}, "Node.IORedis":{type:"IORedis", associatedModules:{ioredis:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLastOrPromise, instrumentationStrategy:0}, "pattern:ioredis/built/command(.js)?$":{}, "pattern:ioredis/built/pipeline(.js)?$":{}, "pattern:ioredis/built/transaction(.js)?$":{}, "pattern:ioredis/built/ScanStream(.js)?$":{}}}, "Node.MSSql":{type:"MSSql", associatedModules:{mssql:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLastOrPromise, 
        instrumentationStrategy:0}, "pattern:mssql/lib/base(.js)?$":{}, "pattern:mssql/lib/base/request(.js)?$":{}, "pattern:mssql/lib/base/connection-pool(.js)?$":{}}}, "Node.Tedious":{type:"Tedious", associatedModules:{tedious:{asyncTrackingMode:e.AsyncTrackingMode.CallbackLast, instrumentationStrategy:0}, "pattern:tedious/lib/connection(.js)?$":{}}}};
        f = Object.assign(Object.create(null), a);
      }
    }
    return f;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  let f;
  a.getPredefinedInstrumentationRules = h;
  a.getPredefinedInstrumentationRule = function(a) {
    return h()[a];
  };
});
S("src/lib/sensors/InstrumentationRule", ["require", "exports"], function(t, a) {
  Object.defineProperty(a, "__esModule", {value:!0});
});
S("src/lib/transformer/ControlParamSupplier", ["require", "exports"], function(t, a) {
  Object.defineProperty(a, "__esModule", {value:!0});
});
S("src/lib/sensors/SensorBase", "require exports semver src/lib/Agent src/lib/Debug src/lib/DebugLoggingEntity src/lib/ModuleRegistry src/lib/PackageRegistry src/lib/Patch src/lib/RunTimeProperty src/lib/sensors/SensorConfig src/lib/util/CoreUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class d extends k.default {
    constructor(b, a, e, g) {
      super(d.makeSensorDebugFlagName(b));
      this.sensorConfigKey = b;
      this.sensorConfig = a;
      this.instrumentationRule = e;
      this.sensorId = g;
      this.addToDebugLogDomain("Sensors");
      this.addToDebugLogDomain("Transformers");
      this.disableFlag = new c.BooleanProperty(`${d.makeSensorDebugFlagName(b)}Disabled`, !1);
      null == this.sensorId && (this.sensorId = h.Agent.correlation.SensorId.SENSOR_ID_NODEJS);
    }
    get name() {
      return this.sensorConfigKey;
    }
    get enabled() {
      return this.sensorConfig.enabled && !this.disableFlag.value;
    }
    get entrypoint() {
      return this.sensorConfig.entrypoint;
    }
    get capture() {
      return this.sensorConfig.capture;
    }
    get active() {
      return this.capture && h.Agent.active && !h.Agent.isCim;
    }
    updateState(b) {
      this.sensorConfig.capture = b.capture;
      this.sensorConfig.entrypoint = b.entrypoint;
    }
    applyInstrumentation() {
    }
    isApplicable(b) {
      const a = this.instrumentationRule.associatedModules[b.request];
      return null == a || d.validateCriterias(a, b);
    }
    determinePackageMetaInfo() {
    }
    toString() {
      return this.name;
    }
    applyPatch(a, d) {
      const c = this.instrumentationRule.associatedModules[a.request];
      null != c ? this.doApplyPatch(c, a.moduleExports, a.request, a, d, b.getOptionalValue(c.ignoreMissing, !1), b.getOptionalValue(c.patchPrototype, !1), b.getOptionalValue(c.asyncTrackingMode, g.AsyncTrackingMode.CallbackLast), c.apiRealm, c.propertiesToCopy) : h.Logger.warning(`${this.sensorConfigKey} received instrumentation request for non associated module '${a.request}'`);
    }
    doApplyPatch(a, c, e, f, k, r, n, u, m, B) {
      if (null != a.rules && d.validateCriterias(a, f)) {
        for (const p of a.rules) {
          if (d.validateCriterias(p, f)) {
            var l = b.getOptionalValue(p.asyncTrackingMode, u);
            const d = b.getOptionalValue(p.patchPrototype, n);
            var w = b.getOptionalValue(p.ignoreMissing, r);
            const I = b.getOptionalValue(a.apiRealm, m), q = b.getOptionalValue(a.propertiesToCopy, B);
            if (null != p.subComponentName) {
              this.isDebugEnabled && h.Logger.debug(`doApplyPatch patching sub-component ${e}.${p.subComponentName}: ${d}`);
              const b = c[p.subComponentName];
              null != b ? this.doApplyPatch(p, b, `${e}.${p.subComponentName}`, f, k, w, d, l, I, q) : w || h.Logger.warning(`${this.sensorConfigKey}: sub-component ${e}.${p.subComponentName} not found`);
            } else {
              this.isDebugEnabled && h.Logger.debug(`patching ${e}: ${p.functionNames}`), w = {ignoreMissing:w, ignoreAlreadyPatched:!1, polymorphicSubstitution:!1, propertiesToCopy:q}, l = new g.ModuleSpec(e, d ? c.prototype : c, l, I), g.applyToAllFunctions(l, k, p.functionNames, w);
            }
          }
        }
      }
    }
    static validateCriterias(a, d) {
      var l = null == a.nodeVersionCriteria || e.satisfies(process.version, a.nodeVersionCriteria, {includePrerelease:!0});
      if (l) {
        l = b.getOptionalValue(a.moduleAllowPrereleaseCriteria, !1);
        const c = n.ModuleRegistry.lookup(d);
        (l = d.isNodeCoreModule || e.satisfies(c.version, ">=0.0.0", {includePrerelease:l})) && null != a.moduleVersionCriteria && (l = c.version !== m.cInvalidVersionString && e.satisfies(c.version, a.moduleVersionCriteria));
      }
      l && null != a.platformCriteria && (l = null != b.match(a.platformCriteria, process.platform));
      l && null != a.runTimePropertyCriteria && (l = (new c.BooleanProperty(a.runTimePropertyCriteria, !1)).value);
      return l;
    }
    static makeSensorDebugFlagName(b) {
      let a;
      b.startsWith(r.cConfigKeyPrefix) ? a = b.substr(r.cConfigKeyPrefix.length) : b.startsWith(r.cSdkConfigKeyPrefix) ? a = `Sdk${b.substr(r.cSdkConfigKeyPrefix.length)}` : (h.Logger.warning(`makeSensorDebugFlagName: Unexpected sensor key: ${b}`), f.fail(), a = b);
      a = a.replace(/\./g, "");
      /Sensor$/.test(b) || (a += "Sensor");
      return a;
    }
  }
  a.SensorBase = d;
});
S("src/lib/AsyncTracker", ["require", "exports", "src/lib/Patch", "src/lib/util/CoreUtil"], function(t, a, e, h) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class f {
    constructor(a, e) {
      this.transformer = a;
      this.descriptor = e;
      this.injectedCallback = !1;
    }
    get hasCallback() {
      return null != this.origCb;
    }
    manipulateArguments(a) {
      const f = e.AsyncTrackingMode.getCallbackIndex(this.descriptor.asyncTrackingMode, a);
      if (0 > f) {
        return a;
      }
      f < a.length && h.isFunction(a[f]) ? this.origCb = a[f] : null != this.transformer.injectionCallback && e.AsyncTrackingMode.doInjectMissingCallback(this.descriptor.asyncTrackingMode) && (this.origCb = this.transformer.injectionCallback, this.injectedCallback = !0);
      if (null == this.origCb) {
        return a;
      }
      const k = this.transformer.wrapCallback(this);
      if (this.injectedCallback) {
        const e = Array(f >= a.length ? f + 1 : a.length);
        let c = 0;
        for (let g = 0; g < e.length && !(g === f && (e[g++] = k, g >= e.length)); ++g) {
          e[g] = a.length > c ? a[c++] : void 0;
        }
        a = e;
      } else {
        a[f] = k;
      }
      return a;
    }
    manipulateReturnValue(a) {
      !a.didThrow && e.AsyncTrackingMode.isPromiseStyle(this.descriptor.asyncTrackingMode) && this.transformer.wrapReturnValue(this, a);
    }
  }
  a.default = f;
});
S("src/lib/transformer/TransformerBase", "require exports src/lib/FunctionId src/lib/Logger src/lib/MethodActivation src/lib/SubPathContext src/lib/util/Validatable".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class m {
    constructor(b, a) {
      this.vNodeActivation = b;
      this.initiatorActivation = a;
      a.spc.activate();
    }
    initiatorActivationDone(b) {
      this.initiatorActivation.spc.deactivate();
      return this.initiatorActivation.exitOrException(b);
    }
    toString() {
      return `AsyncActivation[vNode=${this.vNodeActivation.spc}, initiator=${this.initiatorActivation}]`;
    }
  }
  a.AsyncActivationResult = m;
  class g {
    constructor(b) {
      this.mActivation = b;
      b.spc.activate();
    }
    methodActivationDone(b) {
      this.mActivation.spc.deactivate();
      return this.mActivation.exitOrException(b);
    }
    toString() {
      return `SyncActivation[node=${this.mActivation.spc}]`;
    }
  }
  a.SyncActivationResult = g;
  class c {
    constructor(b) {
      this.activation = b;
      b.spc.activate();
    }
    done(b) {
      this.activation.spc.deactivate();
      return this.activation.exitOrException(b);
    }
    toString() {
      return this.activation.toString();
    }
  }
  a.CbActivationResult = c;
  class r {
    constructor(b) {
      this.controlParams = b;
    }
    static selectMethodActivationContext(b) {
      let a = k.SubPathContext.getActiveContext();
      null != a && a.open || (a = b);
      return a;
    }
    static createCallbackActivation(b, a, l) {
      b = r.selectMethodActivationContext(b);
      b = b.createCallbackActivation(a, l);
      return null != b ? new c(b) : void 0;
    }
    get isDebugEnabled() {
      return this.controlParams.isDebugEnabled;
    }
    isApiRealmActive(b, a) {
      return null != a.apiRealm && null != b.currentActivation && b.currentActivation.functionId.apiRealm === a.apiRealm;
    }
    tryStartAsyncActivation(b) {
      if (this.controlParams.active) {
        var a = k.SubPathContext.getActiveContext();
        if (null != a) {
          if (this.isApiRealmActive(a, b.functionId)) {
            this.controlParams.isDebugEnabled && h.debug(`nested call within apiRealm ${b.functionId.apiRealm} ${a.currentActivation.functionId.functionName}->${b.functionId.functionName}`);
            return;
          }
          a = a.createActivation({functionId:b.functionId, creator:b.creator, mode:1});
          if (null == a) {
            return;
          }
        } else {
          if (!this.controlParams.entrypoint) {
            return;
          }
          a = new k.SubPathContext(void 0, b.sensorId);
          if (!a.valid) {
            return;
          }
          a = new f.MethodActivation({spc:a, mode:1, functionId:b.functionId, endSpcOnExit:!0, creator:b.creator});
        }
        var c = a.spc.spawnAsyncExecutionSubPath(b.sensorId, b.vPathOption);
        if (c.valid) {
          var g = new e.VirtualNodeFunctionId(b.functionId);
          b = new f.MethodActivation({spc:c, mode:2, functionId:g, category:b.category, attachmentCreator:b.attachmentCreator, creator:b.creator});
          return new m(b, a);
        }
        h.info(`${a.toString(!0)} was created but spawned exe subpath ${c} is invalid`);
        a.exit();
      }
    }
    tryStartActivation(b) {
      let a = k.SubPathContext.getActiveContext();
      if (null != a) {
        if (this.isApiRealmActive(a, b.functionId)) {
          this.controlParams.isDebugEnabled && h.debug(`nested call within apiRealm ${b.functionId.apiRealm} ${a.currentActivation.functionId.functionName}->${b.functionId.functionName}`);
          return;
        }
        b = a.createActivation({attachmentCreator:b.attachmentCreator, category:b.category, creator:b.creator, functionId:b.functionId, mode:1});
      } else {
        if (!this.controlParams.entrypoint) {
          return;
        }
        a = new k.SubPathContext(void 0, b.sensorId);
        if (!a.valid) {
          return;
        }
        b = new f.MethodActivation({spc:a, endSpcOnExit:!0, attachmentCreator:b.attachmentCreator, category:b.category, creator:b.creator, functionId:b.functionId, mode:1});
      }
      if (null != b) {
        return new g(b);
      }
    }
    tryStartIncomingAsyncSubPath(b) {
      if (this.controlParams.active && (this.controlParams.entrypoint || n.validate(b.link))) {
        var a = new k.SubPathContext(b.link, b.sensorId, b.serverId, b.taggingMode);
        if (a.valid) {
          var c = new e.VirtualNodeFunctionId(b.functionId);
          c = new f.MethodActivation({spc:a, endSpcOnExit:!0, attachmentCreator:b.attachmentCreator, category:b.category, creator:b.creator, functionId:c, mode:2});
          a = a.spawnAsyncInitiatorSubPath(b.sensorId);
          b = new f.MethodActivation({spc:a, endSpcOnExit:!0, creator:b.creator, functionId:b.functionId, mode:1});
          return new m(c, b);
        }
      }
    }
    tryStartIncomingSubPath(b) {
      if (this.controlParams.active && (this.controlParams.entrypoint || n.validate(b.link))) {
        var a = new k.SubPathContext(b.link, b.sensorId, b.serverId);
        if (a.valid) {
          return b = new f.MethodActivation({spc:a, endSpcOnExit:!0, attachmentCreator:b.attachmentCreator, category:b.category, creator:b.creator, functionId:b.functionId, mode:1}), new g(b);
        }
      }
    }
  }
  a.TransformerBase = r;
});
S("src/lib/transformer/AsyncTransformerBase", ["require", "exports", "src/lib/transformer/TransformerBase"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class h extends e.TransformerBase {
    constructor(a, e = h.dynatraceInjectedCallback) {
      super(a);
      this.injectionCallback = e;
    }
    static dynatraceInjectedCallback() {
    }
  }
  a.AsyncTransformerBase = h;
});
S("src/lib/modules/AutoSensorAttachment", "require exports src/lib/Agent src/lib/AttachmentBase src/lib/MethodIdCache src/lib/Stack src/lib/util/RuntimeUtil".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class m extends h.AttachmentBase {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_AUTOSENSOR_ID, 0, e.Agent.nativeAgent.correlation.AttachmentTarget.CurrentNode);
    }
    fillAutoSensorAttachment(a, c, f) {
      if (null != this.attachment) {
        var b = [];
        null == c || n.isAgentFile(c.fileName) || (f && e.Logger.debug("AutoSensor: adding top frame: [" + c.functionName + " " + c.fileName + " " + c.lineNumber + "] -> " + c.methodId), b.push({methodId:c.methodId, lineNumber:c.lineNumber}));
        this.addAutoSensorFramesFromStackTrace(a, b, f);
        0 < b.length && this.attachment.setAutoSensorFrames(b);
      }
    }
    addAutoSensorFramesFromStackTrace(a, c, h) {
      for (const b of a) {
        a = k.findFunctionName(b);
        const d = b.getFileName() || "";
        if (!n.isAgentFile(d)) {
          const l = b.getLineNumber() || -1, g = f.default.get(a, d);
          h && e.Logger.debug("AutoSensor: processing frame: [" + a + " " + d + " " + l + "] -> " + g);
          c.push({methodId:g, lineNumber:l});
        }
      }
    }
  }
  a.AutoSensorAttachment = m;
});
S("src/lib/modules/AutoSensorModule", "require exports src/lib/Agent src/lib/Debug src/lib/RunTimeProperty src/lib/RuntimeSetting src/lib/Stack src/lib/SubPathContext src/lib/modules/AutoSensorAttachment src/lib/util/CoreUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  function r(b) {
    null != d && d.addSample(r, b);
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const b = new f.NumberOption("AutoSensorStacktDepth", 300);
  let d;
  a.addSample = r;
  a.addSampleAsyncHook = function(b) {
    null != d && d.addSample(b);
  };
  a.resetInstance = function() {
    d = void 0;
  };
  class l {
    constructor() {
      this.name = "AutoSensor";
      this.featureDisabledFlag = new f.BooleanProperty("AutoSensorDisabled", !1);
      this.debugLoggingFlag = new f.BooleanProperty("AutoSensor", !1);
      this.featureEnableSetting = new k.RuntimeSetting("autoSensor.enabled");
      this.autoSensorAlwaysOn = new f.BooleanOption("AutoSensorAlwaysOn", !1);
      h.assert(void 0 === d);
      d = this;
    }
    addSample(a, d) {
      if (this.active) {
        var l = this.getActivation();
        null == l || !this.autoSensorAlwaysOn.value && !e.Agent.nativeAgent.checkAutoSensorInterval() || l.spc.isIgnoredPath || (a = n.getCallSites(b.value, a), 0 >= a.length ? this.isDebugEnabled && e.Logger.debug(`AutoSensor: Failed to retrieve stack for ${this.getActivationInfoString(l)}`) : (d = c.isFunction(d) ? d() : d, this.isDebugEnabled && e.Logger.debug(`AutoSensor: adding sample to ${this.getActivationInfoString(l)}, topFrame: ${d ? d.toString() : "-"}`), (new g.AutoSensorAttachment(l)).fillAutoSensorAttachment(a, 
        d, this.isDebugEnabled)));
      }
    }
    getActivation() {
      var b = m.SubPathContext.getActiveContext();
      if (null != b && (b = b.currentActivation, null != b && !b.isExited)) {
        return b;
      }
    }
    getActivationInfoString(b) {
      return "[" + b.toString(!0) + " " + b.functionId.methodId + " " + b.functionId.fileName + "] on path " + b.spc.path.toString();
    }
    get isDebugEnabled() {
      return this.debugLoggingFlag.value;
    }
    get active() {
      return e.Agent.active && e.Agent.lifeCycleState === e.LifeCycleState.Running ? this.featureEnableSetting.value && !this.featureDisabledFlag.value : !1;
    }
  }
  a.AutoSensorModule = l;
});
S("src/lib/CallbackWrappingHelper", "require exports src/lib/FunctionId src/lib/MethodActivation src/lib/SubPathContext src/lib/transformer/TransformerBase src/lib/modules/AutoSensorModule src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.errorFromFirstArg = function() {
    return 1 <= arguments.length && m.isError(arguments[0]) ? arguments[0] : void 0;
  };
  class r {
    static wrapCallbackContextPassing(b) {
      b.spc.didInitiateAsyncOp = !0;
      return function() {
        try {
          b.spc.activate();
        } catch (l) {
          g.logAgentException(l);
        }
        const a = c.safeInvoke(this, b.origCb, arguments);
        try {
          n.addSample(() => new e.FunctionId(b.origCb)), b.spc.deactivate();
        } catch (l) {
          g.logAgentException(l);
        }
        return a.rethrow();
      };
    }
    static wrapCallbackAsyncSubpath(b) {
      return function() {
        if (b.injectedCallback) {
          return c.doInvoke(this, b.origCb, arguments);
        }
        let a, l;
        try {
          var k = new f.SubPathContext(b.localLink);
          k.valid && (a = new e.FunctionId(b.origCb), l = new h.MethodActivation({spc:k, functionId:a, endSpcOnExit:!0, mode:1}), l.spc.activate());
        } catch (p) {
          g.logAgentException(p);
        }
        k = c.safeInvoke(this, b.origCb, arguments);
        try {
          null != l && (n.addSample(a), l.spc.deactivate(), l.exitOrException(k.exception));
        } catch (p) {
          g.logAgentException(p);
        }
        return k.rethrow();
      };
    }
    static wrapCallbackCreateActivation(b) {
      return function() {
        try {
          if (null != b.virtualNodeActivation) {
            var a = m.isFunction(b.errorExtractor) ? c.doInvoke(this, b.errorExtractor, arguments) : void 0;
            b.virtualNodeActivation.exitOrException(a);
          }
        } catch (p) {
          g.logAgentException(p);
        }
        let l, f;
        if (null != b.virtualNodeActivation && !b.injectedCallback) {
          try {
            l = new e.FunctionId(b.origCb), f = k.TransformerBase.createCallbackActivation(b.virtualNodeActivation.spc, l);
          } catch (p) {
            g.logAgentException(p);
          }
        }
        a = c.safeInvoke(this, b.origCb, arguments);
        try {
          null != f && (n.addSample(l), f.done(a.exception)), null != b.virtualNodeActivation && b.virtualNodeActivation.spc.end();
        } catch (p) {
          g.logAgentException(p);
        }
        return a.rethrow();
      };
    }
  }
  a.CallbackWrappingHelper = r;
});
S("src/lib/AsyncContextPassingTracker", ["require", "exports", "src/lib/AsyncTracker"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class h extends e.default {
    constructor(a, e, h) {
      super(a, h);
      this.transformer = a;
      this.spc = e;
      this.descriptor = h;
    }
  }
  a.default = h;
});
S("src/lib/transformer/ContextPassingTransformer", "require exports src/lib/transformer/AsyncTransformerBase src/lib/AsyncContextPassingTracker src/lib/CallbackWrappingHelper src/lib/FunctionId src/lib/SubPathContext src/lib/modules/AutoSensorModule src/lib/util/InvocationUtil src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class r extends e.AsyncTransformerBase {
    constructor(b, a) {
      super(b);
      this.conditionCb = a;
    }
    generateSubstitute(b) {
      const a = this, l = new k.FunctionId(b);
      return function() {
        if (!a.controlParams.active || a.conditionCb && !a.conditionCb.apply(this, arguments)) {
          return g.doInvoke(this, b.origFn, arguments);
        }
        let d;
        var e = arguments;
        try {
          const c = n.SubPathContext.getActiveContext();
          null != c && (d = new h.default(a, c, b), e = d.manipulateArguments(arguments));
        } catch (q) {
          c.logAgentException(q);
        }
        if (null == d) {
          return g.doInvoke(this, b.origFn, arguments);
        }
        e = g.safeInvoke(this, b.origFn, e);
        try {
          m.addSample(l), d.manipulateReturnValue(e);
        } catch (q) {
          c.logAgentException(q);
        }
        return e.rethrow();
      };
    }
    wrapCallback(b) {
      return f.CallbackWrappingHelper.wrapCallbackContextPassing(b);
    }
    wrapReturnValue() {
    }
  }
  a.ContextPassingTransformer = r;
});
S("src/lib/AsyncVirtualNodeTracker", ["require", "exports", "src/lib/AsyncContextPassingTracker"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class h extends e.default {
  }
  a.default = h;
});
S("src/lib/transformer/AsyncTimingTransformer", "require exports src/lib/transformer/AsyncTransformerBase src/lib/AsyncVirtualNodeTracker src/lib/CallbackWrappingHelper src/lib/FunctionId src/lib/modules/AutoSensorModule src/lib/util/InvocationUtil src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class c extends e.AsyncTransformerBase {
    generateSubstitute(a) {
      const b = this, d = new k.FunctionId(a);
      return function() {
        let c;
        var e = arguments;
        let f;
        try {
          c = b.tryStartAsyncActivation({functionId:d}), null != c && (f = new h.default(b, c.initiatorActivation.spc, a), f.virtualNodeActivation = c.vNodeActivation, e = f.manipulateArguments(arguments));
        } catch (q) {
          g.logAgentException(q);
        }
        if (null == c) {
          return m.doInvoke(this, a.origFn, arguments);
        }
        e = m.safeInvoke(this, a.origFn, e);
        try {
          n.addSample(d), null != f && f.manipulateReturnValue(e), c.initiatorActivationDone(e.exception);
        } catch (q) {
          g.logAgentException(q);
        }
        return e.rethrow();
      };
    }
    wrapCallback(a) {
      return f.CallbackWrappingHelper.wrapCallbackCreateActivation(a);
    }
    wrapReturnValue() {
    }
  }
  a.AsyncTimingTransformer = c;
});
S("src/lib/transformer/SyncTimingTransformer", "require exports src/lib/FunctionId src/lib/SubPathContext src/lib/modules/AutoSensorModule src/lib/util/InvocationUtil src/lib/util/ErrorUtil src/lib/transformer/TransformerBase".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class g extends m.TransformerBase {
    generateSubstitute(a) {
      const c = this, b = new e.FunctionId(a);
      return function() {
        let d;
        if (c.controlParams.active) {
          try {
            var l = h.SubPathContext.getActiveContext();
            null == l || c.isApiRealmActive(l, b) || (d = l.createActivation({functionId:b, mode:1}));
          } catch (x) {
            n.logAgentException(x);
          }
        }
        l = k.safeInvoke(this, a.origFn, arguments);
        try {
          f.addSample(b), null != d && d.exitOrException(l.exception);
        } catch (x) {
          n.logAgentException(x);
        }
        return l.rethrow();
      };
    }
  }
  a.SyncTimingTransformer = g;
});
S("src/lib/sensors/GenericSensors", "require exports src/lib/Agent src/lib/sensors/SensorBase src/lib/transformer/ContextPassingTransformer src/lib/transformer/AsyncTimingTransformer src/lib/transformer/SyncTimingTransformer".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class m extends h.SensorBase {
    applyInstrumentation(b) {
      this.isDebugEnabled && e.Logger.debug(`${this.name}: instrumenting module ${b.toString(!0)}`);
      null == this.transformer && (this.transformer = this.createTransformer());
      this.applyPatch(b, this.transformer);
    }
  }
  class g extends m {
    createTransformer() {
      return new f.ContextPassingTransformer(this);
    }
  }
  a.ContextPassingSensor = g;
  class c extends m {
    createTransformer() {
      return new k.AsyncTimingTransformer(this);
    }
  }
  a.AsyncTimingSensor = c;
  class r extends m {
    createTransformer() {
      return new n.SyncTimingTransformer(this);
    }
  }
  a.SyncTimingSensor = r;
});
S("src/lib/sensors/DisabledModulesSensor", ["require", "exports", "src/lib/sensors/SensorBase", "src/lib/Agent", "src/lib/Debug"], function(t, a, e, h, f) {
  function k() {
  }
  function n() {
    return "";
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const m = {newrelic:function(a) {
    process.env.NEW_RELIC_NO_CONFIG_FILE = "1";
    process.env.NEW_RELIC_ENABLED = "0";
    h.Logger.info("DisabledModules: disabling newrelic agent");
    return a.moduleExports;
  }, appdynamics:function() {
    h.Logger.info("DisabledModules: disabling AppDynamics agent");
    return {profile:k};
  }, longjohn:function() {
    h.Logger.info("DisabledModules: disabline logjohn");
    return {format_stack_frame:n, format_stack:n, async_trace_limit:5, empty_frame:"---------------------------------------------"};
  }};
  class g extends e.SensorBase {
    applyInstrumentation(a) {
      f.assert(!a.isModuleAcquired, "disabled module got loaded before DisabledModuleSensor");
      this.isDebugEnabled && h.Logger.debug(`${this.name}: inhibit ${a}`);
      const c = m[a.request];
      a.moduleExports = null != c ? c(a) : {};
    }
  }
  a.DisabledModulesSensor = g;
});
S("src/lib/sensors/ModuleSubstitutionSensor", ["require", "exports", "src/lib/Agent", "src/lib/sensors/SensorBase", "src/lib/util/ErrorUtil"], function(t, a, e, h, f) {
  function k(a) {
    a.gracefulify = k;
    return a;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const n = {"graceful-fs":function() {
    const a = t("fs");
    return k(a);
  }};
  class m extends h.SensorBase {
    applyInstrumentation(a) {
      null != n[a.request] ? (this.isDebugEnabled && e.Logger.debug(`${this.name}: substituting module ${a}`), a.moduleExports = n[a.request](a)) : (e.Logger.warning(`${this.name}: undefined substitution for module ${a.request}`), f.reportInstrumentationError(this, ` undefined substitution for module ${a.request}`));
    }
  }
  a.ModuleSubstitutionSensor = m;
});
S("src/lib/sensors/UemSensor", "require exports url tls src/lib/Agent src/lib/RunTimeProperty src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/HttpUtil".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class c {
    static isEnabled() {
      return !c.uemDisabled.value && !f.Agent.isCim;
    }
    static createContext(b, a) {
      return new r(b, a);
    }
  }
  a.UemSensor = c;
  c.uemDisabled = new k.BooleanProperty("UemSensorDisabled", !1);
  class r {
    constructor(b, a) {
      var d = e.parse(n.isString(b.url) ? b.url : "");
      d = {scheme:b.socket instanceof h.TLSSocket ? "https" : "http", method:b.method || "", url:d.pathname || "", query:n.isString(d.query) ? d.query : "", clientIP:g.getRemoteAddress(b.socket)};
      this.uemSensorContext = f.Agent.uemSensor.createUemSensorContext(d, b.headers, a);
    }
    release() {
      null != this.uemSensorContext && this.uemSensorContext.release();
    }
    isUemWebRequest() {
      return null != this.uemSensorContext ? this.uemSensorContext.isUemWebRequest() : !1;
    }
    isInjecting() {
      return null != this.uemSensorContext ? this.uemSensorContext.isInjecting() : !1;
    }
    getServerId() {
      return null != this.uemSensorContext ? this.uemSensorContext.getServerId() : 0;
    }
    isPathBlocked() {
      return null != this.uemSensorContext ? this.uemSensorContext.isPathBlocked : !1;
    }
    onWebRequest(b, a, c, e) {
      c = this.handleRequest(c, e);
      null != c && (this.debug && f.Logger.debug(`UEM: isSpecialRequest: ${c.isSpecialRequest}, postBodyNeeded: ${c.postBodyNeeded}, maxPostBodySize: ${c.maxPostBodySize}: ${b.url}`), c.isSpecialRequest ? c.postBodyNeeded ? this.captureSpecialRequestPostBody(c.maxPostBodySize, b, a) : this.handleSpecialRequest(a) : this.handleRegularRequest(b));
    }
    onStoreHeaders(b, a, c) {
      if (!(null == c || 2 > c.length)) {
        if (g.outHeadersKey && a[g.outHeadersKey] === c[1]) {
          var d = r.getHeadersFromServerResponse(c[1]);
          var l = !0;
        } else {
          d = c[1], l = !1;
        }
        null == d && (d = Object.create(null));
        var e = this.responseStarted(d);
        this.debug && (f.Logger.debug(`UEM: ${c[0]}`), this.logHeaders("UEM: Headers before modification:", d));
        var h = this.getChangedResponseHeaders();
        this.debug && this.logHeaders("UEM: Changed responseHeaders:", h);
        for (const b in h) {
          const c = g.lookupKeyname(d, b);
          if (null != c) {
            if (r.shouldAppendHeader(c)) {
              let e = [];
              e = e.concat(d[c], h[b]);
              r.setHeader(a, d, c, e, l);
            } else {
              r.setHeader(a, d, c, h[b], l);
            }
          } else {
            r.setHeader(a, d, b, h[b], l);
          }
        }
        e && "HEAD" !== b.method && (b = g.lookupKeyname(d, "content-length"), null != b && r.removeHeader(a, d, b, l), b = g.lookupKeyname(d, "transfer-encoding") || "transfer-encoding", r.setHeader(a, d, b, "chunked", l));
        this.debug && this.logHeaders("UEM: Headers after modification:", l ? r.getHeadersFromServerResponse(c[1]) : d);
      }
    }
    onResponseWrite(b, a) {
      if (null != b && this.isInjecting() && (b = r.getBuffer(b, a), null != b)) {
        a = this.injectJsAgentTag(b, !1);
        var d = null != a, c = d ? a.length : 0;
        this.debug && f.Logger.debug(`UEM: Agent was ${0 < c ? "" : "NOT "}injected into fragment` + ` (fragment length before: ${b.length}, new fragment${d ? ` length: ${c}` : ": <undefined>"})`);
        return a;
      }
    }
    onResponseEnd(b, a) {
      let d;
      this.isInjecting() && (d = this.injectJsAgentTag(r.getBuffer(b, a), !0), null == b && null != d && 0 === d.length && (d = void 0), this.debug && (a = (b = null != d) ? d.length : 0, f.Logger.debug(`UEM: Processing remaining fragment (fragment${b ? ` length: ${a}` : ": <undefined>"})`)));
      this.release();
      return d;
    }
    handleRequest(b, a) {
      return null != this.uemSensorContext ? this.uemSensorContext.handleRequest(b, a) : {isSpecialRequest:!1, postBodyNeeded:!1, maxPostBodySize:-1};
    }
    responseStarted(b) {
      return null != this.uemSensorContext ? this.uemSensorContext.responseStarted(b) : !1;
    }
    getChangedRequestHeaders() {
      if (null != this.uemSensorContext) {
        return this.uemSensorContext.getChangedRequestHeaders();
      }
    }
    getChangedResponseHeaders() {
      return null != this.uemSensorContext ? this.uemSensorContext.getChangedResponseHeaders() : {};
    }
    injectJsAgentTag(b, a) {
      if (null != this.uemSensorContext) {
        return this.uemSensorContext.injectJsAgentTag(b, a);
      }
    }
    updateRequestBody(b) {
      return null != this.uemSensorContext ? this.uemSensorContext.updateRequestBody(b) : !1;
    }
    getResponseStatus() {
      return null != this.uemSensorContext ? this.uemSensorContext.getResponseStatus() : 200;
    }
    getResponseBody() {
      if (null != this.uemSensorContext) {
        return this.uemSensorContext.getResponseBody();
      }
    }
    get debug() {
      return r.debugProperty.value;
    }
    static getBuffer(b, a) {
      let d;
      n.isString(b) ? d = Buffer.from(b, a) : Buffer.isBuffer(b) && (d = b);
      return null != d && 0 < d.length ? d : void 0;
    }
    static shouldAppendHeader(b) {
      return "set-cookie" === b.toLowerCase() ? !0 : !1;
    }
    logHeaders(b, a) {
      f.Logger.debug(b);
      for (const d in a) {
        if (b = a[d], Array.isArray(b)) {
          for (let a = 0; a < b.length; a++) {
            f.Logger.debug(`  ${d}=${b[a]}`);
          }
        } else {
          f.Logger.debug(`  ${d}=${b}`);
        }
      }
    }
    handleRegularRequest(b) {
      const a = this.getChangedRequestHeaders();
      if (null != a) {
        b.headers = {};
        for (const d in a) {
          b.headers[d.toLowerCase()] = a[d];
        }
        this.debug && this.logHeaders("UEM: Changed requestHeaders:", b.headers);
      }
    }
    handleSpecialRequest(b) {
      const a = this.getChangedResponseHeaders(), c = this.getResponseBody(), e = this.getResponseStatus();
      let h = 0;
      null == c ? f.Logger.warning("UemSensor: failed to get response body for special request (e.g. no jsAgent available)") : h = c.length;
      this.debug && (f.Logger.debug(`UEM: Response status code: ${e}`), this.logHeaders("UEM: Response headers:", a), f.Logger.debug(`UEM: Response body size: ${h}`), 0 < h && f.Logger.debug(`UEM: Response body: ${c.toString("hex", 0, 1024)}`));
      null == g.lookupKeyname(a, "content-length") && (a["content-length"] = `${h}`);
      b.writeHead(e, a);
      0 < h ? b.end(c) : b.end();
    }
    captureSpecialRequestPostBody(b, a, c) {
      this.debug && f.Logger.debug(`UEM: Processing BEACON request method ${a.method}`);
      if ("POST" === a.method && 0 < b) {
        const d = this;
        let e = 0;
        const l = Buffer.allocUnsafe(Math.min(b + 1, 2147483647));
        a.on("data", function(b) {
          try {
            d.debug && f.Logger.debug(`UEM: beacon data: length=${b.length}`), e < l.length && (n.isString(b) ? e += l.write(b, e) : Buffer.isBuffer(b) && (e += b.copy(l, e)));
          } catch (D) {
            m.logAgentException(D);
          }
        });
        a.on("end", function() {
          try {
            const b = l.slice(0, e);
            d.debug && f.Logger.debug(`UEM: beacon end: length=${e}, ${b.toString(void 0, 0, 1024)}`);
            d.updateRequestBody(b) && d.handleSpecialRequest(c);
          } catch (v) {
            m.logAgentException(v);
          }
        });
      } else {
        this.updateRequestBody(Buffer.alloc(0)) && this.handleSpecialRequest(c);
      }
    }
    static setHeader(b, a, c, e, g) {
      g ? b.setHeader(c, e) : a[c] = e;
    }
    static removeHeader(b, a, c, e) {
      e ? b.removeHeader(c) : delete a[c];
    }
    static getHeadersFromServerResponse(b) {
      const a = Object.create(null);
      for (const d in b) {
        const c = b[d];
        a[c[0]] = c[1];
      }
      return a;
    }
  }
  a.UemSensorContext = r;
  r.debugProperty = new k.BooleanProperty("UemSensorLogging", !1);
});
S("src/lib/sensors/WebRequestAttachment", "require exports url querystring src/lib/Agent src/lib/AttachmentBase src/lib/Configuration src/lib/Debug src/lib/Embedder src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/HttpUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b) {
  function d(b) {
    var a = x.get(b);
    if (c.isString(a)) {
      return a;
    }
    let d;
    try {
      c.isFunction(b.address) && (d = b.address());
    } catch (C) {
      r.logAgentException(C);
    }
    null == d || c.isString(d) || !c.isString(d.address) ? a = "localhost" : (a = "IPv6" === d.family ? `[${d.address}]` : d.address, c.isNumber(d.port) && (a += `:${d.port}`));
    x.set(b, a);
    return a;
  }
  function l(b) {
    m.assert(null != b);
    let a = b.length / 2 * 4;
    for (const d of b) {
      a += d.length;
    }
    return a;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const x = g.create("serverAddress");
  class p extends k.AttachmentBase {
    constructor(a, d) {
      super(a, f.Agent.correlation.AttachmentId.ATTACHMENT_WEBREQUEST_ID, 0);
      this.sensorProperties = d;
      this.maxStrLen = b.getWebRequestMaxStringLen();
    }
    fillEntryData(a) {
      this.setMultipleFields(g => {
        const h = a.method || "GET";
        var k = a.headers || {}, u = a.url || "";
        const p = b.getRemoteAddress(a.socket);
        let r = b.getClientIp(k, b.getClientIPDetectionHeaders());
        null == r && (r = p);
        const q = f.Agent.correlation.AttachmentFieldId;
        g.string(q.WEBREQUEST_CLIENT_IP, r, this.maxStrLen);
        g.stringCached(q.WEBREQUEST_REQUEST_METHOD, h, this.maxStrLen);
        u = e.parse(u);
        g.stringCached(q.WEBREQUEST_URI, u.pathname || "/", this.maxStrLen);
        c.isString(u.query) && g.stringCached(q.WEBREQUEST_QUERY_STRING, u.query, this.maxStrLen);
        g.stringCached(q.WEBREQUEST_REQUESTED_HOSTNAME, b.getHostname(k, b.getHostDetectionHeaders()), this.maxStrLen);
        null != a.rawHeaders && g.integer(q.WEBREQUEST_REQUEST_HEADER_SIZE, l(a.rawHeaders));
        const w = this.sensorProperties;
        g.map(q.WEBREQUEST_REQUEST_HEADERS, k, w.captureAllRequestHeaders ? void 0 : b => -1 !== w.requestHeadersToCapture.indexOf(b), this.maxStrLen);
        c.isString(n.Configuration.appName) && g.stringCached(q.WEBREQUEST_APPLICATION_ID, n.Configuration.appName, this.maxStrLen);
        g.stringCached(q.WEBREQUEST_SERVERNAME, d(a.server), this.maxStrLen);
        g.stringCached(q.WEBREQUEST_CONTEXTROOT, "/", this.maxStrLen);
        k = k.forwarded || k["x-forwarded-for"];
        c.isString(k) && g.string(q.WEBREQUEST_FORWARDED_FOR, k, this.maxStrLen);
        g.string(q.WEBREQUEST_REMOTE_ADRESS, p, this.maxStrLen);
        "GET" === h && w.shallCaptureRequestData() && c.isString(u.query) && this.fillRequestParameters(g, u.query);
      });
    }
    fillExitData(a) {
      this.setMultipleFields(d => {
        const e = f.Agent.correlation.AttachmentFieldId;
        null != a.statusCode && d.integer(e.WEBREQUEST_RESPONSE_STATUS, +a.statusCode);
        if (c.isString(a.headers)) {
          d.integer(e.WEBREQUEST_RESPONSE_HEADER_SIZE, a.headers.length), this.fillResponseHeadersFromHeaderline(d, a.headers);
        } else {
          if (null != a.headers) {
            const {captureAllResponseHeaders:c, responseHeadersToCapture:l} = this.sensorProperties;
            b.fillOutgoingHeaders(d, e.WEBREQUEST_RESPONSE_HEADERS, a.headers, c, l);
          }
        }
        c.isString(a.postData) && 0 < a.postData.length && this.fillRequestParameters(d, a.postData);
      });
    }
    fillRequestParameters(b, a) {
      const {captureAllRequestParameters:d, requestParametersToCapture:c} = this.sensorProperties;
      b.map(f.Agent.correlation.AttachmentFieldId.WEBREQUEST_REQUEST_PARAMETERS, h.parse(a), d ? void 0 : b => -1 !== c.indexOf(b), this.maxStrLen);
    }
    fillResponseHeadersFromHeaderline(b, a) {
      a = a.split("\r\n");
      const d = a.length;
      let c = 0;
      for (; c < d; c++) {
        if (a[c].startsWith("HTTP/")) {
          c++;
          break;
        }
      }
      const {captureAllResponseHeaders:e, responseHeadersToCapture:l} = this.sensorProperties, g = f.Agent.correlation.AttachmentFieldId.WEBREQUEST_RESPONSE_HEADERS;
      for (; c < d; c++) {
        const d = a[c], f = d.indexOf(":");
        if (-1 !== f) {
          const a = d.substr(0, f).toLowerCase();
          (e || -1 !== l.indexOf(a)) && b.keyValueCached(g, a, d.substr(f + 1).trim(), this.maxStrLen);
        }
      }
    }
  }
  a.WebRequestAttachment = p;
});
S("src/lib/transformer/EventEmitterTransformerBase", "require exports src/lib/Embedder src/lib/Patch src/lib/util/CoreUtil src/lib/transformer/TransformerBase".split(" "), function(t, a, e, h, f, k) {
  function n(a, e, b) {
    function d() {
      a.removeListener(e, d.listener);
      c || (c = !0, b.apply(a, arguments));
    }
    let c = !1;
    d.listener = b;
    m.set(d, b);
    return d;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const m = e.create("eventEmitter");
  class g extends k.TransformerBase {
    constructor(a, e) {
      super(a);
      null != e && (Array.isArray(e) ? this.types = e : this.types = [e]);
    }
    applyTransformation(a) {
      const c = h.cPolymorphicDefaultOptions, b = new h.FunctionSpec("addListener", a);
      null != h.substitute(b, this.generateAddListenerSubstitute(), c) && h.installAlias(b, new h.FunctionSpec("on", a));
      h.substitute(new h.FunctionSpec("once", a), this.generateOnceSubstitute(), c);
      h.substitute(new h.FunctionSpec("prependListener", a), this.generateAddListenerSubstitute(), c);
      h.substitute(new h.FunctionSpec("prependOnceListener", a), this.generatePrependOnceSubstitute(), c);
    }
    static getUnwrappedListener(a) {
      return m.get(a) || a;
    }
    generateAddListenerSubstitute() {
      const a = this;
      return function b() {
        if (a.checkArguments.apply(a, arguments)) {
          var d = arguments[1];
          const c = a.getWrappedListener(this, arguments[0], d);
          if (null != c && c !== d) {
            return m.set(c, d), d = g.getUnwrappedListener(d), c.listener = d, arguments[1] = c, h.invokeResolvedOriginal(b, this, arguments);
          }
        }
        return h.invokeOriginal(b, this, arguments);
      };
    }
    generateOnceSubstitute() {
      const a = this;
      return function b() {
        return a.checkArguments.apply(a, arguments) && a.shallWrap(this, arguments[0]) ? (arguments[1] = n(this, arguments[0], arguments[1]), this.on.apply(this, arguments)) : h.invokeOriginal(b, this, arguments);
      };
    }
    generatePrependOnceSubstitute() {
      const a = this;
      return function b() {
        return a.checkArguments.apply(a, arguments) && a.shallWrap(this, arguments[0]) ? (arguments[1] = n(this, arguments[0], arguments[1]), this.prependListener.apply(this, arguments)) : h.invokeOriginal(b, this, arguments);
      };
    }
    checkArguments() {
      return 2 <= arguments.length && f.isFunction(arguments[1]) && (null == this.types || -1 !== this.types.indexOf(arguments[0]));
    }
  }
  a.EventEmitterTransformerBase = g;
});
S("src/lib/transformer/ReadableStreamDataTransformer", "require exports src/lib/transformer/EventEmitterTransformerBase src/lib/Logger src/lib/Patch src/lib/util/ErrorUtil src/lib/util/InvocationUtil".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  var m;
  (function(a) {
    a[a.UNDEFINED = 0] = "UNDEFINED";
    a[a.READ = 1] = "READ";
    a[a.DATAEVENT = 2] = "DATAEVENT";
  })(m || (m = {}));
  class g extends e.EventEmitterTransformerBase {
    constructor(a, e, b) {
      super(a, "data");
      this.maxSize = e;
      this.tracker = b;
      this.state = m.UNDEFINED;
    }
    applyTransformation(a) {
      const c = new f.FunctionSpec("read", a);
      null == f.applyToSingle(c, this) && h.warning(`${this.tracker}: Failed to patch ${c.qualifiedName}`);
      super.applyTransformation(a);
    }
    generateSubstitute(a) {
      const c = this;
      let b = a.origFn;
      return function() {
        const a = c.controlParams.isDebugEnabled, e = c.tracker;
        if (null == e.vNodeActivation) {
          return a && h.debug(`${e}: ReadableStreamDataTransformer.read don't capture data on close path`), n.doInvoke(this, b, arguments);
        }
        c.state === m.UNDEFINED && (c.state = m.READ);
        if (c.state !== m.READ) {
          return a && h.debug(`${e}: ReadableStreamDataTransformer.read skipped as state=${m[c.state]}`), n.doInvoke(this, b, arguments);
        }
        const g = this.read, f = n.safeInvoke(this, b, arguments);
        if (!f.didThrow) {
          const b = f.retVal;
          null != b && c.addChunk("read", b);
        }
        a && h.debug(`${e}: ReadableStreamDataTransformer.read() didThrow: ${f.didThrow ? k.verboseExceptionObject(f.exception) : "-"}`);
        this.read !== g && (b = this.read, this.read = g);
        return f.rethrow();
      };
    }
    shallWrap() {
      this.controlParams.isDebugEnabled && h.debug(`${this.tracker}: ReadableStreamDataTransformer.shallWrap: ${m[this.state]}, ${this.tracker.vNodeActivation}`);
      return this.state === m.UNDEFINED && null != this.tracker.vNodeActivation;
    }
    getWrappedListener(a, e, b) {
      if (this.state !== m.UNDEFINED) {
        return b;
      }
      const d = this;
      this.state = m.DATAEVENT;
      return function(a) {
        const c = d.controlParams.isDebugEnabled, e = d.tracker;
        if (null == e.vNodeActivation) {
          return c && h.debug(`${e}: ReadableStreamDataTransformer.onData don't capture data on close path`), n.doInvoke(this, b, arguments);
        }
        if (d.state !== m.DATAEVENT) {
          return c && h.debug(`${e}: ReadableStreamDataTransformer.onData skipped as state=${m[d.state]}`), n.doInvoke(this, b, arguments);
        }
        d.addChunk("onData", a);
        return n.doInvoke(this, b, arguments);
      };
    }
    addChunk(a, e) {
      const b = this.controlParams.isDebugEnabled, d = this.tracker;
      try {
        const c = d.streamData.length;
        b && h.debug(`${d}: ReadableStreamDataTransformer.${a}: curLen=${c}, chunkLen=${e.length}`);
        c < this.maxSize ? d.streamData += e.slice(0, this.maxSize - c) : b && h.debug(`${d}: ReadableStreamDataTransformer.${a} skip chunk of length ${e.length}`);
      } catch (l) {
        k.logAgentException(l);
      }
    }
  }
  a.ReadableStreamDataTransformer = g;
});
S("src/lib/util/UniqueId", ["require", "exports"], function(t, a) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class e {
    constructor() {
      this.id = e.getNext();
    }
    toString() {
      return e.asString(this.id);
    }
    static getNext() {
      const a = e.nextId++;
      e.nextId >= Math.pow(2, 16) && (e.nextId = 0);
      return a;
    }
    static getNextAsString() {
      return e.asString(e.getNext());
    }
    static asString(a) {
      return `[#${("000" + a.toString(16)).substr(-4)}]`;
    }
  }
  a.UniqueId = e;
  e.nextId = 0;
});
S("src/lib/transformer/WebRequestTrackerBase", "require exports src/lib/Agent src/lib/sensors/ExceptionAttachment src/lib/sensors/WebRequestAttachment src/lib/util/ErrorUtil src/lib/util/UniqueId".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class m {
    constructor(a, c, e) {
      this.trackerName = a;
      this.server = c;
      this.sensor = e;
      this.streamData = "";
      this.errorCnt = 0;
      this.id = n.UniqueId.getNext();
    }
    createAttachments(a) {
      this.webRequestAttachment = new f.WebRequestAttachment(a, this.sensor.properties);
      if (this.webRequestAttachment.valid) {
        try {
          this.onWebRequestAttachmentCreated();
        } catch (c) {
          k.logAgentException(c);
        }
      } else {
        this.isDebugEnabled && e.Logger.debug(`${this}: WebRequestAttachment is not valid`);
      }
    }
    attachError(a) {
      const c = this.isDebugEnabled;
      this.errorCnt++;
      if (1 === this.errorCnt) {
        if (null != this.vNodeActivation) {
          try {
            (new h.ExceptionAttachment(this.vNodeActivation)).fillExceptionData(a), c && e.Logger.debug(`${this}: attached error ${k.verboseExceptionObject(a)}`);
          } catch (r) {
            k.logAgentException(r);
          }
        } else {
          c && e.Logger.debug(`${this}: rejecting error object - vNode closed`);
        }
      } else {
        c && e.Logger.debug(`${this}: rejecting error object - already attached ${this.errorCnt}`);
      }
    }
    endAsyncExeNode() {
      const a = this.isDebugEnabled;
      if (null != this.vNodeActivation) {
        try {
          a && e.Logger.debug(`${this}: endAsyncExeNode() virt: ${this.vNodeActivation.spc}`), null != this.webRequestAttachment && this.webRequestAttachment.valid && this.fillWebRequestAttachmentExitData(), 0 === this.errorCnt ? this.vNodeActivation.exit() : this.vNodeActivation.methodException(), this.vNodeActivation = void 0;
        } catch (c) {
          k.logAgentException(c);
        }
      } else {
        a && e.Logger.debug(`${this}: endAsyncExeNode() no vNode set`);
      }
    }
    get isDebugEnabled() {
      return this.sensor.isDebugEnabled;
    }
    toString() {
      this.logPrefix || (this.logPrefix = `${this.trackerName} ${n.UniqueId.asString(this.id)}`);
      return this.logPrefix;
    }
  }
  a.WebRequestTrackerBase = m;
});
S("src/lib/util/EventUtil", ["require", "exports"], function(t, a) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.reEmitErrorIfNeeded = function(a, h) {
    1 >= a.listenerCount("error") && (a.removeAllListeners("error"), a.emit("error", h));
  };
});
S("src/lib/transformer/HttpServerTransformer", "require exports src/lib/modules/AutoSensorModule src/lib/sensors/UemSensor src/lib/sensors/WebRequestSensor src/lib/transformer/EventEmitterTransformerBase src/lib/transformer/ReadableStreamDataTransformer src/lib/transformer/WebRequestTrackerBase src/lib/Agent src/lib/Embedder src/lib/FunctionId src/lib/Patch src/lib/SubPathContext src/lib/Tracing src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/EventUtil src/lib/util/HttpUtil src/lib/util/InvocationUtil".split(" "), 
function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p, q, v, D) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.ServerResponseEmbedder = c.create("serverResponse");
  class C extends m.WebRequestTrackerBase {
    constructor(b, a, d, c, e) {
      super("WebRequest", b, c);
      this.req = a;
      this.res = d;
      this.uemSensorContext = e;
      this.isResponseEnd = !1;
    }
    endAsyncExeNode() {
      this.isDebugEnabled && g.Logger.debug(`${this}: endAsyncExeNode(), vNode: ${this.vNodeActivation}, headersSent: ${this.res.headersSent}, status: ${this.res.statusCode}`);
      super.endAsyncExeNode();
      a.ServerResponseEmbedder.clear(this.res);
    }
    onWebRequestAttachmentCreated() {
      const b = this.req;
      this.webRequestAttachment.fillEntryData({server:this.server, socket:b.socket, method:b.method, headers:b.headers, rawHeaders:b.rawHeaders, url:b.url});
    }
    fillWebRequestAttachmentExitData() {
      var b = this.res;
      const a = b.headersSent;
      b = {statusCode:a ? b.statusCode : void 0, headers:a && x.isString(b._header) ? b._header : void 0, postData:this.streamData};
      this.webRequestAttachment.fillExitData(b);
    }
  }
  let u = !1;
  class z extends k.EventEmitterTransformerBase {
    constructor(b) {
      super(b, "request");
      this.sensor = b;
    }
    shallWrap() {
      return !0;
    }
    getWrappedListener(c, w, q) {
      const I = this;
      I.controlParams.isDebugEnabled && g.Logger.debug(`WebRequest: getWrappedListener cnt: ${c.listenerCount(w)}`);
      const m = k.EventEmitterTransformerBase.getUnwrappedListener(q), L = new r.FunctionId(m);
      return function(...c) {
        const k = c[0], w = c[1], r = I.controlParams.isDebugEnabled;
        r && g.Logger.debug(`WebRequest: Handler enter: ${k.method}, ${k.url}`);
        if (!I.controlParams.active) {
          return r && g.Logger.debug("WebRequest: Handler exit - inactive"), D.doInvoke(this, q, c);
        }
        if (a.ServerResponseEmbedder.hasKey(w)) {
          var H = a.ServerResponseEmbedder.get(w);
          if (null == H) {
            return r && g.Logger.debug("WebRequest: Handler exit - no reqData"), D.doInvoke(this, q, c);
          }
          r && g.Logger.debug(`${H}: Handler exit: already patched, currSpc: ${d.SubPathContext.getActiveContext()}`);
          if (null == H.vNodeActivation) {
            return r && g.Logger.debug(`${H}: Handler exit - no vNodeActivation`), D.doInvoke(this, q, c);
          }
          try {
            var G = H.vNodeActivation.spc.createActivation({functionId:L, mode:1});
            null != G && G.spc.activate();
          } catch (P) {
            p.logAgentException(P);
          }
          c = D.safeInvoke(this, q, c);
          try {
            null != G && (q === m && e.addSample(L), G.spc.deactivate(), G.exitOrException(c.exception));
          } catch (P) {
            p.logAgentException(P);
          }
          r && g.Logger.debug(`${H}: Handler exit didThrow: ${c.didThrow ? p.verboseExceptionObject(c.exception) : "-"}`);
          return c.rethrow();
        }
        let Q;
        G = !1;
        try {
          let d;
          const c = v.getTraceContext(k.headers);
          null != c && (d = g.Agent.correlation.deserializeLinkFromString(c.dtTag, c.traceParent, c.traceState));
          let e = 0, p = !1;
          var K;
          if (K = h.UemSensor.isEnabled()) {
            x.isBoolean(k.isSpdy) && k.isSpdy ? (u || (g.Logger.info("Disable UEM on SPDY requests"), u = !0), K = !1) : K = !0;
          }
          K && (Q = h.UemSensor.createContext(k, d), G = Q.isUemWebRequest(), e = Q.getServerId(), p = Q.isPathBlocked());
          if (!G) {
            const h = I.shouldSuppressPath(k.url, p, r);
            let u;
            h && null == Q || (u = new C(this, k, w, I.sensor, Q), a.ServerResponseEmbedder.set(w, u));
            if (!h) {
              if (H = I.tryStartIncomingAsyncSubPath({functionId:L, category:g.Agent.correlation.MethodCategory.WebRequest, link:d, attachmentCreator:u, serverId:e, taggingMode:l.Tracing.getHttpTaggingMode()}), d = void 0, null != H) {
                if (r) {
                  const b = u.webRequestAttachment;
                  g.Logger.debug(`${u}: Handler virt: ${H.vNodeActivation.spc}, init: ${H.initiatorActivation.spc}, tag: ${l.Tracing.traceContextToString(c)}, ${b}`);
                }
                u.vNodeActivation = H.vNodeActivation;
                var B = I.sensor;
                K = u;
                if (v.shallCapturePostRequestParameters(k.method, k.headers, B.properties)) {
                  var O = new b.ModuleSpec("IncomingMessage", k);
                  (new n.ReadableStreamDataTransformer(B, f.WebRequestSensor.cPostDataCaptureSize, K)).applyTransformation(O);
                } else {
                  if (B.isDebugEnabled) {
                    const b = B.properties, a = x.getOptionalPropertyValue(k.headers, "content-type", "no content-type");
                    g.Logger.debug(`${K}: skip capturing POST data, ${b.captureAllRequestParameters}, ${b.requestParametersToCapture}, ${a}`);
                  }
                }
                k.on("error", z.getRequestErrorListener(u));
                w.on("error", z.responseErrorListener);
              } else {
                r && g.Logger.debug(`${u}: Handler failed to create activation, tag: ${l.Tracing.traceContextToString(c)}`);
              }
            }
            if (null != u) {
              w.on("close", z.responseCloseListener);
            }
          }
          null != d && d.purge();
          if (null != Q) {
            let b = g.Agent.correlation.cInvalidPath;
            B = 0;
            G || null == H || (b = H.vNodeActivation.spc.path, B = H.vNodeActivation.serialNo);
            Q.onWebRequest(k, w, b, B);
          }
        } catch (P) {
          p.logAgentException(P);
        }
        if (!G) {
          c = D.safeInvoke(this, q, c);
          try {
            null != H && (q === m && e.addSample(L), H.initiatorActivationDone(c.exception));
          } catch (P) {
            p.logAgentException(P);
          }
          r && g.Logger.debug(`WebRequest: Handler exit didThrow: ${c.didThrow ? p.verboseExceptionObject(c.exception) : "-"}`);
          return c.rethrow();
        }
      };
    }
    shouldSuppressPath(b, a, d) {
      const c = a || !this.sensor.properties.shallCaptureUrl(b);
      c && d && g.Logger.debug(`WebRequest: suppress subpath ${b}, uemBlocked: ${a}`);
      return c;
    }
    static getRequestErrorListener(b) {
      return function(a) {
        z.handleErrorEvent(this, b, a);
      };
    }
    static responseErrorListener(b) {
      z.handleErrorEvent(this, a.ServerResponseEmbedder.get(this), b);
    }
    static handleErrorEvent(b, a, d) {
      null != a && a.attachError(d);
      q.reEmitErrorIfNeeded(b, d);
    }
    static responseCloseListener() {
      const b = a.ServerResponseEmbedder.get(this);
      null != b && (b.isDebugEnabled && g.Logger.debug(`${b}: responseClose`), b.endAsyncExeNode());
    }
  }
  a.ServerRequestTransformer = z;
  class B {
    constructor(b) {
      this.controlParams = b;
    }
    generateSubstitute(b) {
      const d = this, c = new r.FunctionId(b);
      return function(...l) {
        const f = d.controlParams.isDebugEnabled, h = a.ServerResponseEmbedder.get(this);
        if (null == h) {
          return f && g.Logger.debug("WebRequest: unmonitored end()"), D.doInvoke(this, b.origFn, l);
        }
        f && g.Logger.debug(`${h}: end() argLength: ${l.length}`);
        if (null != h.uemSensorContext) {
          let b = !1;
          try {
            h.isResponseEnd = !0;
            this.headersSent || this.finished || (f && g.Logger.debug(`${h}: call writeHead(${this.statusCode})`), b = !0, this.writeHead(this.statusCode), b = !1);
            let a = l[0], d = l[1], c = l[2];
            x.isFunction(a) ? (c = a, a = void 0) : x.isFunction(d) && (c = d, d = void 0);
            const e = h.uemSensorContext.onResponseEnd(a, d);
            null != e && (null != a ? l[0] = e : l = [e, c]);
          } catch (J) {
            b ? f && g.Logger.debug(`${h}: end() writeHead has thrown: ${p.verboseExceptionObject(J)}`) : p.logAgentException(J);
          }
        }
        l = D.safeInvoke(this, b.origFn, l);
        try {
          e.addSample(c);
        } catch (G) {
          p.logAgentException(G);
        }
        h.endAsyncExeNode();
        f && g.Logger.debug(`${h}: end() didThrow: ${l.didThrow ? p.verboseExceptionObject(l.exception) : "-"}`);
        return l.rethrow();
      };
    }
  }
  a.ServerResponseEndTransformer = B;
  class A {
    constructor(b) {
      this.controlParams = b;
    }
    generateSubstitute(b) {
      const d = this, c = new r.FunctionId(b);
      return function(...l) {
        const f = d.controlParams.isDebugEnabled, h = a.ServerResponseEmbedder.get(this);
        if (null == h) {
          return f && g.Logger.debug("WebRequest: unmonitored storeHeader()"), D.doInvoke(this, b.origFn, l);
        }
        f && g.Logger.debug(`${h}: storeHeader() argLength: ${l.length}`);
        try {
          if (e.addSample(c), null != h.uemSensorContext) {
            h.uemSensorContext.onStoreHeaders(h.req, this, l);
          }
        } catch (G) {
          p.logAgentException(G);
        }
        l = D.safeInvoke(this, b.origFn, l);
        f && g.Logger.debug(`${h}: storeHeader() didThrow: ${l.didThrow ? p.verboseExceptionObject(l.exception) : "-"}`);
        return l.rethrow();
      };
    }
  }
  a.ResponseStoreHeaderTransformer = A;
  class w {
    constructor(b) {
      this.controlParams = b;
    }
    generateSubstitute(b) {
      const d = this;
      return function(...c) {
        const e = d.controlParams.isDebugEnabled, l = a.ServerResponseEmbedder.get(this);
        if (null == l) {
          return e && g.Logger.debug("WebRequest: unmonitored write()"), D.doInvoke(this, b.origFn, c);
        }
        e && g.Logger.debug(`${l}: write() argLength: ${c.length}`);
        if (null != l.uemSensorContext && !l.isResponseEnd) {
          try {
            this.headersSent || this.finished || !x.isNumber(this.statusCode) || this.writeHead(this.statusCode);
            const b = l.uemSensorContext.onResponseWrite(...c);
            null != b && (c[0] = b);
          } catch (L) {
            p.logAgentException(L);
          }
        }
        c = D.safeInvoke(this, b.origFn, c);
        e && g.Logger.debug(`${l}: write() didThrow: ${c.didThrow ? p.verboseExceptionObject(c.exception) : "-"}`);
        return c.rethrow();
      };
    }
  }
  a.ServerResponseWriteTransformer = w;
});
S("src/lib/transformer/Http2ServerTransformer", "require exports events src/lib/transformer/ReadableStreamDataTransformer src/lib/transformer/EventEmitterTransformerBase src/lib/transformer/WebRequestTrackerBase src/lib/Agent src/lib/Debug src/lib/Embedder src/lib/FunctionId src/lib/Patch src/lib/SubPathContext src/lib/Tracing src/lib/modules/AutoSensorModule src/lib/sensors/WebRequestSensor src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/EventUtil src/lib/util/HttpUtil src/lib/util/InvocationUtil".split(" "), 
function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p, q, v, D, C) {
  function u(b) {
    const a = A.get(this);
    null != a && (a.isDebugEnabled && n.Logger.debug(`${a}: streamCloseListener() headersSent: ${this.headersSent}, errorCode: ${b}`), a.endAsyncExeNode(), A.clear(a.stream));
  }
  function z(b) {
    const a = A.get(this);
    null != a && a.attachError(b);
    v.reEmitErrorIfNeeded(this, b);
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const B = [];
  a.addCheckForIncomingRequestSuppression = function(b) {
    B.includes(b) || B.push(b);
  };
  const A = g.create("ServerHttp2Stream");
  class w extends k.WebRequestTrackerBase {
    constructor(b, a, d, c, e) {
      super("Http2Server", b, e);
      this.stream = a;
      this.headers = d;
      this.rawHeader = c;
    }
    setResponseHeaders(b) {
      m.assert(null != this.webRequestAttachment);
      if (p.isObject(b)) {
        if (null != this.webRequestAttachment && this.webRequestAttachment.valid) {
          try {
            this.webRequestAttachment.fillExitData({statusCode:b[":status"], headers:b});
          } catch (Q) {
            q.logAgentException(Q);
          }
        } else {
          this.isDebugEnabled && n.Logger.debug(`${this}: no valid WebRequestAttachment in setResponseHeaders()`);
        }
      }
    }
    onWebRequestAttachmentCreated() {
      const b = this.headers;
      this.webRequestAttachment.fillEntryData({server:this.server, socket:this.stream.session.socket, method:b[":method"], url:b[":path"], headers:b, rawHeaders:this.rawHeader});
      this.rawHeader = this.headers = void 0;
    }
    fillWebRequestAttachmentExitData() {
      0 < this.streamData.length && this.webRequestAttachment.fillExitData({postData:this.streamData});
    }
  }
  class I {
    constructor(b) {
      this.sensor = b;
      this.serverPatched = !1;
    }
    generateSubstitute(b) {
      const a = this, d = "createSecureServer" === b.functionName ? 1 : 0;
      return function(...c) {
        const l = a.sensor.isDebugEnabled;
        l && n.Logger.debug(`Http2Server: ${b.functionName}() hasRequestHandler: ${2 <= c.length}`);
        let g;
        if (!a.serverPatched) {
          try {
            l && n.Logger.debug(`Http2Server: ${b.functionName}() delay request listener registration`), c.length > d && p.isFunction(c[d]) && (g = c[d], c[d] = void 0);
          } catch (U) {
            q.logAgentException(U);
          }
        }
        c = C.safeInvoke(this, b.origFn, c);
        if (c.didThrow || a.serverPatched) {
          l && n.Logger.debug(`Http2Server: ${b.functionName}() exit with exception: ${c.exception}`);
        } else {
          try {
            const d = c.retVal;
            if (d instanceof e.EventEmitter) {
              l && n.Logger.debug(`Http2Server: ${b.functionName}() patching ${d.constructor && d.constructor.name}`);
              const c = new r.ModuleSpec(d.constructor.name, d.constructor.prototype);
              (new K(a.sensor)).applyTransformation(c);
              if (null != g) {
                d.on("request", g);
              }
              a.serverPatched = !0;
            } else {
              n.Logger.info(`Http2Server: ${b.functionName}() skip patching server as it is no emitter: ${d && d.constructor && d.constructor.name}`);
            }
          } catch (U) {
            q.logAgentException(U);
          }
        }
        return c.rethrow();
      };
    }
  }
  a.CreateServerTransformer = I;
  class K extends f.EventEmitterTransformerBase {
    constructor(b) {
      super(b, "stream");
      this.sensor = b;
    }
    shallWrap() {
      return !0;
    }
    getWrappedListener(a, e, g) {
      const k = this;
      k.controlParams.isDebugEnabled && n.Logger.debug(`Http2Server: getWrappedListener(${e.toString()}) cnt: ${a.listenerCount(e)}`);
      const p = f.EventEmitterTransformerBase.getUnwrappedListener(g), I = new c.FunctionId(p);
      return function(...a) {
        const c = a[0], e = a[1], f = a[3], m = k.controlParams.isDebugEnabled;
        m && n.Logger.debug("Http2Server: onStream enter");
        if (!k.controlParams.active) {
          return m && n.Logger.debug("Http2Server: onStream exit - inactive"), C.doInvoke(this, g, a);
        }
        if (A.hasKey(c)) {
          var N = A.get(c);
          if (null == N) {
            return m && n.Logger.debug("Http2Server: onStream exit - no tracker"), C.doInvoke(this, g, a);
          }
          m && n.Logger.debug(`${N}: onStream exit: already patched, currSpc: ${b.SubPathContext.getActiveContext()}`);
          if (null == N.vNodeActivation) {
            return m && n.Logger.debug(`${N}: onStream exit - no vNodeActivation`), C.doInvoke(this, g, a);
          }
          try {
            var v = N.vNodeActivation.spc.createActivation({functionId:I, mode:1});
            null != v && v.spc.activate();
          } catch (V) {
            q.logAgentException(V);
          }
          a = C.safeInvoke(this, g, a);
          try {
            null != v && (g === p && l.addSample(I), v.spc.deactivate(), v.exitOrException(a.exception));
          } catch (V) {
            q.logAgentException(V);
          }
          m && n.Logger.debug(`${N}: onStream exit didThrow: ${a.didThrow ? q.verboseExceptionObject(a.exception) : "-"}`);
          return a.rethrow();
        }
        try {
          if (!k.shouldSuppress(e)) {
            let b;
            const a = D.getTraceContext(e);
            null != a && (b = n.Agent.correlation.deserializeLinkFromString(a.dtTag, a.traceParent, a.traceState));
            const l = new w(this, c, e, f, k.sensor);
            N = k.tryStartIncomingAsyncSubPath({functionId:I, category:n.Agent.correlation.MethodCategory.WebRequest, link:b, attachmentCreator:l, taggingMode:d.Tracing.getHttpTaggingMode()});
            if (null != N) {
              if (m) {
                const b = l.webRequestAttachment;
                n.Logger.debug(`${l}: onStream virt: ${N.vNodeActivation.spc}, init: ${N.initiatorActivation.spc}, tag: ${d.Tracing.traceContextToString(a)}, ${b}`);
              }
              l.vNodeActivation = N.vNodeActivation;
              A.set(c, l);
              k.patchResponseApis(l, c);
              var L = k.sensor;
              v = l;
              if (D.shallCapturePostRequestParameters(e[":method"], e, L.properties)) {
                var G = new r.ModuleSpec("ServerHttp2Stream", c);
                (new h.ReadableStreamDataTransformer(L, x.WebRequestSensor.cPostDataCaptureSize, v)).applyTransformation(G);
              } else {
                if (L.isDebugEnabled) {
                  const b = L.properties;
                  n.Logger.debug(`${v}: skip capturing POST data, method=${e[":method"]}, all=${b.captureAllRequestParameters}, list=${b.requestParametersToCapture}, ct=${e["content-type"] || "no content-type"}`);
                }
              }
              c.on("error", z);
              c.on("close", u);
            } else {
              m && n.Logger.debug(`${l}: onStream failed to create activation, tag: ${d.Tracing.traceContextToString(a)}`);
            }
          }
        } catch (V) {
          q.logAgentException(V);
        }
        a = C.safeInvoke(this, g, a);
        try {
          null != N && (g === p && l.addSample(I), N.initiatorActivationDone(a.exception));
        } catch (V) {
          q.logAgentException(V);
        }
        m && n.Logger.debug(`Http2Server: onStream exit didThrow: ${a.didThrow ? q.verboseExceptionObject(a.exception) : "-"}`);
        return a.rethrow();
      };
    }
    patchResponseApis(b, a) {
      if (!K.respondPatched) {
        K.respondPatched = !0;
        a = a.constructor.prototype;
        var d = [{name:"respond", headersParamIdx:0}, {name:"respondWithFD", headersParamIdx:1}, {name:"respondWithFile", headersParamIdx:1}];
        for (const c of d) {
          d = new r.FunctionSpec(c.name, "ServerHttp2Stream", a);
          const e = new O(this.sensor, c.headersParamIdx);
          null == r.applyToSingle(d, e) && n.Logger.warning(`${b}: Failed to patch ServerHttp2Stream.${c.name}`);
        }
      }
    }
    shouldSuppress(b) {
      const a = b[":path"];
      if (!this.sensor.properties.shallCaptureUrl(a)) {
        return this.isDebugEnabled && n.Logger.debug(`Http2Server:: suppress path for: ${a}`), !0;
      }
      b = b["content-type"];
      if (p.isString(b)) {
        for (const a of B) {
          if (a(b)) {
            return this.isDebugEnabled && n.Logger.debug(`Http2Server:: suppress path for content-type: ${b}`), !0;
          }
        }
      }
      return !1;
    }
  }
  K.respondPatched = !1;
  class O {
    constructor(b, a) {
      this.sensor = b;
      this.headersParamIdx = a;
    }
    generateSubstitute(b) {
      const a = this, d = new c.FunctionId(b);
      return function(...c) {
        const e = a.sensor.isDebugEnabled, g = A.get(this);
        if (null == g) {
          return e && n.Logger.debug("Http2Server: unmonitored respond()"), C.doInvoke(this, b.origFn, c);
        }
        e && n.Logger.debug(`${g}: respond() argLength: ${c.length}`);
        const f = C.safeInvoke(this, b.origFn, c);
        try {
          l.addSample(d), f.didThrow || c.length > a.headersParamIdx && g.setResponseHeaders(c[a.headersParamIdx]);
        } catch (R) {
          q.logAgentException(R);
        }
        e && n.Logger.debug(`${g}: respond() didThrow: ${f.didThrow ? q.verboseExceptionObject(f.exception) : "-"}`);
        return f.rethrow();
      };
    }
  }
});
S("src/lib/sensors/WebRequestSensor", "require exports src/lib/sensors/SensorBase src/lib/sensors/WebRequestSensorProperties src/lib/transformer/HttpServerTransformer src/lib/transformer/Http2ServerTransformer src/lib/Debug src/lib/Logger src/lib/Patch src/lib/RunTimeProperty src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c, r) {
  Object.defineProperty(a, "__esModule", {value:!0});
  const b = new c.BooleanProperty("Http2ServerInstrumentationEnabled", !1);
  (function(b) {
    b.isMonitored = function(b) {
      return f.ServerResponseEmbedder.hasData(b);
    };
    b.attachError = function(b, a) {
      (b = f.ServerResponseEmbedder.get(b)) && b.attachError(a);
    };
  })(a.WebRequestSensorApi || (a.WebRequestSensorApi = {}));
  class d extends e.SensorBase {
    constructor(b, a, d, c) {
      super(b, a, d, c);
      this.properties = new h.WebRequestSensorProperties(a);
    }
    applyInstrumentation(a) {
      const d = a.request, c = [];
      switch(d) {
        case "http":
          this.transformRegisterRequest(a);
          this.transformResponseStoreHeader(a, c);
          this.transformResponseWrite(a, c);
          this.transformResponseEnd(a, c);
          break;
        case "https":
          this.transformRegisterRequest(a);
          break;
        case "http2":
          b.value || this.properties.enableHttp2Transformer ? (this.transformHttp2CreateSecureServer(a, c), this.transformHttp2CreateServer(a, c)) : m.info("Instrumenting HTTP2 server is disabled");
          break;
        default:
          m.warning(`Unexpected WebRequestSensor.applyInstrumentation(${d}`);
      }
      0 < c.length && r.reportInstrumentationError(this, c);
    }
    updateState(b) {
      super.updateState(b);
      this.properties.update(b);
    }
    transformRegisterRequest(b) {
      b = new g.ModuleSpec("Server", b.moduleExports.Server.prototype);
      (new f.ServerRequestTransformer(this)).applyTransformation(b);
    }
    transformResponseStoreHeader(b, a) {
      const d = new g.FunctionSpec("_storeHeader", "ServerResponse", b.moduleExports.ServerResponse.prototype), c = new f.ResponseStoreHeaderTransformer(this);
      null == g.applyToSingle(d, c, g.cPolymorphicDefaultOptions) && (m.warning(`Failed to patch ${b.request}.ServerResponse._storeHeader`), n.fail(), a.push(`${d.module}.${d.qualifiedName}`));
    }
    transformResponseWrite(b, a) {
      const d = new g.FunctionSpec("write", "ServerResponse", b.moduleExports.ServerResponse.prototype), c = new f.ServerResponseWriteTransformer(this);
      null == g.applyToSingle(d, c, g.cPolymorphicDefaultOptions) && (m.warning(`Failed to patch ${b.request}.ServerResponse.write`), n.fail(), a.push(`${d.module}.${d.qualifiedName}`));
    }
    transformResponseEnd(b, a) {
      const d = new g.FunctionSpec("end", "ServerResponse", b.moduleExports.ServerResponse.prototype), c = new f.ServerResponseEndTransformer(this);
      null == g.applyToSingle(d, c, g.cPolymorphicDefaultOptions) && (m.warning(`Failed to patch ${b.request}.ServerResponse.end`), n.fail(), a.push(`${d.module}.${d.qualifiedName}`));
    }
    transformHttp2CreateSecureServer(b, a) {
      const d = new g.FunctionSpec("createSecureServer", "", b.moduleExports), c = new k.CreateServerTransformer(this);
      null == g.applyToSingle(d, c) && (m.warning(`Failed to patch ${b.request}.createSecureServer`), n.fail(), a.push(`${d.module}.${d.qualifiedName}`));
    }
    transformHttp2CreateServer(b, a) {
      const d = new g.FunctionSpec("createServer", "", b.moduleExports), c = new k.CreateServerTransformer(this);
      null == g.applyToSingle(d, c) && (m.warning(`Failed to patch ${b.request}.createServer`), n.fail(), a.push(`${d.module}.${d.qualifiedName}`));
    }
  }
  a.WebRequestSensor = d;
  d.cPostDataCaptureSize = 20000;
});
S("src/lib/sensors/ClientWebRequestSensorProperties", "require exports src/lib/sensors/UriRuleSensorProperty src/lib/Logger src/lib/util/CoreUtil src/lib/util/HttpUtil".split(" "), function(t, a, e, h, f, k) {
  function n(b, a) {
    return f.isBoolean(b) ? b : a;
  }
  function m(b, a) {
    return Array.isArray(b) ? k.toStringArrayLc(b) : a;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const g = [], c = [], r = [];
  class b {
    constructor(b) {
      this.theCaptureAllResponseHeaders = this.theCaptureAllRequestHeaders = !1;
      this.theRequestHeadersToCapture = g;
      this.theResponseHeadersToCapture = c;
      this.theUriRulesWhiteList = this.theEnableHttp2Transformer = !1;
      this.theUriRules = r;
      this.update(b);
    }
    update(b) {
      f.hasProperty(b, "sensorProperties") ? (b = b.sensorProperties, this.theCaptureAllRequestHeaders = n(b.captureAllRequestHeaders, !1), this.theCaptureAllResponseHeaders = n(b.captureAllResponseHeaders, !1), this.theRequestHeadersToCapture = m(b.requestHeadersToCapture, g), this.theResponseHeadersToCapture = m(b.responseHeadersToCapture, c), this.theEnableHttp2Transformer = n(b.enableHttp2Transformer, !1), this.theUriRulesWhiteList = n(b.uriRulesWhiteList, !1), this.theUriRules = e.parseUriRules(b.uriRules, 
      "ClientWebRequestSensorConfig.sensorProperties")) : h.info("ClientWebRequestSensorConfig has no sensorProperties field");
    }
    get captureAllRequestHeaders() {
      return this.theCaptureAllRequestHeaders;
    }
    get requestHeadersToCapture() {
      return this.theRequestHeadersToCapture;
    }
    get captureAllResponseHeaders() {
      return this.theCaptureAllResponseHeaders;
    }
    get responseHeadersToCapture() {
      return this.theResponseHeadersToCapture;
    }
    get enableHttp2Transformer() {
      return this.theEnableHttp2Transformer;
    }
    get uriRulesWhiteList() {
      return this.theUriRulesWhiteList;
    }
    get uriRules() {
      return this.theUriRules;
    }
    shallCaptureRequestHeaders() {
      return this.theCaptureAllRequestHeaders || 0 < this.theRequestHeadersToCapture.length;
    }
    shallCaptureResponsetHeaders() {
      return this.theCaptureAllResponseHeaders || 0 < this.theResponseHeadersToCapture.length;
    }
    shallCaptureUrl(b) {
      if (!f.isString(b) || 0 === this.theUriRules.length) {
        return !this.theUriRulesWhiteList;
      }
      let a = "", d = b;
      const c = b.indexOf("?");
      if (-1 !== c) {
        d = b.substring(0, c);
        const e = b.indexOf("#", c);
        a = -1 !== e ? b.substring(c + 1, e) : b.substring(c + 1);
      }
      b = this.theUriRules.some(b => b.match(d, a));
      return this.theUriRulesWhiteList ? b : !b;
    }
  }
  a.ClientWebRequestSensorProperties = b;
});
S("src/lib/sensors/ClientWebRequestAttachment", "require exports url src/lib/Agent src/lib/AttachmentBase src/lib/util/CoreUtil src/lib/util/HttpUtil".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class m extends f.AttachmentBase {
    constructor(a, c) {
      super(a, h.Agent.correlation.AttachmentId.ATTACHMENT_CLIENT_WEBREQUEST_ID, 0);
      this.sensorProperties = c;
      this.maxStrLen = n.getWebRequestMaxStringLen();
    }
    fillEntryData(a, c) {
      const e = c ? 443 : 80;
      c = c ? "https:" : "http:";
      const b = a.protocol || c, d = a.hostname || a.host || "localhost", l = k.isString(a.method) && a.method.toUpperCase() || "GET", f = null == a.port ? e : +a.port;
      let g = "", m = "/", v = -1;
      a.path && (g = m = `${a.path}`, v = m.indexOf("?"), -1 !== v && (m = m.substr(0, v)));
      const D = `${b}//${d}` + (f === e && b === c ? "" : `:${f}`) + m;
      this.setMultipleFields(b => {
        const c = h.Agent.correlation.AttachmentFieldId;
        b.stringCached(c.CLIENT_WEB_REQUEST_URI, D, this.maxStrLen);
        b.stringCached(c.CLIENT_WEB_REQUEST_METHOD, l, this.maxStrLen);
        b.stringCached(c.CLIENT_WEB_REQUEST_HOSTNAME, d, this.maxStrLen);
        b.integer(c.CLIENT_WEB_REQUEST_PORTNO, f);
        if (null != a.headers && !this.willGetLateEntryData(a.headers)) {
          const {captureAllRequestHeaders:d, requestHeadersToCapture:e} = this.sensorProperties;
          n.fillOutgoingHeaders(b, c.CLIENT_WEB_REQUEST_REQUEST_HEADER, a.headers, d, e);
          -1 !== v && b.stringCached(c.CLIENT_WEB_REQUEST_QUERY, g.substr(v + 1), this.maxStrLen);
        }
      });
    }
    fillLateEntryData(a) {
      var c = h.Agent.correlation.AttachmentFieldId;
      if (a.path) {
        var f = e.parse(`scheme://host/${a.path}`);
        k.isString(f.query) && this.setStringCached(c.CLIENT_WEB_REQUEST_QUERY, f.query, this.maxStrLen);
      }
      f = this.sensorProperties;
      if (f.shallCaptureRequestHeaders()) {
        const {captureAllRequestHeaders:b, requestHeadersToCapture:d} = f;
        f = n.getHeaderNames(a);
        c = c.CLIENT_WEB_REQUEST_REQUEST_HEADER;
        for (const e of f) {
          if (f = e.toLowerCase(), b || -1 !== d.indexOf(f)) {
            const b = a.getHeader(e);
            if (Array.isArray(b)) {
              for (const a of b) {
                null != a && this.setKeyValueCached(c, f, `${a}`, this.maxStrLen);
              }
            } else {
              null != b && this.setKeyValueCached(c, f, `${b}`, this.maxStrLen);
            }
          }
        }
      }
    }
    fillExitData(a) {
      this.setMultipleFields(c => {
        const e = h.Agent.correlation.AttachmentFieldId, b = a.statusCode;
        k.isNumber(b) && c.integer(e.CLIENT_WEB_REQUEST_RESPONSECODE, b);
        if (null != a.headers) {
          const {captureAllResponseHeaders:b, responseHeadersToCapture:l} = this.sensorProperties;
          c.map(e.CLIENT_WEB_REQUEST_RESPONSE_HEADER, a.headers, a => b || -1 !== l.indexOf(a), this.maxStrLen);
        }
      });
    }
    willGetLateEntryData(a) {
      if (Array.isArray(a)) {
        return !1;
      }
      if (k.isObject(a)) {
        for (const c in a) {
          if ("expect" === c.toLowerCase()) {
            return !1;
          }
        }
      }
      return !0;
    }
  }
  a.ClientWebRequestAttachment = m;
});
S("src/lib/transformer/HttpClientTransformer", "require exports url src/lib/Debug src/lib/Embedder src/lib/FunctionId src/lib/Logger src/lib/SubPathContext src/lib/Tracing src/lib/modules/AutoSensorModule src/lib/sensors/ClientWebRequestAttachment src/lib/sensors/SensorConstants src/lib/transformer/EventEmitterTransformerBase src/lib/transformer/TransformerBase src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/EventUtil src/lib/util/InvocationUtil src/lib/util/UniqueId".split(" "), function(t, 
a, e, h, f, k, n, m, g, c, r, b, d, l, x, p, q, v, D) {
  function C(b) {
    try {
      const a = this.listenerCount("response");
      1 >= a ? b._dump() : n.warning(`ClientWebRequest: dummyOnResponse but cnt is ${a}`);
    } catch (K) {
    }
  }
  function u(b, a) {
    x.isString(b) ? b = e.parse(b) : null != b && x.isFunction(e.URL) && b instanceof e.URL ? b = {protocol:b.protocol, hostname:b.hostname, path:b.pathname + b.search, port:"" !== b.port ? b.port : void 0} : (a = b, b = {});
    x.isFunction(a) && (a = void 0);
    return Object.assign(b, a);
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class z {
    constructor(b, a, d) {
      this.reqOpts = b;
      this.isHttps = a;
      this.sensor = d;
      this.onRequestInjected = !1;
      this.id = D.UniqueId.getNext();
    }
    createAttachments(b) {
      b = new r.ClientWebRequestAttachment(b, this.sensor.properties);
      if (b.valid) {
        this.attachment = b;
        try {
          b.fillEntryData(this.reqOpts, this.isHttps);
        } catch (K) {
          p.logAgentException(K);
        }
      } else {
        this.sensor.isDebugEnabled && n.debug(`${this}: fillEntryData() - failed to create attachment`);
      }
    }
    fillAttachmentLateEntryData() {
      h.assert(null != this.attachment);
      if (null != this.attachment && null != this.theClientRequest) {
        try {
          this.attachment.fillLateEntryData(this.theClientRequest);
        } catch (I) {
          p.logAgentException(I);
        }
      }
    }
    fillAttachmentExitData(b) {
      if (null != this.attachment) {
        try {
          this.attachment.fillExitData(b);
        } catch (K) {
          p.logAgentException(K);
        }
      } else {
        h.fail();
      }
    }
    set clientRequest(b) {
      z.embedder.set(b, this);
      this.theClientRequest = b;
    }
    endAsyncSubPath() {
      null != this.vNodeActivation && (this.vNodeActivation.spc.end(), this.vNodeActivation = void 0, null != this.theClientRequest && z.embedder.clear(this.theClientRequest), this.theClientRequest = void 0);
    }
    toString() {
      this.logPrefix || (this.logPrefix = `ClientWebRequest ${D.UniqueId.asString(this.id)}`);
      return this.logPrefix;
    }
    static getTracker(b) {
      return z.embedder.get(b) || z.activeTracker;
    }
  }
  z.activeTracker = void 0;
  z.embedder = f.create("clientRequest");
  a.normalizeOptions = u;
  class B extends l.TransformerBase {
    constructor(b, a) {
      super(b);
      this.sensor = b;
      this.isHttps = a;
    }
    generateSubstitute(b) {
      const a = this, d = new k.FunctionId(b);
      return function(...l) {
        const f = a.controlParams.isDebugEnabled;
        f && n.debug(`ClientWebRequest: request() argsCnt: ${l.length}`);
        if (!a.controlParams.active) {
          return f && n.debug("ClientWebRequest: request() exit - inactive"), v.doInvoke(this, b.origFn, l);
        }
        var h = l[0];
        const k = l[1];
        let w, q, r;
        try {
          var I = u(h, k);
          const b = !a.sensor.properties.shallCaptureUrl(I.path);
          b && f && n.debug(`ClientWebRequest: suppress path for: ${I.path}`);
          if (!b) {
            if (q = new z(I, a.isHttps, a.sensor), w = a.tryStartAsyncActivation({functionId:d, attachmentCreator:q}), null != w) {
              if (q.vNodeActivation = w.vNodeActivation, r = w.vNodeActivation.spc.createAddSerializeLink(!0, g.Tracing.getHttpTaggingMode()), f) {
                const b = q.attachment;
                n.debug(`${q}: request() virt: ${w.vNodeActivation.spc}, init: ${w.initiatorActivation.spc}, tag: ${g.Tracing.traceContextToString(r)}, ${b}`);
              }
            } else {
              f && n.debug(`${q}: request() no method activation, active spc: ${m.SubPathContext.getActiveContext()}`);
            }
          }
        } catch (T) {
          p.logAgentException(T);
        }
        if (null == w) {
          return v.doInvoke(this, b.origFn, l);
        }
        null != r && ((I = new g.Tracing(r), h instanceof e.URL || !x.hasProperty(h, "headers")) ? !x.isFunction(k) && x.hasProperty(k, "headers") && (h = B.addTaggingHeaderInOptions(I, k, f), null != h && (l[1] = h, r = void 0)) : (h = B.addTaggingHeaderInOptions(I, h, f), null != h && (l[0] = h, r = void 0)));
        z.activeTracker = q;
        l = v.safeInvoke(this, b.origFn, l);
        z.activeTracker = void 0;
        try {
          c.addSample(d);
          if (l.didThrow) {
            B.closeAsyncExePathWithException(q, l.exception);
          } else {
            const b = l.retVal;
            q.clientRequest = b;
            b.on("error", B.getErrorListener(q));
            null != r && (new g.Tracing(r)).setHttpTaggingHeadersOnRequest(b);
          }
          w.initiatorActivationDone(l.exception);
        } catch (T) {
          p.logAgentException(T);
        }
        f && n.debug(`${null != q ? q.toString() : "ClientWebRequest"}: request() exit didThrow: ${l.didThrow ? p.verboseExceptionObject(l.exception) : "-"}`);
        return l.rethrow();
      };
    }
    static addTaggingHeaderInOptions(a, d, c) {
      let e;
      Array.isArray(d.headers) ? (e = Object.assign(Object.create(null), d), e.headers = e.headers.slice(0), a.useDtTagging() && e.headers.push([b.cHttpTaggingHeader, a.dtTag]), a.useTraceContext() && (e.headers.push([b.cHttpTraceParent, a.traceParent]), a.isTraceStateValid() && e.headers.push([b.cHttpTraceState, a.traceState]))) : x.isObject(d.headers) ? (e = Object.assign({}, d), e.headers = Object.assign({}, e.headers), a.useDtTagging() && (e.headers[b.cHttpTaggingHeader] = a.dtTag), a.useTraceContext() && 
      (e.headers[b.cHttpTraceParent] = a.traceParent, a.isTraceStateValid() && (e.headers[b.cHttpTraceState] = a.traceState))) : c && n.debug(`ClientWebRequest: headers property present in options but unknown type: ${typeof d.headers}`);
      return e;
    }
    static getErrorListener(b) {
      return function(a) {
        B.closeAsyncExePathWithException(b, a);
        q.reEmitErrorIfNeeded(this, a);
      };
    }
    static closeAsyncExePathWithException(b, a) {
      let d;
      if (null != b.vNodeActivation) {
        try {
          d = b.vNodeActivation.spc, b.vNodeActivation.methodException(a), b.endAsyncSubPath();
        } catch (H) {
          p.logAgentException(H);
        }
      }
      b.sensor.isDebugEnabled && n.debug(`${b}: closeAsyncExePathWithException() spc: ${d}, err: ${p.verboseExceptionObject(a)}`);
    }
  }
  a.RequestTransformer = B;
  class A {
    constructor(b) {
      this.controlParams = b;
    }
    generateSubstitute(b) {
      const a = this;
      return function(...d) {
        try {
          const b = a.controlParams.isDebugEnabled, d = z.getTracker(this);
          null != d ? (b && n.debug(`${d}: _storeHeadersSubstitute()`), 0 === this.listenerCount("response") && (this.on("response", C), d.onRequestInjected = !0, b && n.debug(`${d}: installed dummy response listener`)), d.fillAttachmentLateEntryData()) : b && n.debug("ClientWebRequest: unmonitored _storeHeadersSubstitute()");
        } catch (H) {
          p.logAgentException(H);
        }
        return v.doInvoke(this, b.origFn, d);
      };
    }
  }
  a.ClientRequestStoreHeadersTransformer = A;
  class w extends d.EventEmitterTransformerBase {
    constructor(b) {
      super(b, "response");
    }
    shallWrap(b) {
      return null != z.getTracker(b);
    }
    getWrappedListener(b, a, e) {
      const f = z.getTracker(b);
      if (null == f) {
        return e;
      }
      f.onRequestInjected && (b.removeListener("response", C), f.onRequestInjected = !1);
      const g = d.EventEmitterTransformerBase.getUnwrappedListener(e);
      return function(...b) {
        const a = b[0], d = f.sensor.isDebugEnabled;
        if (null == f.vNodeActivation) {
          return d && n.debug(`${f}: onResponse() vNode already closed status: ${a.statusCode}`), v.doInvoke(this, e, b);
        }
        let h, w;
        try {
          null != a.statusCode && f.fillAttachmentExitData(a), f.vNodeActivation.exit(), f.onRequestInjected || (h = new k.FunctionId(g), w = l.TransformerBase.createCallbackActivation(f.vNodeActivation.spc, h));
        } catch (R) {
          p.logAgentException(R);
        }
        b = v.safeInvoke(this, e, b);
        try {
          null != w && (e === g && c.addSample(h), w.done(b.exception)), f.endAsyncSubPath();
        } catch (R) {
          p.logAgentException(R);
        }
        d && n.debug(`${f}: onResponse() status: ${a.statusCode}, didThrow: ${b.didThrow ? p.verboseExceptionObject(b.exception) : "-"}`);
        return b.rethrow();
      };
    }
  }
  a.ClientRequestEmitterTransformer = w;
});
S("src/lib/transformer/Http2ClientTransformer", "require exports events src/lib/transformer/EventEmitterTransformerBase src/lib/transformer/TransformerBase src/lib/Agent src/lib/AttachmentBase src/lib/Debug src/lib/Embedder src/lib/FunctionId src/lib/Patch src/lib/SubPathContext src/lib/Tracing src/lib/modules/AutoSensorModule src/lib/util/CoreUtil src/lib/util/EventUtil src/lib/util/ErrorUtil src/lib/util/HttpUtil src/lib/util/InvocationUtil src/lib/util/UniqueId".split(" "), function(t, a, e, h, 
f, k, n, m, g, c, r, b, d, l, x, p, q, v, D, C) {
  function u() {
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const z = [];
  a.addCheckForOutgoingRequestSuppression = function(b) {
    z.includes(b) || z.push(b);
  };
  class B extends n.AttachmentBase {
    constructor(b, a) {
      super(b, k.Agent.correlation.AttachmentId.ATTACHMENT_CLIENT_WEBREQUEST_ID, 0);
      this.sensorProperties = a;
      this.maxStrLen = v.getWebRequestMaxStringLen();
    }
    fillEntryData(b = "https:", a = "localhost", d) {
      this.setMultipleFields(c => {
        d = x.isObject(d) ? d : {};
        let e;
        switch(b.toLowerCase()) {
          case "https:":
            e = 443;
            break;
          case "http:":
            e = 80;
        }
        var l = d[":authority"];
        x.isString(l) || (l = a);
        let f = "localhost", g = e;
        if (x.isString(l)) {
          var h = l.indexOf(":");
          -1 !== h ? (f = l.substr(0, h), g = +l.substr(h + 1)) : f = l;
        }
        l = x.isString(d[":method"]) ? d[":method"] : "GET";
        h = "/";
        let w;
        if (null != d[":path"]) {
          var u = `${d[":path"]}`;
          const b = u.indexOf("?");
          -1 !== b ? (h = u.substr(0, b), w = u.substr(b + 1)) : h = u;
        }
        u = k.Agent.correlation.AttachmentFieldId;
        c.stringCached(u.CLIENT_WEB_REQUEST_URI, `${b}//${f}` + (g === e ? "" : `:${g}`) + h, this.maxStrLen);
        c.stringCached(u.CLIENT_WEB_REQUEST_METHOD, l, this.maxStrLen);
        c.stringCached(u.CLIENT_WEB_REQUEST_HOSTNAME, f, this.maxStrLen);
        null != g && c.integer(u.CLIENT_WEB_REQUEST_PORTNO, g);
        null != w && this.setStringCached(u.CLIENT_WEB_REQUEST_QUERY, w, this.maxStrLen);
        this.sensorProperties.shallCaptureRequestHeaders() && v.fillOutgoingHeaders(c, u.CLIENT_WEB_REQUEST_REQUEST_HEADER, d, this.sensorProperties.captureAllRequestHeaders, this.sensorProperties.requestHeadersToCapture);
      });
    }
    fillExitData(b) {
      this.setMultipleFields(a => {
        const d = k.Agent.correlation.AttachmentFieldId, c = b[":status"];
        x.isNumber(c) && a.integer(d.CLIENT_WEB_REQUEST_RESPONSECODE, c);
        const e = this.sensorProperties.captureAllResponseHeaders, l = this.sensorProperties.responseHeadersToCapture;
        a.map(d.CLIENT_WEB_REQUEST_RESPONSE_HEADER, b, b => e || -1 !== l.indexOf(b), this.maxStrLen);
      });
    }
  }
  a.ClientWebRequestAttachment = B;
  class A {
    constructor(b, a, d) {
      this.clientSession = b;
      this.headers = a;
      this.sensor = d;
      this.onRequestInjected = !1;
      this.id = C.UniqueId.getNext();
    }
    createAttachments(b) {
      b = new B(b, this.sensor.properties);
      if (b.valid) {
        this.attachment = b;
        try {
          b.fillEntryData(this.clientSession[I.kProtocol], this.clientSession[I.kAuthority], this.headers);
        } catch (L) {
          q.logAgentException(L);
        }
      } else {
        this.sensor.isDebugEnabled && k.Logger.debug(`${this}: fillEntryData() - failed to create attachment`);
      }
    }
    fillAttachmentExitData(b) {
      if (null != this.attachment) {
        try {
          this.attachment.fillExitData(b);
        } catch (L) {
          q.logAgentException(L);
        }
      } else {
        m.fail();
      }
    }
    set clientStream(b) {
      A.embedder.set(b, this);
      this.theClientStream = b;
    }
    endAsyncSubPath() {
      null != this.vNodeActivation && (this.vNodeActivation.spc.end(), this.vNodeActivation = void 0, null != this.theClientStream && A.embedder.clear(this.theClientStream), this.theClientStream = void 0);
    }
    toString() {
      this.logPrefix || (this.logPrefix = `ClientWebRequest ${C.UniqueId.asString(this.id)}`);
      return this.logPrefix;
    }
    static getTracker(b) {
      return A.embedder.get(b);
    }
  }
  A.embedder = g.create("clientStream");
  class w {
    constructor(b) {
      this.kProtocol = this.kAuthority = this.dummySymbol = Symbol("Dummy");
      try {
        const a = Object.getOwnPropertySymbols(b);
        for (const b of a) {
          switch(b.toString()) {
            case "Symbol(authority)":
              this.kAuthority = b;
              break;
            case "Symbol(protocol)":
              this.kProtocol = b;
          }
        }
      } catch (L) {
        q.logAgentException(L);
      }
    }
  }
  a.SymbolExtractor = w;
  let I;
  class K {
    constructor(b) {
      this.sensor = b;
      this.connectPatched = !1;
    }
    generateSubstitute(b) {
      const a = this;
      return function(...d) {
        const c = a.sensor.isDebugEnabled;
        c && k.Logger.debug(`Http2Client: connect(): ${d.length}`);
        d = D.safeInvoke(this, b.origFn, d);
        if (d.didThrow || a.connectPatched) {
          c && k.Logger.debug(`Http2Client: connect() exit with exception: ${d.exception}`);
        } else {
          try {
            const b = d.retVal;
            if (b instanceof e.EventEmitter) {
              c && k.Logger.debug(`Http2Client: connect() patching ${b.constructor && b.constructor.name}`);
              null == I && (I = new w(b));
              const d = new r.FunctionSpec("request", "ClientHttp2Session", b.constructor.prototype), e = new O(a.sensor);
              null == r.applyToSingle(d, e) && k.Logger.warning("Http2Client: Failed to patch ClientHttp2Session.request");
              a.connectPatched = !0;
            } else {
              k.Logger.info(`Http2Client: connect() skip patching client as it is no emitter: ${b && b.constructor && b.constructor.name}`);
            }
          } catch (N) {
            q.logAgentException(N);
          }
        }
        return d.rethrow();
      };
    }
  }
  a.ConnectTransformer = K;
  class O extends f.TransformerBase {
    constructor(b) {
      super(b);
      this.sensor = b;
    }
    generateSubstitute(a) {
      const e = this, f = new c.FunctionId(a);
      return function(...c) {
        const g = e.controlParams.isDebugEnabled;
        g && k.Logger.debug(`ClientWebRequest: request(): ${c.length}`);
        if (!e.controlParams.active) {
          return g && k.Logger.debug("ClientWebRequest: request() exit - inactive"), D.doInvoke(this, a.origFn, c);
        }
        let h, w;
        try {
          const a = 0 < c.length && x.isObject(c[0]) && !Array.isArray(c[0]) ? c[0] : void 0;
          if (!e.shouldSuppress(a)) {
            if (w = new A(this, a, e.sensor), h = e.tryStartAsyncActivation({functionId:f, attachmentCreator:w}), null != h) {
              w.vNodeActivation = h.vNodeActivation;
              const b = h.vNodeActivation.spc.createAddSerializeLink(!0, d.Tracing.getHttpTaggingMode());
              if (null != b) {
                const e = new d.Tracing(b);
                0 === c.length ? c = [e.getHttpTaggingHeaders()] : null != a ? c[0] = Object.assign(Object.create(null), a, e.getHttpTaggingHeaders()) : null == c[0] ? c[0] = e.getHttpTaggingHeaders() : g && k.Logger.debug(`${w}: request() can't set tag as headers object seems to be invalid ${typeof a}`);
              }
              if (g) {
                const a = w.attachment;
                k.Logger.debug(`${w}: request() virt: ${h.vNodeActivation.spc}, init: ${h.initiatorActivation.spc}, tag: ${d.Tracing.traceContextToString(b)}, ${a}`);
              }
            } else {
              g && k.Logger.debug(`${w}: request() no method activation, active spc: ${b.SubPathContext.getActiveContext()}`);
            }
          }
        } catch (T) {
          q.logAgentException(T);
        }
        c = D.safeInvoke(this, a.origFn, c);
        try {
          if (l.addSample(f), null != h) {
            if (h.initiatorActivationDone(c.exception), c.didThrow) {
              O.closeAsyncExePath(w, c.exception);
            } else {
              const b = c.retVal;
              w.clientStream = b;
              e.patchClientStream(b);
              b.on("response", u);
              w.onRequestInjected = !0;
              b.on("error", O.getErrorListener(w));
              b.on("close", O.getCloseListener(w));
            }
          }
        } catch (T) {
          q.logAgentException(T);
        }
        g && k.Logger.debug(`${null != w ? w.toString() : "ClientWebRequest"}: request() exit didThrow: ${c.didThrow ? q.verboseExceptionObject(c.exception) : "-"}`);
        return c.rethrow();
      };
    }
    static getErrorListener(b) {
      return function(a) {
        O.closeAsyncExePath(b, a);
        p.reEmitErrorIfNeeded(this, a);
      };
    }
    static getCloseListener(b) {
      return function() {
        O.closeAsyncExePath(b);
      };
    }
    static closeAsyncExePath(b, a) {
      let d;
      if (null != b.vNodeActivation) {
        try {
          d = b.vNodeActivation.spc, b.vNodeActivation.exitOrException(a), b.endAsyncSubPath();
        } catch (J) {
          q.logAgentException(J);
        }
      }
      b.sensor.isDebugEnabled && k.Logger.debug(`${b}: closeAsyncExePath() spc: ${d}, err: ${null != a ? q.verboseExceptionObject(a) : "-"}`);
    }
    patchClientStream(b) {
      if (!O.clientStreamPatched) {
        O.clientStreamPatched = !0;
        var a = b.constructor.prototype;
        b = new H(this.sensor);
        a = new r.ModuleSpec("ClientHttp2Stream", a);
        b.applyTransformation(a);
      }
    }
    shouldSuppress(b) {
      var a = null != b ? b[":path"] : void 0;
      if (!this.sensor.properties.shallCaptureUrl(a)) {
        return this.isDebugEnabled && k.Logger.debug(`ClientWebRequest: suppress path for: ${a}`), !0;
      }
      a = null != b ? v.lookupKeyname(b, "content-type") : void 0;
      if (x.isString(a)) {
        for (const d of z) {
          const c = b[a];
          if (x.isString(c)) {
            if (d(c)) {
              return this.isDebugEnabled && k.Logger.debug(`ClientWebRequest: suppress path for ${a}: ${c}`), !0;
            }
          } else {
            this.isDebugEnabled && k.Logger.debug(`ClientWebRequest: Header ${a} does not hold a string value`);
          }
        }
      }
      return !1;
    }
  }
  O.clientStreamPatched = !1;
  class H extends h.EventEmitterTransformerBase {
    constructor(b) {
      super(b, "response");
    }
    shallWrap(b) {
      return null != A.getTracker(b);
    }
    getWrappedListener(b, a, d) {
      const e = A.getTracker(b);
      if (null == e) {
        return d;
      }
      e.onRequestInjected && (e.onRequestInjected = !1, b.removeListener("response", u));
      const g = h.EventEmitterTransformerBase.getUnwrappedListener(d);
      return function(...b) {
        const a = b[0], h = e.sensor.isDebugEnabled;
        if (null == e.vNodeActivation) {
          return h && k.Logger.debug(`${e}: onResponse() vNode already closed status: ${a[":status"]}`), D.doInvoke(this, d, b);
        }
        let w, u;
        try {
          null != a && e.fillAttachmentExitData(a), e.vNodeActivation.exit(), e.onRequestInjected || (w = new c.FunctionId(g), u = f.TransformerBase.createCallbackActivation(e.vNodeActivation.spc, w));
        } catch (F) {
          q.logAgentException(F);
        }
        b = D.safeInvoke(this, d, b);
        try {
          null != u && (d === g && l.addSample(w), u.done(b.exception)), e.endAsyncSubPath();
        } catch (F) {
          q.logAgentException(F);
        }
        h && k.Logger.debug(`${e}: onResponse() status: ${a[":status"]}, didThrow: ${b.didThrow ? q.verboseExceptionObject(b.exception) : "-"}`);
        return b.rethrow();
      };
    }
  }
});
S("src/lib/sensors/ClientWebRequestSensor", "require exports semver src/lib/Logger src/lib/Debug src/lib/Patch src/lib/RunTimeProperty src/lib/sensors/ClientWebRequestSensorProperties src/lib/sensors/SensorBase src/lib/transformer/HttpClientTransformer src/lib/transformer/Http2ClientTransformer".split(" "), function(t, a, e, h, f, k, n, m, g, c, r) {
  Object.defineProperty(a, "__esModule", {value:!0});
  const b = new n.BooleanProperty("Http2ClientInstrumentationEnabled", !1);
  class d extends g.SensorBase {
    constructor(b, a, d, c) {
      super(b, a, d, c);
      this.properties = new m.ClientWebRequestSensorProperties(a);
    }
    applyInstrumentation(a) {
      switch(a.request) {
        case "http":
          this.transformRequest(a);
          this.transformGet(a);
          this.transformClientRequestStoreHeader(a);
          this.transformClientRequestEmitter(a);
          break;
        case "https":
          this.transformRequest(a);
          this.transformGet(a);
          break;
        case "http2":
          b.value || this.properties.enableHttp2Transformer ? this.transformHttp2Connect(a) : h.info("Instrumenting HTTP2 client is disabled");
      }
    }
    updateState(b) {
      super.updateState(b);
      this.properties.update(b);
    }
    transformRequest(b) {
      var a = new k.FunctionSpec("request", b.request, b.moduleExports, "http");
      b = new c.RequestTransformer(this, "https" === b.request);
      a = k.applyToSingle(a, b);
      f.assert(null != a);
    }
    transformClientRequestEmitter(b) {
      b = new k.ModuleSpec("ClientRequest", b.moduleExports.ClientRequest.prototype);
      (new c.ClientRequestEmitterTransformer(this)).applyTransformation(b);
    }
    transformClientRequestStoreHeader(b) {
      b = new k.FunctionSpec("_storeHeader", "ClientRequest", b.moduleExports.ClientRequest.prototype);
      const a = new c.ClientRequestStoreHeadersTransformer(this);
      b = k.applyToSingle(b, a, k.cPolymorphicDefaultOptions);
      f.assert(null != b);
    }
    transformGet(b) {
      if ("https" !== b.request || e.satisfies(process.version, ">=9.0.0 || 8.9.0", {includePrerelease:!0})) {
        var a = b.moduleExports;
        b = new k.FunctionSpec("get", b.request, a);
        k.substitute(b, function() {
          const b = a.request.apply(a, arguments);
          b.end();
          return b;
        });
      }
    }
    transformHttp2Connect(b) {
      b = new k.FunctionSpec("connect", b.request, b.moduleExports, "http");
      const a = new r.ConnectTransformer(this);
      b = k.applyToSingle(b, a);
      f.assert(null != b);
    }
  }
  a.ClientWebRequestSensor = d;
});
S("src/lib/transformer/EventEmitterContextPassingTransformer", "require exports src/lib/transformer/EventEmitterTransformerBase src/lib/FunctionId src/lib/SubPathContext src/lib/modules/AutoSensorModule src/lib/util/InvocationUtil src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class g extends e.EventEmitterTransformerBase {
    shallWrap() {
      return this.controlParams.active && null != f.SubPathContext.getActiveContext();
    }
    getWrappedListener(a, e, b) {
      if (!this.controlParams.active) {
        return b;
      }
      let d;
      try {
        d = f.SubPathContext.getActiveContext(), null != d && (d.didInitiateAsyncOp = !0);
      } catch (l) {
        m.logAgentException(l);
      }
      return null != d ? g.getListenerClosure(d, b) : b;
    }
    static getListenerClosure(a, f) {
      const b = e.EventEmitterTransformerBase.getUnwrappedListener(f);
      return function() {
        try {
          a.activate();
        } catch (l) {
          m.logAgentException(l);
        }
        const d = n.safeInvoke(this, f, arguments);
        try {
          f === b && k.addSample(() => new h.FunctionId(f)), a.deactivate();
        } catch (l) {
          m.logAgentException(l);
        }
        return d.rethrow();
      };
    }
  }
  a.EventEmitterContextPassingTransformer = g;
});
S("src/lib/sensors/EventEmitterContextPassingSensor", "require exports src/lib/Agent src/lib/sensors/SensorBase src/lib/Patch src/lib/transformer/EventEmitterContextPassingTransformer".split(" "), function(t, a, e, h, f, k) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class n extends h.SensorBase {
    applyInstrumentation(a) {
      const g = new f.ModuleSpec("EventEmitter", a.moduleExports.EventEmitter.prototype), c = new k.EventEmitterContextPassingTransformer(this);
      this.isDebugEnabled && e.Logger.debug(`${this.name}: instrumenting module ${a.toString(!0)}`);
      c.applyTransformation(g);
    }
  }
  a.EventEmitterContextPassingSensor = n;
});
S("src/lib/util/JsonObfuscatorUtil", ["require", "exports", "src/lib/Configuration"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class h {
    static normalizeQueryToString(a, e) {
      h.initialized || h.initialize();
      this.whitelist = e;
      a = this.internal_normalizeQueryToString(a, 0);
      this.whitelist = void 0;
      return a;
    }
    static initialize() {
      h.isAppMon = 1 === e.Configuration.activeProduct;
      h.maxStringLength = e.Configuration.maxSqlStringLen;
      h.initialized = !0;
    }
    static internal_normalizeQueryToString(a, e) {
      let f = "";
      if (e >= this.maxRecursionDepth || null === a || void 0 === a || a instanceof RegExp || "object" !== typeof a) {
        return f += h.isAppMon ? a : this.queryValueReplacer;
      }
      if (a instanceof Array) {
        f += "[";
        for (var k = 0; k < a.length; ++k) {
          f += this.internal_normalizeQueryToString(a[k], e + 1);
          if (f.length > h.maxStringLength) {
            break;
          }
          k < a.length - 1 && (f += ",");
        }
        f += "]";
      } else {
        f += "{";
        k = 0;
        const g = void 0 === this.whitelist ? Object.keys(a) : this.whitelist;
        for (const c of g) {
          if (Object.hasOwnProperty.call(a, c) && (f += `${0 === k ? "" : ","}${c}:`, k++, f += this.internal_normalizeQueryToString(a[c], e + 1), f.length > h.maxStringLength)) {
            break;
          }
        }
        f += "}";
      }
      return f.length > h.maxStringLength ? f.slice(0, h.maxStringLength) : f;
    }
  }
  a.QueryNormalizer = h;
  h.initialized = !1;
  h.maxRecursionDepth = 50;
  h.queryValueReplacer = "?";
});
S("src/lib/sensors/MongoDbAttachmentUtils", "require exports semver src/lib/Agent src/lib/util/CoreUtil src/lib/util/JsonObfuscatorUtil".split(" "), function(t, a, e, h, f, k) {
  function n(b) {
    return b && "object" === typeof b ? k.QueryNormalizer.normalizeQueryToString(b) : b;
  }
  function m(b) {
    switch(b) {
      case c.aggregate:
        return "pipeline:";
      case c.bulkWrite:
        return "operations:";
      case c.createIndex:
      case c.ensureIndex:
        return "fieldOrSpec:";
      case c.createIndexes:
        return "indexSpecs:";
      case c.deleteMany:
      case c.deleteOne:
      case c.listCollections:
      case c.findOneAndReplace:
      case c.findOneAndUpdate:
      case c.findOneAndDelete:
      case c.replaceOne:
      case c.updateMany:
      case c.updateOne:
        return "filter:";
      case c.dropIndex:
        return "indexName:";
      case c.collection:
      case c.createCollection:
        return "name:";
      case c.command:
        return "command:";
      case c.indexExists:
        return "indexes:";
      case c.insert:
      case c.insertMany:
      case c.insertOne:
        return "docs:";
      case c.rename:
        return "newName:";
      case c.remove:
      case c.update:
        return "selector:";
      case c.save:
        return "doc:";
      default:
        return "query:";
    }
  }
  function g(b) {
    switch(b) {
      case c.distinct:
        return 0;
      case c.findAndModify:
        return 2;
      case c.findOneAndReplace:
      case c.findOneAndUpdate:
      case c.replaceOne:
      case c.update:
      case c.updateMany:
      case c.updateOne:
        return 1;
      default:
        return -1;
    }
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  var c;
  (function(b) {
    b[b.aggregate = 0] = "aggregate";
    b[b.authenticate = 1] = "authenticate";
    b[b.bulkWrite = 2] = "bulkWrite";
    b[b.close = 3] = "close";
    b[b.collection = 4] = "collection";
    b[b.count = 5] = "count";
    b[b.createCollection = 6] = "createCollection";
    b[b.createIndexes = 7] = "createIndexes";
    b[b.createIndex = 8] = "createIndex";
    b[b.command = 9] = "command";
    b[b.deleteMany = 10] = "deleteMany";
    b[b.deleteOne = 11] = "deleteOne";
    b[b.dropIndex = 12] = "dropIndex";
    b[b.drop = 13] = "drop";
    b[b.dropAllIndexes = 14] = "dropAllIndexes";
    b[b.dropDatabase = 15] = "dropDatabase";
    b[b.distinct = 16] = "distinct";
    b[b.dropIndexes = 17] = "dropIndexes";
    b[b.ensureIndex = 18] = "ensureIndex";
    b[b.find = 19] = "find";
    b[b.findOne = 20] = "findOne";
    b[b.findAndModify = 21] = "findAndModify";
    b[b.findOneAndReplace = 22] = "findOneAndReplace";
    b[b.findOneAndUpdate = 23] = "findOneAndUpdate";
    b[b.findAndRemove = 24] = "findAndRemove";
    b[b.findOneAndDelete = 25] = "findOneAndDelete";
    b[b.indexInformation = 26] = "indexInformation";
    b[b.indexExists = 27] = "indexExists";
    b[b.insert = 28] = "insert";
    b[b.insertMany = 29] = "insertMany";
    b[b.insertOne = 30] = "insertOne";
    b[b.listCollections = 31] = "listCollections";
    b[b.listIndexes = 32] = "listIndexes";
    b[b.mapReduce = 33] = "mapReduce";
    b[b.open = 34] = "open";
    b[b.reIndex = 35] = "reIndex";
    b[b.rename = 36] = "rename";
    b[b.remove = 37] = "remove";
    b[b.replaceOne = 38] = "replaceOne";
    b[b.save = 39] = "save";
    b[b.update = 40] = "update";
    b[b.updateMany = 41] = "updateMany";
    b[b.updateOne = 42] = "updateOne";
  })(c || (c = {}));
  a.methodNameToMethodType = function(b) {
    switch(c[b]) {
      case c.aggregate:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_AGGREGATE;
      case c.open:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_CONNECTION_ACQUISITION;
      case c.close:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_COMMAND;
      case c.collection:
      case c.listCollections:
      case c.listIndexes:
      case c.indexInformation:
      case c.indexExists:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_LISTCOLLECTIONS;
      case c.createCollection:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_CREATECOLLECTION;
      case c.dropDatabase:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_DROPDATABASE;
      case c.command:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_COMMAND;
      case c.insert:
      case c.insertMany:
      case c.insertOne:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_INSERT;
      case c.save:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_SAVE;
      case c.count:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_GET_COUNT;
      case c.find:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_FIND;
      case c.findOne:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_FIND_ONE;
      case c.findAndModify:
      case c.findOneAndReplace:
      case c.replaceOne:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_FIND_AND_MODIFY;
      case c.update:
      case c.updateMany:
      case c.updateOne:
      case c.findOneAndUpdate:
      case c.rename:
      case c.createIndex:
      case c.createIndexes:
      case c.ensureIndex:
      case c.reIndex:
      case c.bulkWrite:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_UPDATE;
      case c.findAndRemove:
      case c.findOneAndDelete:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_FIND_AND_REMOVE;
      case c.distinct:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_DISTINCT;
      case c.remove:
      case c.deleteMany:
      case c.deleteOne:
      case c.dropIndex:
      case c.drop:
      case c.dropAllIndexes:
      case c.dropIndexes:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_REMOVE;
      case c.authenticate:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_AUTHENTICATE;
      case c.mapReduce:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_MONGO_DB_MAP_REDUCE;
      default:
        return h.Agent.correlation.DbMethodType.DB_METHOD_TYPE_UNKNOWN;
    }
  };
  class r {
    constructor(b, a) {
      this.version = a;
      this.hostName = this.databaseName = "";
      this.portNumber = -1;
      this.collectionName = "";
      this.poolSize = -1;
      this.initialize(b);
    }
    updateDatabaseAttachmentInfo(b) {
      const a = e.satisfies(this.version, "<=1.4");
      b = a ? b : b.s;
      "" === this.databaseName && (this.databaseName = this.findDatabaseName(b));
      "" === this.collectionName && (this.collectionName = this.findCollectionName(b, a));
    }
    initialize(b) {
      const a = e.satisfies(this.version, "<=1.4");
      if (null != b) {
        b = a ? b : b.s;
        const d = this.findReplicationSetPrimaryOptions(b, this.version);
        this.databaseName = this.findDatabaseName(b);
        this.hostName = this.findHostName(b, d, this.version);
        this.portNumber = this.findPort(b, d);
        this.collectionName = this.findCollectionName(b, a);
        this.poolSize = this.findPoolSize(b, d);
      }
    }
    findReplicationSetPrimaryOptions(b, a) {
      if (e.satisfies(a, "<=1.4")) {
        if (f.hasProperty(b, "serverConfig", "servers") && b.serverConfig.servers instanceof Array && 0 < b.serverConfig.servers.length) {
          for (const a of b.serverConfig.servers) {
            if (a.internalMaster) {
              return a;
            }
          }
        }
      } else {
        if (e.satisfies(a, ">=3.0")) {
          if (f.hasProperty(b, "topology", "s", "coreTopology", "s")) {
            if (a = b.topology.s.coreTopology.s, f.hasProperty(a, "replicaSetState", "primary", "s", "options")) {
              return a.replicaSetState.primary.s.options;
            }
          } else {
            if (f.hasProperty(b, "coreTopology", "s") && (a = b.coreTopology.s, f.hasProperty(a, "replicaSetState", "primary", "s", "options"))) {
              return a.replicaSetState.primary.s.options;
            }
          }
        } else {
          if (f.hasProperty(b, "topology", "s", "replset", "s")) {
            if (b = b.topology.s.replset.s, e.satisfies(a, "2.0 - 2.1")) {
              if (f.hasProperty(b, "replState", "primary", "s", "options")) {
                return b.replState.primary.s.options;
              }
            } else {
              if (e.satisfies(a, ">=2.2")) {
                return b;
              }
            }
          }
        }
      }
    }
    findDatabaseName(b) {
      let a = "";
      null != b && (f.hasProperty(b, "databasename") ? a = b.databasename : f.hasProperty(b, "databaseName") ? a = b.databaseName : f.hasProperty(b, "dbname") ? a = b.dbname : f.hasProperty(b, "dbName") ? a = b.dbName : f.hasProperty(b, "db", "databasename") ? a = b.db.databasename : f.hasProperty(b, "db", "databaseName") ? a = b.db.databaseName : f.hasProperty(b, "db", "dbname") ? a = b.db.dbname : f.hasProperty(b, "db", "dbName") ? a = b.db.dbName : f.hasProperty(b, "namespace", "db") && (a = b.namespace.db));
      return a;
    }
    findHostName(b, a, c) {
      let d = "";
      if (a) {
        if (f.hasProperty(a, "host")) {
          if (d = a.host, e.satisfies(c, ">=3.0") && f.hasProperty(a, "servers") && a.servers instanceof Array) {
            for (const b of a.servers) {
              if (b.host.toLocaleUpperCase().startsWith(d.toLocaleUpperCase())) {
                d = b.host;
                break;
              }
            }
          }
        } else {
          if (e.satisfies(c, ">=2.2") && f.hasProperty(a, "replicaSetState", "primary", "s", "options") && (d = a.replicaSetState.primary.s.options.host, f.hasProperty(a, "seedlist") && a.seedlist instanceof Array)) {
            for (const b of a.seedlist) {
              if (b.host.toLocaleUpperCase().startsWith(d.toLocaleUpperCase())) {
                d = b.host;
                break;
              }
            }
          }
        }
      } else {
        f.hasProperty(b, "topology", "host") ? d = b.topology.host : f.hasProperty(b, "topology", "s", "host") ? d = b.topology.s.host : f.hasProperty(b, "db", "serverConfig", "s", "host") ? d = b.db.serverConfig.s.host : f.hasProperty(b, "serverConfig", "host") ? d = b.serverConfig.host : f.hasProperty(b, "db", "serverConfig", "host") ? d = b.db.serverConfig.host : f.hasProperty(b, "host") && (d = b.host);
      }
      return d || "undefined";
    }
    findPort(b, a) {
      let d = -1;
      a ? f.hasProperty(a, "port") ? d = a.port : f.hasProperty(a, "replicaSetState", "primary", "s", "options") && (d = a.replicaSetState.primary.s.options.port) : f.hasProperty(b, "topology", "port") ? d = b.topology.port : f.hasProperty(b, "topology", "s", "port") ? d = b.topology.s.port : f.hasProperty(b, "db", "serverConfig", "s", "port") ? d = b.db.serverConfig.s.port : f.hasProperty(b, "serverConfig", "port") ? d = b.serverConfig.port : f.hasProperty(b, "db", "serverConfig", "port") ? d = 
      b.db.serverConfig.port : f.hasProperty(b, "port") && (d = b.port);
      return +d;
    }
    findCollectionName(b, a) {
      let d = "";
      null != b && (f.hasProperty(b, "collectionName") ? d = b.collectionName : f.hasProperty(b, "name") ? d = b.name : f.hasProperty(b, "db", "name") && !a ? d = b.db.name : f.hasProperty(b, "namespace", "collection") && (d = b.namespace.collection));
      return d;
    }
    findPoolSize(b, a) {
      let d = -1;
      f.hasProperty(a, "size") ? d = a.size : f.hasProperty(a, "replicaSetState", "primary", "s", "options", "size") ? d = a.replicaSetState.primary.s.options.size : f.hasProperty(b, "topology", "s", "poolSize") ? d = b.topology.s.poolSize : f.hasProperty(b, "topology", "s", "poolsize") ? d = b.topology.s.poolsize : f.hasProperty(b, "serverConfig", "connectionPool", "poolSize") ? d = b.serverConfig.connectionPool.poolSize : f.hasProperty(b, "serverConfig", "options", "poolSize") && (d = b.serverConfig.options.poolSize);
      return +d;
    }
  }
  a.MongoDbConfigurationData = r;
  a.normalizeJson = n;
  a.getNormalizedQueryString = function(b, a) {
    b = c[b];
    a: {
      switch(b) {
        case c.distinct:
          var d = 1;
          break a;
        case c.authenticate:
        case c.drop:
        case c.dropAllIndexes:
        case c.dropDatabase:
        case c.dropIndexes:
        case c.indexInformation:
        case c.listIndexes:
        case c.mapReduce:
        case c.reIndex:
        case c.insert:
        case c.insertMany:
        case c.insertOne:
          d = -1;
          break a;
        default:
          d = 0;
      }
    }
    return -1 < d && d < a.length && (a = a[d]) && !f.isFunction(a) ? m(b) + n(a) : "";
  };
  a.getUpdateString = function(b, a) {
    b = g(c[b]);
    return -1 < b && b < a.length && (a = a[b]) && !f.isFunction(a) ? "update:" + n(a) : "";
  };
});
S("src/lib/sensors/MongoDbAttachment", ["require", "exports", "src/lib/Agent", "src/lib/AttachmentBase", "src/lib/sensors/MongoDbAttachmentUtils"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.CONNECTION_POOL_TYPE_MONGODB = 17;
  a.DATABASE_TYPE = "MongoDB";
  a.DEFAULT_POOL_NAME = "default-pool";
  class k extends h.AttachmentBase {
  }
  a.MongoDbAttachment = k;
  class n extends k {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_SQL_ID, 0);
    }
    fillMongoDbQueryData(a) {
      if (null != this.attachment && null != a) {
        const c = e.Agent.correlation.AttachmentFieldId;
        this.setString(c.SQL_STATEMENT, a.makePseudoSql(), e.Configuration.maxSqlStringLen);
        null != a.dbMethod && this.attachment.setFieldInteger(c.SQL_METHOD_TYPE, f.methodNameToMethodType(a.dbMethod));
      }
    }
    updateRowCount(a) {
      null != this.attachment && this.attachment.valid && this.attachment.setFieldInteger(e.Agent.correlation.AttachmentFieldId.SQL_NUM_ROWS_RETURNED, a);
    }
  }
  a.MongoDbQueryAttachment = n;
  class m extends k {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_CONNECTION_POOL_ID, 0);
    }
    fillMongoDbConnectionPoolData(c) {
      null != this.attachment && null != c.mongDbConfigData && this.setMultipleFields(f => {
        const b = e.Agent.correlation.AttachmentFieldId;
        f.stringCached(b.CONNECTION_POOL_DB, c.mongDbConfigData.databaseName);
        f.stringCached(b.CONNECTION_POOL_URL, c.dbUrl);
        f.stringCached(b.CONNECTION_POOL_DBTYPE, a.DATABASE_TYPE);
        f.stringCached(b.CONNECTION_POOL_NAME, a.DEFAULT_POOL_NAME);
        f.stringCached(b.CONNECTION_POOL_DBHOST, c.mongDbConfigData.hostName);
        f.integer(b.CONNECTION_POOL_DBPORTNO, c.mongDbConfigData.portNumber);
        f.integer(b.CONNECTION_POOL_TYPE, a.CONNECTION_POOL_TYPE_MONGODB);
        f.integer(b.CONNECTION_POOL_AGGREGATION_MECHANISM, e.Agent.correlation.DbAggregationMechanism.DB_AGGREGATION_MECHANISM_MONGO_DB_ASYNC);
        f.integer(b.CONNECTION_POOL_SIZE, c.mongDbConfigData.poolSize);
      });
    }
  }
  a.MongoDbConnectionPoolAttachment = m;
  class g {
    constructor(a, e, b) {
      this.mongDbConfigData = a;
      this.dbMethod = e;
      this.dbUrl = this.dbUpdateString = this.dbQueryString = "";
      null != e && null != b && (this.dbQueryString = f.getNormalizedQueryString(e, b), this.dbUpdateString = f.getUpdateString(e, b));
      null != this.mongDbConfigData && (this.dbUrl = "mongodb://" + this.mongDbConfigData.hostName + (0 < this.mongDbConfigData.portNumber ? ":" + this.mongDbConfigData.portNumber : "") + "/" + this.mongDbConfigData.databaseName);
    }
    makePseudoSql() {
      let a = "";
      null != this.mongDbConfigData && (this.mongDbConfigData.collectionName && (a += this.mongDbConfigData.collectionName), this.dbMethod && (this.mongDbConfigData.collectionName && (a += "."), a += this.dbMethod), a = a + "(" + this.dbQueryString, this.dbQueryString && this.dbUpdateString && (a += ", "), a += this.dbUpdateString, a += ")");
      return a;
    }
  }
  a.MongoDbAttachmentData = g;
});
S("src/lib/transformer/PromiseTransformerUtilities", ["require", "exports", "src/lib/util/CoreUtil", "src/lib/Embedder"], function(t, a, e, h) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.PromiseEmbedder = h.create("promise");
  class f {
    static isActuallyAPromise(a) {
      return null != a && e.isFunction(a.then) ? !0 : !1;
    }
    static registerThenWrapper(e, f) {
      var g = !1, c = !1;
      const h = () => {
      }, b = b => {
        if (!c && !g) {
          throw b;
        }
      };
      a.PromiseEmbedder.createOrGet(e, () => new k).customThenWrapper = (a, e, k) => {
        e && k !== b && (c = !0);
        e || k === h || (g = !0);
        return f(a, e, k);
      };
      e.then(h, b);
    }
  }
  a.PromiseTransformerUtilities = f;
  class k {
  }
  a.EmbeddedPromiseContext = k;
});
S("src/lib/sensors/ResultSetAttachment", ["require", "exports", "src/lib/Agent", "src/lib/AttachmentBase"], function(t, a, e, h) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class f extends h.AttachmentBase {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_SQL_RESULTSET_AGGREGATION_ID, 0);
    }
  }
  a.ResultSetAttachment = f;
});
S("src/lib/transformer/MongoDbTransformer", "require exports src/lib/Agent src/lib/AsyncTracker src/lib/Debug src/lib/Embedder src/lib/FunctionId src/lib/Patch src/lib/SubPathContext src/lib/modules/AutoSensorModule src/lib/sensors/ExceptionAttachment src/lib/sensors/MongoDbAttachment src/lib/transformer/AsyncTransformerBase src/lib/transformer/PromiseTransformerUtilities src/lib/transformer/TransformerBase src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/util/UniqueId src/lib/sensors/MongoDbAttachmentUtils src/lib/sensors/ResultSetAttachment".split(" "), 
function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p, q, v, D, C, u) {
  function z(b, a, d, c, f, g, l) {
    let h;
    l && e.Logger.debug(`${a}: enter then call, isCatch ${d}`);
    try {
      if (null != a.virtualNodeActivation) {
        if (a.virtualNodeActivation.isExited) {
          const b = new n.FunctionId(f);
          h = x.TransformerBase.createCallbackActivation(a.virtualNodeActivation.spc, b);
          l && e.Logger.debug(`${a}: new callback node for ${b.functionName}: ${h}`);
        } else {
          d || null == c || (Array.isArray(c) ? a.rowCount = c.length : a.rowCount = 1, a.updateRowCount()), a.virtualNodeActivation.exitOrException(d ? c : void 0), a.virtualNodeActivation.spc.end(), l && e.Logger.debug(`${a}: ended virtual node and path`);
        }
      }
    } catch (P) {
      q.logAgentException(P);
    }
    b = v.safeInvoke(b, f, g);
    try {
      null != h && h.done(b.exception);
    } catch (P) {
      q.logAgentException(P);
    }
    l && e.Logger.debug(`${a}: exit then call, didThrow ${b.didThrow}`);
    return b.rethrow();
  }
  function B(b, a, d, c, f, g, l) {
    try {
      null != a.virtualNodeActivation && (0 < g.length && (d = !0, p.isError(c) ? (new r.ExceptionAttachment(a.virtualNodeActivation)).fillExceptionData(c) : (d = null == c || a.exitVNode, d || (Array.isArray(c) ? (a.rowCount = c.length, d = !0) : p.isBoolean(c) || p.isNumber(c) ? d = !0 : a.rowCount++)), d && !a.virtualNodeActivation.isExited && (a.updateRowCount(), a.virtualNodeActivation.exit(), l && e.Logger.debug(`${a}: ended virtual node`))), null != a.spc && a.spc.activate());
    } catch (W) {
      q.logAgentException(W);
    }
    b = v.safeInvoke(b, f, g);
    try {
      null == a.virtualNodeActivation ? A.suppressActivationCreation = !1 : (null != a.spc && a.spc.deactivate(), a.virtualNodeActivation.isExited && a.virtualNodeActivation.spc.open && a.virtualNodeActivation.spc.end());
    } catch (W) {
      q.logAgentException(W);
    }
    return b.rethrow();
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class A {
    static isActuallyACursor(b, a) {
      return b && b instanceof a;
    }
    static isActuallyADb(b, a) {
      return b && b instanceof a;
    }
    static isActuallyAClient(b, a) {
      return b && b instanceof a;
    }
    static isActuallyACollection(b, a) {
      return b && b instanceof a;
    }
  }
  a.MongoDbTransformerHelper = A;
  A.TrackerEmbedder = k.create("tracker");
  A.HostInfoEmbedder = k.create("hostName");
  class w extends d.AsyncTransformerBase {
    constructor(b, a, d) {
      super(b);
      this.cursorType = a;
      this.mongoDbVersion = d;
    }
    generateSubstitute(a) {
      const d = this, f = new n.FunctionId(a);
      return function() {
        const l = d.controlParams.isDebugEnabled;
        l && e.Logger.debug(`${a.functionName} mongoDbCallSubstitute enter`);
        let h;
        var w = arguments;
        if (d.controlParams.active) {
          try {
            if (A.suppressActivationCreation) {
              A.suppressActivationCreation = !1, l && e.Logger.debug(`${h}: suppressing activation creation`);
            } else {
              const c = A.HostInfoEmbedder.get(this);
              null != c ? (l && e.Logger.debug(`${h}: ++++++++++++ mongoconfigdata object found`), c.updateDatabaseAttachmentInfo(this)) : l && e.Logger.debug(`${h}: ---------- no mongoconfigdata object found.`);
              const f = new b.MongoDbAttachmentData(c, a.functionName, arguments);
              h = new J(f, d, a, void 0, !0);
              null != g.SubPathContext.getActiveContext() && (h.spc = g.SubPathContext.getActiveContext(), w = h.manipulateArguments(arguments));
            }
          } catch (F) {
            q.logAgentException(F);
          }
        }
        w = v.safeInvoke(this, a.origFn, w);
        try {
          c.addSample(f), null != h && null != h.spc && h.manipulateReturnValue(w);
        } catch (F) {
          q.logAgentException(F);
        }
        l && e.Logger.debug(`${a.functionName} mongoDbCallSubstitute exit, didThrow: ${w.didThrow}`);
        return w.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this;
      b.isCursorInCallback = !0;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute enter for ${b.origCb.name}`);
        try {
          b.spc.activate();
        } catch (M) {
          q.logAgentException(M);
        }
        for (var f = 0; f < arguments.length; f++) {
          A.isActuallyACursor(arguments[f], a.cursorType) && (A.TrackerEmbedder.set(arguments[f], b), d && e.Logger.debug(`${b}: storing tracker to cursor from argument`));
        }
        f = v.safeInvoke(this, b.origCb, arguments);
        try {
          c.addSample(() => new n.FunctionId(b.origCb)), b.spc.deactivate();
        } catch (M) {
          q.logAgentException(M);
        }
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute exit for ${b.origCb.name}, didThrow: ${f.didThrow}`);
        return f.rethrow();
      };
    }
    wrapReturnValue(b, a) {
      a = a.retVal;
      const d = this.controlParams.isDebugEnabled;
      A.isActuallyACursor(a, this.cursorType) && (A.TrackerEmbedder.set(a, b), d && e.Logger.debug(`${b}: storing tracker to cursor from return value`));
    }
  }
  a.MongoDbReturnsCursorTransformer = w;
  class I extends d.AsyncTransformerBase {
    constructor(b, a) {
      super(b);
      this.mongoDbVersion = a;
    }
    generateSubstitute(b) {
      const a = this, d = new n.FunctionId(b);
      return function() {
        const f = a.controlParams.isDebugEnabled;
        f && e.Logger.debug(`${b.functionName} mongoDbCursorCallSubstitute enter`);
        let g;
        let l = arguments, h;
        if (a.controlParams.active) {
          try {
            var w = A.TrackerEmbedder.get(this);
            null != w && (f && e.Logger.debug(`${w}: found tracker`), g = new J(w.mongoData, a, b, void 0, !0), g.execCount = w.execCount, g.virtualNodeActivation = w.virtualNodeActivation, g.suppressNext = "each" === b.functionName, h = a.tryStartAsyncActivation({functionId:d, category:e.Agent.correlation.MethodCategory.Database, attachmentCreator:g, vPathOption:2}), null != h && (h.initiatorActivation.spc.didInitiateAsyncOp = !0, g.spc = h.initiatorActivation.spc, g.virtualNodeActivation = h.vNodeActivation, 
            A.TrackerEmbedder.set(this, g), f && e.Logger.debug(`${g}: async activation created`)), null != g.spc && (f && e.Logger.debug(`${g}: patching callback`), l = g.manipulateArguments(arguments)));
          } catch (P) {
            q.logAgentException(P);
          }
        }
        w = v.safeInvoke(this, b.origFn, l);
        try {
          c.addSample(d), null != g && (null != g.spc && g.manipulateReturnValue(w), w.didThrow && null != g.virtualNodeActivation && (g.virtualNodeActivation.isExited || g.virtualNodeActivation.exitOrException(w.exception), g.virtualNodeActivation.spc.end())), null != h && (w.didThrow && (h.vNodeActivation.exitOrException(w.exception), h.vNodeActivation.spc.end()), h.initiatorActivationDone(w.exception));
        } catch (P) {
          q.logAgentException(P);
        }
        f && e.Logger.debug(`${b.functionName} mongoDbCursorCallSubstitute exit, didThrow: ${w.didThrow}`);
        return w.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute enter for ${b.origCb.name}`);
        try {
          if (null != b.virtualNodeActivation) {
            if (0 < arguments.length) {
              var f = !0;
              if (p.isError(arguments[0])) {
                const a = arguments[0];
                (new r.ExceptionAttachment(b.virtualNodeActivation)).fillExceptionData(a);
                d && e.Logger.debug(`${b}: ended virtual node`);
              } else {
                if (2 === arguments.length) {
                  const a = arguments[1];
                  f = null == a;
                  f || (Array.isArray(a) ? (b.rowCount = arguments[1].length, f = !0) : p.isBoolean(a) || p.isNumber(a) ? f = !0 : b.rowCount++);
                }
              }
              f && !b.virtualNodeActivation.isExited && (b.updateRowCount(), b.createResultSetAttachment && (b.setResultSetAttachmentData(), b.virtualNodeActivation.exit()));
            }
            null != b.spc && b.spc.activate();
          }
        } catch (M) {
          q.logAgentException(M);
        }
        f = v.safeInvoke(this, b.origCb, arguments);
        try {
          c.addSample(() => new n.FunctionId(b.origCb)), null == b.virtualNodeActivation ? A.suppressActivationCreation = !1 : (null != b.spc && b.spc.deactivate(), b.virtualNodeActivation.isExited && null != b.virtualNodeActivation.spc && b.virtualNodeActivation.spc.open && b.virtualNodeActivation.spc.end());
        } catch (M) {
          q.logAgentException(M);
        }
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute exit for ${b.origCb.name}, didThrow: ${f.didThrow}`);
        return f.rethrow();
      };
    }
    wrapReturnValue(b, a) {
      function d(a, d, e) {
        return function(a) {
          return B(this, b, d, a, e, arguments, c);
        };
      }
      a = a.retVal;
      const c = this.controlParams.isDebugEnabled;
      l.PromiseTransformerUtilities.isActuallyAPromise(a) && (c && e.Logger.debug(`${b}: register then wrapper and install dummy handlers`), l.PromiseTransformerUtilities.registerThenWrapper(a, d), b.returnsPromise = !0);
    }
  }
  a.MongoDbCursorTransformer = I;
  class K extends d.AsyncTransformerBase {
    constructor(b, a) {
      super(b);
      this.mongoDbVersion = a;
    }
    generateSubstitute(b) {
      const a = this, d = new n.FunctionId(b);
      return function() {
        const f = a.controlParams.isDebugEnabled;
        f && e.Logger.debug(`${b.functionName} mongoDbCursorNextCallSubstitute enter`);
        let g;
        let l = arguments, h;
        if (a.controlParams.active) {
          try {
            var w = A.TrackerEmbedder.get(this);
            null == w || w.suppressNext || (f && e.Logger.debug(`${g}: found tracker`), g = new J(w.mongoData, a, b, void 0, !0), g.execCount = w.execCount, g.suppressNext = !0, g.exitVNode = !0, g.virtualNodeActivation = w.virtualNodeActivation, A.TrackerEmbedder.set(this, g), h = a.tryStartAsyncActivation({functionId:d, category:e.Agent.correlation.MethodCategory.Database, attachmentCreator:g, vPathOption:2}), null != h && (h.initiatorActivation.spc.didInitiateAsyncOp = !0, g.spc = h.initiatorActivation.spc, 
            g.virtualNodeActivation = h.vNodeActivation, A.TrackerEmbedder.set(this, g), f && e.Logger.debug(`${g}: async activation created`)), f && e.Logger.debug(`${g}: patching callback`), null != g.spc && (l = g.manipulateArguments(arguments)));
          } catch (P) {
            q.logAgentException(P);
          }
        }
        w = v.safeInvoke(this, b.origFn, l);
        try {
          c.addSample(d), null != g && (null != g.spc && g.manipulateReturnValue(w), w.didThrow && null != g.virtualNodeActivation && (g.virtualNodeActivation.isExited || g.virtualNodeActivation.exitOrException(w.exception), g.virtualNodeActivation.spc.end())), null != h && (w.didThrow && (h.vNodeActivation.exitOrException(w.exception), h.vNodeActivation.spc.end()), h.initiatorActivationDone(w.exception));
        } catch (P) {
          q.logAgentException(P);
        }
        f && e.Logger.debug(`${b.functionName} mongoDbCursorCallSubstitute exit, didThrow: ${w.didThrow}`);
        return w.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute enter for ${b.origCb.name}`);
        try {
          if (null != b.virtualNodeActivation) {
            if (0 < arguments.length && p.isError(arguments[0])) {
              var f = arguments[0];
              (new r.ExceptionAttachment(b.virtualNodeActivation)).fillExceptionData(f);
            }
            d && e.Logger.debug(`${b}: ended virtual node`);
            b.virtualNodeActivation.isExited || b.virtualNodeActivation.exit();
          }
          null != b.spc && b.spc.activate();
        } catch (M) {
          q.logAgentException(M);
        }
        f = v.safeInvoke(this, b.origCb, arguments);
        try {
          c.addSample(() => new n.FunctionId(b.origCb)), null != b.spc && b.spc.deactivate(), null == b.virtualNodeActivation ? A.suppressActivationCreation = !1 : null != b.virtualNodeActivation.spc && b.virtualNodeActivation.spc.open && b.virtualNodeActivation.spc.end();
        } catch (M) {
          q.logAgentException(M);
        }
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute exit for ${b.origCb.name}, didThrow: ${f.didThrow}`);
        return f.rethrow();
      };
    }
    wrapReturnValue(b, a) {
      function d(a, d, e) {
        return function(a) {
          return B(this, b, d, a, e, arguments, c);
        };
      }
      a = a.retVal;
      const c = this.controlParams.isDebugEnabled;
      l.PromiseTransformerUtilities.isActuallyAPromise(a) && (c && e.Logger.debug(`${b}: register then wrapper and install dummy handlers`), l.PromiseTransformerUtilities.registerThenWrapper(a, d), b.returnsPromise = !0);
    }
  }
  a.MongoDbCursorNextTransformer = K;
  class O extends d.AsyncTransformerBase {
    constructor(b, a) {
      super(b);
      this.mongoDbVersion = a;
    }
    generateSubstitute(b) {
      const a = this, d = new n.FunctionId(b);
      return function() {
        const f = a.controlParams.isDebugEnabled;
        f && e.Logger.debug(`${b.functionName} mongoDbCursorCallSubstitute enter`);
        let g;
        let l = arguments;
        if (a.controlParams.active) {
          try {
            var h = A.TrackerEmbedder.get(this);
            if (null != h) {
              f && e.Logger.debug(`${g}: found tracker`);
              h.execCount++;
              f && e.Logger.debug(`${g}: patching callback`);
              const d = h.virtualNodeActivation, c = h.resultSetAttachment;
              g = new J(h.mongoData, a, b, h.spc, h.createResultSetAttachment);
              g.virtualNodeActivation = d;
              g.execCount = h.execCount;
              null != c && (g.resultSetAttachment = c);
              f && e.Logger.debug(`${g}: context passing only`);
              null != g.spc && (l = g.manipulateArguments(arguments));
            }
          } catch (W) {
            q.logAgentException(W);
          }
        }
        h = v.safeInvoke(this, b.origFn, l);
        try {
          c.addSample(d), null != g && null != g.spc && g.manipulateReturnValue(h);
        } catch (W) {
          q.logAgentException(W);
        }
        f && e.Logger.debug(`${b.functionName} mongoDbCursorCallSubstitute exit, didThrow: ${h.didThrow}`);
        return h.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute enter for ${b.origCb.name}`);
        try {
          if (null != b.virtualNodeActivation) {
            if (0 < arguments.length && p.isError(arguments[0])) {
              var f = arguments[0];
              (new r.ExceptionAttachment(b.virtualNodeActivation)).fillExceptionData(f);
            }
            b.createResultSetAttachment && b.setResultSetAttachmentData();
            d && e.Logger.debug(`${b}: ended virtual node`);
          }
          null != b.spc && b.spc.activate();
        } catch (M) {
          q.logAgentException(M);
        }
        f = v.safeInvoke(this, b.origCb, arguments);
        try {
          c.addSample(() => new n.FunctionId(b.origCb)), null != b.spc && b.spc.deactivate();
        } catch (M) {
          q.logAgentException(M);
        }
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute exit for ${b.origCb.name}, didThrow: ${f.didThrow}`);
        return f.rethrow();
      };
    }
    wrapReturnValue(b, a) {
      function d(a, d, e) {
        return function(a) {
          return B(this, b, d, a, e, arguments, c);
        };
      }
      a = a.retVal;
      const c = this.controlParams.isDebugEnabled;
      l.PromiseTransformerUtilities.isActuallyAPromise(a) && (c && e.Logger.debug(`${b}: register then wrapper and install dummy handlers`), l.PromiseTransformerUtilities.registerThenWrapper(a, d), b.returnsPromise = !0);
    }
  }
  a.MongoDbCursorInternalNextTransformer = O;
  class H extends d.AsyncTransformerBase {
    constructor(b, a, d, c) {
      super(b);
      this.dbType = a;
      this.clientType = d;
      this.version = c;
    }
    generateSubstitute(a) {
      const d = this;
      return function() {
        const c = d.controlParams.isDebugEnabled;
        let f;
        var l = arguments;
        if (d.controlParams.active) {
          try {
            c && e.Logger.debug(`${a.functionName} mongoDbConnectSubstitute enter`);
            const h = new C.MongoDbConfigurationData(this, d.version), w = new b.MongoDbAttachmentData(h, void 0, void 0);
            f = new J(w, d, a);
            l = f.manipulateArguments(arguments);
            const k = g.SubPathContext.getActiveContext();
            null != k && (f.spc = k);
          } catch (E) {
            q.logAgentException(E);
          }
        }
        l = v.safeInvoke(this, a.origFn, l);
        try {
          null != f && f.manipulateReturnValue(l), c && e.Logger.debug(`${a.functionName} mongoDbConnectSubstitute exit, didThrow: ${l.didThrow}`);
        } catch (E) {
          q.logAgentException(E);
        }
        return l.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        try {
          d && e.Logger.debug(`${b}: mongoDbConnectCbSubstitute enter for ${b.origCb.name}`);
          var c = 0 < arguments.length ? arguments[arguments.length - 1] : void 0;
          let f;
          if (A.isActuallyADb(c, a.dbType)) {
            f = new C.MongoDbConfigurationData(c, a.version);
          } else {
            if (A.isActuallyAClient(c, a.clientType) && p.hasProperty(c, "topology")) {
              f = new C.MongoDbConfigurationData(c.topology, a.version);
              const b = new L(a.controlParams), d = new m.FunctionSpec("db", "MongoClient", c);
              m.applyToSingle(d, b);
            }
          }
          null != f && A.HostInfoEmbedder.set(c, f);
          null != b.spc && b.spc.activate();
        } catch (M) {
          q.logAgentException(M);
        }
        c = v.safeInvoke(this, b.origCb, arguments);
        try {
          null != b.spc && b.spc.deactivate(), d && e.Logger.debug(`${b}: mongoDbConnectCbSubstitute exit for ${b.origCb.name}, didThrow: ${c.didThrow}`);
        } catch (M) {
          q.logAgentException(M);
        }
        return c.rethrow();
      };
    }
    wrapReturnValue(b, a) {
      function d(a, d, e) {
        return function(a) {
          return z(this, b, d, a, e, arguments, c);
        };
      }
      a = a.retVal;
      const c = this.controlParams.isDebugEnabled;
      l.PromiseTransformerUtilities.isActuallyAPromise(a) && (c && e.Logger.debug(`${b}: register then wrapper and install dummy handlers`), l.PromiseTransformerUtilities.registerThenWrapper(a, d), b.returnsPromise = !0);
    }
  }
  a.MongoDbConnectTransformer = H;
  class Q extends d.AsyncTransformerBase {
    constructor(b, a) {
      super(b);
      this.version = a;
    }
    generateSubstitute(a) {
      const d = this;
      return function() {
        const c = d.controlParams.isDebugEnabled;
        let f = arguments;
        if (d.controlParams.active) {
          try {
            c && e.Logger.debug(`${a.functionName} mongoDbOpenSubstitute enter`);
            const h = new C.MongoDbConfigurationData(this, d.version), w = new b.MongoDbAttachmentData(h);
            var l = new J(w, d, a);
            f = l.manipulateArguments(arguments);
            const k = g.SubPathContext.getActiveContext();
            null != k && (l.spc = k);
            A.HostInfoEmbedder.set(this, h);
          } catch (E) {
            q.logAgentException(E);
          }
        }
        l = v.safeInvoke(this, a.origFn, f);
        try {
          c && e.Logger.debug(`${a.functionName} mongoDbConnectSubstitute exit, didThrow: ${l.didThrow}`);
        } catch (E) {
          q.logAgentException(E);
        }
        return l.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        try {
          d && e.Logger.debug(`${b}: mongoDbOpenCbSubstitute enter for ${b.origCb.name}`), null != b.spc && b.spc.activate();
        } catch (M) {
          q.logAgentException(M);
        }
        const c = v.safeInvoke(this, b.origCb, arguments);
        try {
          null != b.spc && b.spc.deactivate(), d && e.Logger.debug(`${b}: mongoDbOpenCbSubstitute exit for ${b.origCb.name}, didThrow: ${c.didThrow}`);
        } catch (M) {
          q.logAgentException(M);
        }
        return c.rethrow();
      };
    }
    wrapReturnValue() {
    }
  }
  a.MongoDbOpenTransformer = Q;
  class L extends x.TransformerBase {
    generateSubstitute(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        let c;
        if (a.controlParams.active) {
          try {
            d && e.Logger.debug(`${b.functionName} mongoDbClientDbSubstitute enter`), c = A.HostInfoEmbedder.get(this);
          } catch (E) {
            q.logAgentException(E);
          }
        }
        const f = v.safeInvoke(this, b.origFn, arguments);
        try {
          null != c ? A.HostInfoEmbedder.set(f.retVal, c) : d && e.Logger.debug("No mongoconfigdata object found."), d && e.Logger.debug(`${b.functionName} mongoDbClientDbSubstitute exit, didThrow: ${f.didThrow}`);
        } catch (E) {
          q.logAgentException(E);
        }
        return f.rethrow();
      };
    }
  }
  a.MongoDbClientTransformer = L;
  class G extends d.AsyncTransformerBase {
    constructor(b, a, d, c) {
      super(b);
      this.isDbCollection = a;
      this.collectionType = d;
      this.mongoDbVersion = c;
    }
    generateSubstitute(a) {
      const d = this, f = new n.FunctionId(a);
      return function() {
        const g = d.controlParams.isDebugEnabled;
        g && e.Logger.debug(`${a.functionName} mongoDbCallSubstitute enter`);
        let l, h;
        var w = arguments;
        let k;
        if (d.controlParams.active) {
          try {
            if (d.shouldCreateNode(arguments)) {
              if (A.suppressActivationCreation) {
                A.suppressActivationCreation = !1, g && e.Logger.debug(`${a.functionName} suppressing activation creation`);
              } else {
                k = A.HostInfoEmbedder.get(this);
                null != k ? (g && e.Logger.debug(`${l}: ++++++++++++ mongoconfigdata object found`), k.updateDatabaseAttachmentInfo(this)) : (k = new C.MongoDbConfigurationData(this, d.mongoDbVersion), g && e.Logger.debug(`${l}: --------- no mongoconfigdata object found. Creating a new one`));
                const c = new b.MongoDbAttachmentData(k, a.functionName, arguments);
                l = new J(c, d, a, void 0, d.isDbCollection);
                h = d.tryStartAsyncActivation({functionId:f, category:e.Agent.correlation.MethodCategory.Database, attachmentCreator:l, vPathOption:1});
                null != h && (h.initiatorActivation.spc.didInitiateAsyncOp = !0, l.spc = h.initiatorActivation.spc, l.virtualNodeActivation = h.vNodeActivation, w = l.manipulateArguments(arguments), g && e.Logger.debug(`${l}: async activation created`));
              }
            } else {
              if (d.isDbCollection) {
                k = new C.MongoDbConfigurationData(this, d.mongoDbVersion);
                const c = new b.MongoDbAttachmentData(k, a.functionName, arguments);
                l = new J(c, d, a, void 0, d.isDbCollection);
                w = l.manipulateArguments(arguments);
              }
            }
          } catch (P) {
            q.logAgentException(P);
          }
        }
        w = v.safeInvoke(this, a.origFn, w);
        try {
          c.addSample(f);
          if (null != h) {
            w.didThrow || l.manipulateReturnValue(w);
            if (w.didThrow || l.hasCallback && l.returnsPromise) {
              h.vNodeActivation.exitOrException(w.exception), h.vNodeActivation.spc.end();
            }
            h.initiatorActivationDone(w.exception);
          }
          null != k && A.isActuallyACollection(w.retVal, d.collectionType) && A.HostInfoEmbedder.set(w.retVal, k);
        } catch (P) {
          q.logAgentException(P);
        }
        g && e.Logger.debug(`${a.functionName} mongoDbCallSubstitute exit, didThrow: ${w.didThrow}`);
        return w.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute enter for ${b.origCb.name}`);
        let f, g;
        try {
          if (null != b.virtualNodeActivation) {
            if (0 < arguments.length && p.isError(arguments[0])) {
              var l = arguments[0];
              (new r.ExceptionAttachment(b.virtualNodeActivation)).fillExceptionData(l);
            }
            b.virtualNodeActivation.isExited || (2 === arguments.length && null != arguments[1] && (Array.isArray(arguments[1]) ? b.rowCount = arguments[1].length : b.rowCount = 1), b.updateRowCount(), b.virtualNodeActivation.exit(), d && e.Logger.debug(`${b}: ended virtual node`));
          }
          if (null != b.virtualNodeActivation && !b.injectedCallback) {
            try {
              g = new n.FunctionId(b.origCb), f = x.TransformerBase.createCallbackActivation(b.virtualNodeActivation.spc, g), d && e.Logger.debug(`${b}: created cb activation: ${f}`);
            } catch (F) {
              q.logAgentException(F);
            }
          }
        } catch (F) {
          q.logAgentException(F);
        }
        A.suppressActivationCreation && (A.suppressActivationCreation = !1);
        null != b.mongoData.mongDbConfigData && 0 < arguments.length && A.isActuallyACollection(arguments[arguments.length - 1], a.collectionType) && A.HostInfoEmbedder.set(arguments[arguments.length - 1], b.mongoData.mongDbConfigData);
        l = v.safeInvoke(this, b.origCb, arguments);
        try {
          null != f && (c.addSample(g), f.done(l.exception)), null != b.virtualNodeActivation && (b.virtualNodeActivation.isExited || b.virtualNodeActivation.exit(), b.virtualNodeActivation.spc.end());
        } catch (F) {
          q.logAgentException(F);
        }
        d && e.Logger.debug(`${b}: mongoDbCbSubstitute exit for ${b.origCb.name}, didThrow: ${l.didThrow}`);
        return l.rethrow();
      };
    }
    wrapReturnValue(b, a) {
      function d(a, d, e) {
        return function(a) {
          return z(this, b, d, a, e, arguments, c);
        };
      }
      a = a.retVal;
      const c = this.controlParams.isDebugEnabled;
      l.PromiseTransformerUtilities.isActuallyAPromise(a) && (c && e.Logger.debug(`${b}: register then wrapper and install dummy handlers`), l.PromiseTransformerUtilities.registerThenWrapper(a, d), b.returnsPromise = !0);
    }
    shouldCreateNode(b) {
      return this.isDbCollection ? 1 <= b.length && b[1] && b[1].strict : !0;
    }
  }
  a.MongoDbTransformer = G;
  class J extends h.default {
    constructor(b, a, d, c, e) {
      super(a, d);
      this.mongoData = b;
      this.spc = c;
      this.createResultSetAttachment = e;
      this.rowCount = this.execCount = 0;
      this.onExitTicksSet = this.returnsPromise = this.exitVNode = this.suppressNext = this.isCursorInCallback = !1;
      this.id = D.UniqueId.getNext();
    }
    createAttachments(a) {
      if (null != this.mongoData) {
        this.sqlAttachment = new b.MongoDbQueryAttachment(a);
        this.sqlAttachment.valid && this.sqlAttachment.fillMongoDbQueryData(this.mongoData);
        const d = new b.MongoDbConnectionPoolAttachment(a);
        d.valid && d.fillMongoDbConnectionPoolData(this.mongoData);
        this.createResultSetAttachment && null == this.resultSetAttachment && (this.resultSetAttachment = new u.ResultSetAttachment(a));
      } else {
        f.fail("CreateAttachment called without MongoData!");
      }
    }
    setResultSetAttachmentData() {
      null != this.resultSetAttachment && this.resultSetAttachment.valid && null != this.virtualNodeActivation && e.Agent.correlation.setSqlResultSetData(this.virtualNodeActivation.spc.path, this.virtualNodeActivation.serialNo, this.execCount, 0, 0);
    }
    updateRowCount() {
      null != this.sqlAttachment && this.sqlAttachment.updateRowCount(this.rowCount);
    }
    toString() {
      this.logPrefix || (this.logPrefix = `MongoDb ${D.UniqueId.asString(this.id)}`);
      return this.logPrefix;
    }
  }
});
S("src/lib/sensors/MongoDbSensor", "require exports semver src/lib/Agent src/lib/Patch src/lib/sensors/SensorBase src/lib/transformer/MongoDbTransformer".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  let m, g, c;
  class r extends k.SensorBase {
    applyInstrumentation(b) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: inhibit ${b}`);
      b.matchRequest("mongodb") && (this.isDebugEnabled && h.Logger.debug(`${this.name}: patching mongodb`), c = b.moduleInfo.version, m = void 0, this.patchMongoDb(b, c), this.patchMongoDbConnect(b.moduleExports, c), this.patchDbCollection(b.moduleExports, b.request, c), this.patchDbOpen(b.moduleExports, b.request, c), this.patchCursorMethods(b.moduleExports, b.request, c), this.patchCursorNextMethods(b.moduleExports, b.request, c), this.patchCursorInternalNext(b.moduleExports, b.request, c), this.patchCollectionFind(b.moduleExports, 
      b.request, c), this.patchCollectionAggregate(b.moduleExports, b.request, g, c), this.patchListCollections(b.moduleExports, b.request, m, c), m = void 0);
      if (b.matchRequestPattern("command_cursor")) {
        var a = new n.MongoDbCursorTransformer(this, c), f = new n.MongoDbCursorNextTransformer(this, c);
        c ? (e.satisfies(c, "1.4") ? m = b.moduleExports.CommandCursor : e.satisfies(c, ">=2.0.0") && (m = b.moduleExports), this.patchCommandCursorEach(m, b.request, a), this.patchCommandCursorToArray(m, b.request, a), this.patchCommandCursorNext(m, b.request, f), this.patchCommandCursorInternalNext(m, b.request, c)) : h.Logger.warning("CommandCursor type not found - some methods will not be fully supported (e.g. Db.listCollection)!");
      }
      b.matchRequestPattern("aggregation_cursor") && (a = new n.MongoDbCursorTransformer(this, c), f = new n.MongoDbCursorNextTransformer(this, c), c ? (e.satisfies(c, "1.4") ? g = b.moduleExports.AggregationCursor : e.satisfies(c, ">=2.0.0") && (g = b.moduleExports), this.patchAggregationCursorEach(g, b.request, a), this.patchAggregationCursorToArray(g, b.request, a), this.patchAggregationCursorNext(g, b.request, f), this.patchAggregationCursorInternalNext(g, b.request, c)) : h.Logger.warning("CommandCursor type not found - some methods will not be fully supported (e.g. Db.listCollection)!"));
    }
    patchMongoDb(b, a) {
      a = new n.MongoDbTransformer(this, !1, b.moduleExports.Collection, a);
      this.applyPatch(b, a);
    }
    patchMongoDbConnect(b, a) {
      a = new n.MongoDbConnectTransformer(this, b.Db, b.MongoClient, a);
      let d = new f.FunctionSpec("connect", "", b, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(d, a);
      d = new f.FunctionSpec("connect", "MongoClient", b.MongoClient, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(d, a);
    }
    patchDbOpen(b, a, c) {
      a = new n.MongoDbOpenTransformer(this, c);
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching Db.open`);
      b = new f.FunctionSpec("open", "Db", b.Db.prototype, f.AsyncTrackingMode.CallbackLast, "mongodb");
      f.applyToSingle(b, a);
    }
    patchDbCollection(b, a, c) {
      a = new n.MongoDbTransformer(this, !0, b.Collection, c);
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching Db.collection`);
      b = new f.FunctionSpec("collection", "Db", b.Db.prototype, f.AsyncTrackingMode.CallbackLast, "mongodb");
      f.applyToSingle(b, a);
    }
    patchCursorMethods(b, a, c) {
      c = new n.MongoDbCursorTransformer(this, c);
      this.patchCursorToArray(b, a, c);
      this.patchCursorCount(b, a, c);
      this.patchCursorEach(b, a, c);
    }
    patchCursorNextMethods(b, a, c) {
      c = new n.MongoDbCursorNextTransformer(this, c);
      this.patchCursorHasNext(b, a, c);
      this.patchCursorNext(b, a, c);
      this.patchCursorNextObject(b, a, c);
    }
    patchCursorInternalNext(b, a, c) {
      a = new n.MongoDbCursorInternalNextTransformer(this, c);
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching cursor._next`);
      b = new f.FunctionSpec("_next", "Cursor", b.Cursor.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, a);
    }
    patchCursorToArray(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching cursor.ToArray`);
      b = new f.FunctionSpec("toArray", "Cursor", b.Cursor.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchCursorHasNext(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching cursor.HasNext`);
      b = new f.FunctionSpec("hasNext", "Cursor", b.Cursor.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchCursorNext(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching cursor.Next`);
      b = new f.FunctionSpec("next", "Cursor", b.Cursor.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchCursorNextObject(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching cursor.NextObject`);
      b = new f.FunctionSpec("nextObject", "Cursor", b.Cursor.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchCursorCount(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching cursor.Count`);
      b = new f.FunctionSpec("count", "Cursor", b.Cursor.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchCursorEach(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching cursor.Each`);
      b = new f.FunctionSpec("each", "Cursor", b.Cursor.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchCommandCursorEach(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching commandCursor.Each`);
      b = new f.FunctionSpec("each", "CommandCursor", b.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchCommandCursorNext(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching commandCursor.Next`);
      b = new f.FunctionSpec("next", "CommandCursor", b.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchCommandCursorToArray(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching commandCursor.ToArray`);
      b = new f.FunctionSpec("toArray", "CommandCursor", b.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchCommandCursorInternalNext(b, a, c) {
      a = new n.MongoDbCursorInternalNextTransformer(this, c);
      this.isDebugEnabled && h.Logger.debug(`${this.name}: commandCursor._next`);
      b = new f.FunctionSpec("_next", "CommandCursor", b.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, a);
    }
    patchAggregationCursorEach(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching aggreagationCursor.Each`);
      b = new f.FunctionSpec("each", "AggreagationCursor", b.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchAggregationCursorNext(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching aggreagationCursor.Next`);
      b = new f.FunctionSpec("next", "AggreagationCursor", b.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchAggregationCursorToArray(b, a, c) {
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching aggreagationCursor.ToArray`);
      b = new f.FunctionSpec("toArray", "AggreagationCursor", b.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, c);
    }
    patchAggregationCursorInternalNext(b, a, c) {
      a = new n.MongoDbCursorInternalNextTransformer(this, c);
      this.isDebugEnabled && h.Logger.debug(`${this.name}: aggreagationCursor cursor._next`);
      b = new f.FunctionSpec("_next", "AggreagationCursor", b.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, a);
    }
    patchCollectionFind(b, a, c) {
      a = new n.MongoDbReturnsCursorTransformer(this, b.Cursor, c);
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching collection.Find`);
      b = new f.FunctionSpec("find", "Collection", b.Collection.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, a);
    }
    patchCollectionAggregate(b, a, c, e) {
      a = new n.MongoDbReturnsCursorTransformer(this, c, e);
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching collection.aggregate`);
      b = new f.FunctionSpec("aggregate", "Collection", b.Collection.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, a);
    }
    patchListCollections(b, a, c, e) {
      a = new n.MongoDbReturnsCursorTransformer(this, c, e);
      this.isDebugEnabled && h.Logger.debug(`${this.name}: patching Db.listCollections`);
      b = new f.FunctionSpec("listCollections", "Db", b.Db.prototype, f.AsyncTrackingMode.CallbackLastOrPromise, "mongodb");
      f.applyToSingle(b, a);
    }
  }
  a.MongoDbSensor = r;
});
S("src/lib/transformer/RedisTracker", "require exports events src/lib/CallbackWrappingHelper src/lib/Embedder src/lib/Logger src/lib/util/CoreUtil src/lib/util/UniqueId".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class g {
    constructor(b, a, c) {
      this.transformer = b;
      this.descriptor = a;
      this.redisClient = c;
      this.errorExtractor = h.errorFromFirstArg;
      this.injectedCallback = !1;
      this.isDebugEnabled = b.controlParams.isDebugEnabled;
      this.id = m.UniqueId.getNext();
    }
    toString() {
      this.logPrefix || (this.logPrefix = `Redis ${m.UniqueId.asString(this.id)}`);
      return this.logPrefix;
    }
    getWrappedCallback(b) {
      null != b ? this.origCb = b : (this.injectedCallback = !0, this.origCb = this.transformer.emitErrors ? this.getEmittingRedisCb() : this.getThrowingRedisCb());
      b = this.transformer.wrapCallback(this);
      g.embedder.set(b, !0);
      return b;
    }
    cbIsWrapped(b) {
      return null != b ? !!g.embedder.get(b) : !1;
    }
    getEmittingRedisCb() {
      const b = this;
      return function(a) {
        a && (b.redisClient instanceof e.EventEmitter ? (b.isDebugEnabled && k.debug(`${b}: reemit error event: ${a}`), b.redisClient.emit("error", a)) : b.isDebugEnabled && k.debug(`${b}: can't reemit error event: ${a}, ${typeof b.redisClient}`));
      };
    }
    getThrowingRedisCb() {
      const b = this;
      return function(a) {
        a && (b.isDebugEnabled && k.debug(`${b}: re-throw error event: ${a}`), process.nextTick(() => {
          throw a;
        }));
      };
    }
  }
  a.RedisTrackerBase = g;
  g.embedder = f.create("redisTracker");
  class c extends g {
    manipulateArguments(b) {
      if (0 < b.length) {
        const a = b[0];
        null != a && (this.isDebugEnabled && k.debug(`${this}: ${n.isFunction(a.callback) ? "wrap" : "inject"} callback`), a.callback = this.getWrappedCallback(a.callback));
      }
      return b;
    }
    shallProcess(b) {
      if (0 < b.length) {
        const a = b[0];
        if (null != a) {
          return !this.cbIsWrapped(a.callback);
        }
      }
      this.isDebugEnabled && k.debug(`${this}: Since26: unknown args: length=${b.length}, typeof(args[0]=${1 <= b.length ? typeof b[0] : ""})`);
      return !1;
    }
  }
  a.RedisTrackerSince26 = c;
  class r extends g {
    manipulateArguments(b) {
      if (3 <= b.length) {
        if (void 0 === b[2] || n.isFunction(b[2])) {
          this.isDebugEnabled && k.debug(`${this}: ${n.isFunction(b[2]) ? "wrap" : "inject"} at third argument`), b[2] = this.getWrappedCallback(b[2]);
        }
        return b;
      }
      if (2 === b.length && Array.isArray(b[1])) {
        const a = b[1];
        n.isFunction(a[a.length - 1]) ? (a[a.length - 1] = this.getWrappedCallback(a[a.length - 1]), this.isDebugEnabled && k.debug(`${this}: wrapped last element in args[1]`)) : (this.isDebugEnabled && k.debug(`${this}: inject a third argument.`), b.push(this.getWrappedCallback()));
      }
      return b;
    }
    shallProcess(b) {
      let a;
      if (3 <= b.length && (void 0 === b[2] || n.isFunction(b[2]))) {
        a = b[2];
      } else {
        if (2 === b.length && Array.isArray(b[1])) {
          b = b[1], n.isFunction(b[b.length - 1]) && (a = b[b.length - 1]);
        } else {
          return this.isDebugEnabled && k.debug(`${this}: Pre26: unknown args: length=${b.length}, typeof(args[2]=${2 <= b.length ? typeof b[2] : ""})`), !1;
        }
      }
      return !this.cbIsWrapped(a);
    }
  }
  a.RedisTrackerPre26 = r;
});
S("src/lib/transformer/RedisTransformer", "require exports events src/lib/Agent src/lib/AttachmentBase src/lib/CallbackWrappingHelper src/lib/FunctionId src/lib/SubPathContext src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/modules/AutoSensorModule src/lib/transformer/RedisTracker src/lib/transformer/TransformerBase".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d, l) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class x {
    constructor(b, a) {
      this.tracker = b;
      this.args = a;
    }
    createAttachments(b) {
      try {
        const a = new f.AttachmentBase(b, h.Agent.correlation.AttachmentId.ATTACHMENT_EXTERNAL_CALL_ID, 0);
        null != a ? a.setMultipleFields(b => {
          const a = this.tracker.redisClient.connection_options || this.tracker.redisClient.connectionOption, c = h.Agent.correlation.AttachmentFieldId;
          null != a ? (g.isString(a.host) && b.stringCached(c.EXTERNALCALL_HOSTNAME_ID, a.host), null != a.port && b.integer(c.EXTERNALCALL_PORTNO_ID, +a.port)) : (g.isString(this.tracker.redisClient.host) && b.stringCached(c.EXTERNALCALL_HOSTNAME_ID, this.tracker.redisClient.host), null != this.tracker.redisClient.port && b.integer(c.EXTERNALCALL_PORTNO_ID, +this.tracker.redisClient.port));
          b.stringCached(c.EXTERNALCALL_OPERATION_NAME_ID, this.getCommandName());
          b.integer(c.EXTERNALCALL_CALL_TYPE_ID, h.Agent.correlation.ExternalCallType.REDIS);
        }) : this.tracker.isDebugEnabled && h.Logger.debug(`${this.tracker}: failed to create attachment`);
      } catch (v) {
        c.logAgentException(v);
      }
    }
    getCommandName() {
      if (this.tracker.transformer.useCommandObject && 0 < this.args.length && null != this.args[0]) {
        var b = this.args[0].command;
        if (g.isString(b)) {
          return this.tracker.isDebugEnabled && h.Logger.debug(`${this.tracker}: found command in CmdObj: ${b}`), b;
        }
      }
      if (1 < this.args.length && Array.isArray(this.args[1]) && (b = this.args[0], g.isString(b))) {
        return this.tracker.isDebugEnabled && h.Logger.debug(`${this.tracker}: found command in arg[0]: ${b}`), b;
      }
      this.tracker.isDebugEnabled && h.Logger.debug(`${this.tracker}: fallback to command from descriptor: ${this.tracker.descriptor.functionName}`);
      return this.tracker.descriptor.functionName;
    }
  }
  class p extends l.TransformerBase {
    constructor(b, a, c) {
      super(b);
      this.useCommandObject = a;
      this.emitErrors = c;
    }
    generateSubstitute(a) {
      const f = this, g = new n.FunctionId(a);
      return function(...l) {
        const k = f.controlParams.isDebugEnabled;
        if (k) {
          const b = l.length;
          h.Logger.debug(`Redis command(), argCnt: ${b}, cmd: ${1 <= b ? arguments[0] : "<missing>"}, isEmitter: ${this instanceof e.EventEmitter}`);
        }
        if (!f.controlParams.active) {
          return k && h.Logger.debug("Redis command() exit - inactive"), r.doInvoke(this, a.origFn, arguments);
        }
        let p, q;
        try {
          if (q = f.useCommandObject ? new d.RedisTrackerSince26(f, a, this) : new d.RedisTrackerPre26(f, a, this), q.shallProcess(l)) {
            const b = new x(q, l);
            p = f.tryStartAsyncActivation({functionId:g, attachmentCreator:b});
            null != p ? (q.virtualNodeActivation = p.vNodeActivation, l = q.manipulateArguments(l), k && h.Logger.debug(`${q}: command() virt: ${p.vNodeActivation.spc}, init: ${p.initiatorActivation.spc}`)) : k && h.Logger.debug(`${q}: no activation, active spc: ${m.SubPathContext.getActiveContext()}`);
          } else {
            k && h.Logger.debug(`${q}: Skip request as shall Process returned false`);
          }
        } catch (A) {
          c.logAgentException(A);
        }
        l = r.safeInvoke(this, a.origFn, l);
        try {
          null != p && (b.addSample(g), p.initiatorActivationDone(l.exception));
        } catch (A) {
          c.logAgentException(A);
        }
        k && q && h.Logger.debug(`${q}: command() exit, didThrow: ${l.didThrow}`);
        return l.rethrow();
      };
    }
    wrapCallback(b) {
      return k.CallbackWrappingHelper.wrapCallbackCreateActivation(b);
    }
  }
  a.RedisTransformer = p;
});
S("src/lib/sensors/RedisSensor", "require exports semver src/lib/Patch src/lib/sensors/SensorBase src/lib/transformer/RedisTransformer src/lib/ModuleRegistry src/lib/Debug src/lib/Logger src/lib/util/CoreUtil src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c, r) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class b extends f.SensorBase {
    applyInstrumentation(b) {
      const a = n.ModuleRegistry.lookup(b);
      let d;
      if (c.isFunction(b.moduleExports.RedisClient.prototype.internal_send_command)) {
        var f = !0;
        d = "internal_send_command";
      } else {
        f = !1, d = "send_command";
      }
      const q = e.gte(a.version, "2.0.0");
      f = new k.RedisTransformer(this, f, q);
      b = new h.FunctionSpec(d, "RedisClient", b.moduleExports.RedisClient.prototype);
      null == h.applyToSingle(b, f) && (g.warning(`Failed to patch Redis version: ${a.version}`), r.reportInstrumentationError(this, `failed to patch redis version: ${a.version}`), m.fail());
    }
  }
  a.RedisSensor = b;
});
S("src/lib/transformer/MemcachedTracker", ["require", "exports", "src/lib/util/ErrorUtil", "src/lib/CallbackWrappingHelper"], function(t, a, e, h) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class f {
    constructor(a) {
      this.transformer = a;
      this.injectedCallback = !1;
      this.errorExtractor = h.errorFromFirstArg;
    }
    manipulateArguments(a) {
      if (0 < a.length) {
        try {
          const e = a[0]();
          null != e.callback ? this.origCb = e.callback : (this.injectedCallback = !0, this.origCb = f.emptyCallback);
          e.callback = this.transformer.wrapCallback(this);
          a[0] = function() {
            return e;
          };
        } catch (n) {
          e.logAgentException(n);
        }
      }
      return a;
    }
    static emptyCallback() {
    }
  }
  a.MemcachedTracker = f;
});
S("src/lib/transformer/MemcachedTransformer", "require exports src/lib/Agent src/lib/AttachmentBase src/lib/CallbackWrappingHelper src/lib/Embedder src/lib/FunctionId src/lib/modules/AutoSensorModule src/lib/util/CoreUtil src/lib/util/InvocationUtil src/lib/util/ErrorUtil src/lib/transformer/MemcachedTracker src/lib/transformer/TransformerBase".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d) {
  Object.defineProperty(a, "__esModule", {value:!0});
  const l = k.create("memcachedAttachment");
  class x {
    constructor(b, a) {
      this.originalDescriptor = b;
      this.args = a;
    }
    createAttachments(b) {
      var a = e.Agent.correlation;
      this.externalCallAttachment = new h.AttachmentBase(b, a.AttachmentId.ATTACHMENT_EXTERNAL_CALL_ID, 0);
      b = a.AttachmentFieldId;
      a = this.getCommandName();
      this.externalCallAttachment.setStringCached(b.EXTERNALCALL_OPERATION_NAME_ID, a);
      this.externalCallAttachment.attachment.setFieldInteger(b.EXTERNALCALL_CALL_TYPE_ID, e.Agent.correlation.ExternalCallType.MEMCACHED);
    }
    setServerInfo(b) {
      if (null != this.externalCallAttachment && g.isString(b) && 0 < b.length) {
        var a = b.split(":");
        b = a[0];
        let c = 11211;
        1 < a.length && (c = +a[1]);
        a = e.Agent.correlation.AttachmentFieldId;
        this.externalCallAttachment.setStringCached(a.EXTERNALCALL_HOSTNAME_ID, b);
        this.externalCallAttachment.attachment.setFieldInteger(a.EXTERNALCALL_PORTNO_ID, c);
      }
    }
    getCommandName() {
      if (0 < this.args.length) {
        const b = this.args[0];
        if (null != b.name) {
          return b.name;
        }
      }
      return this.originalDescriptor.functionName;
    }
  }
  a.MemcachedAttachmentCreator = x;
  class p extends d.TransformerBase {
    generateSubstitute(a) {
      const d = this, e = new n.FunctionId(a);
      return function() {
        var f = arguments;
        let g;
        try {
          const c = new b.MemcachedTracker(d), h = new x(a, f);
          g = d.tryStartAsyncActivation({functionId:e, attachmentCreator:h});
          null != g && (c.virtualNodeActivation = g.vNodeActivation, l.set(this, h), c.manipulateArguments(f));
        } catch (B) {
          r.logAgentException(B);
        }
        f = c.safeInvoke(this, a.origFn, f);
        try {
          m.addSample(e), null != g && g.initiatorActivationDone(f.exception);
        } catch (B) {
          r.logAgentException(B);
        }
        return f.rethrow();
      };
    }
    wrapCallback(b) {
      return f.CallbackWrappingHelper.wrapCallbackCreateActivation(b);
    }
  }
  a.MemcachedCommandTransformer = p;
  class q {
    generateSubstitute(b) {
      return function() {
        const a = l.get(this);
        null != a && 0 < arguments.length && (a.setServerInfo(arguments[0]), l.clear(this));
        return c.doInvoke(this, b.origFn, arguments);
      };
    }
  }
  a.MemcachedConnectTransformer = q;
});
S("src/lib/sensors/MemcachedSensor", ["require", "exports", "src/lib/Patch", "src/lib/sensors/SensorBase", "src/lib/transformer/MemcachedTransformer"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k extends h.SensorBase {
    applyInstrumentation(a) {
      e.applyToSingle(new e.FunctionSpec("command", "Client", a.moduleExports.prototype), new f.MemcachedCommandTransformer(this));
      e.applyToSingle(new e.FunctionSpec("connect", "Client", a.moduleExports.prototype), new f.MemcachedConnectTransformer);
    }
  }
  a.MemcachedSensor = k;
});
S("src/lib/sensors/ExpressSensor", "require exports src/lib/Logger src/lib/Patch src/lib/sensors/SensorBase src/lib/sensors/WebRequestSensor src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n) {
  function m(a) {
    return function p(b, c, f, g) {
      try {
        k.WebRequestSensorApi.isMonitored(f) && a.active && (a.isDebugEnabled && e.debug(`${a.name}: capture error ${n.verboseExceptionObject(b)}`), b instanceof Error && k.WebRequestSensorApi.attachError(f, b));
      } catch (q) {
        e.warning(`ExpressSensor: failed with ${n.verboseExceptionObject(q)}`);
      }
      h.PatchedFnDescriptor.getOrigFn(p).call(this, b, c, f, g);
    };
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class g extends f.SensorBase {
    applyInstrumentation(a) {
      a.matchRequestPattern("layer") && h.substitute(new h.FunctionSpec("handle_error", "Layer", a.moduleExports.prototype), m(this));
    }
  }
  a.ExpressSensor = g;
});
S("src/lib/sensors/FinalHandlerSensor", "require exports src/lib/ErrorObject src/lib/Logger src/lib/Patch src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/sensors/SensorBase src/lib/sensors/WebRequestSensor".split(" "), function(t, a, e, h, f, k, n, m, g) {
  function c(b, a, c) {
    return function q(d) {
      try {
        if (null != d && g.WebRequestSensorApi.isMonitored(a)) {
          c.isDebugEnabled && h.debug(`${c.name}: capture error ${n.verboseExceptionObject(d)}`);
          const b = d instanceof Error ? d : e.createExceptionObject(d, q);
          g.WebRequestSensorApi.attachError(a, b);
        }
      } catch (v) {
        h.warning(`${c.name}: failed with ${n.verboseExceptionObject(v)}`);
      }
      b(d);
    };
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class r extends m.SensorBase {
    applyInstrumentation(b) {
      var a = b.moduleExports;
      if (k.isFunction(a) && 3 === a.length) {
        b.moduleExports = this.makeFinalHandlerSubstituteClosure(a);
        const c = new f.SubstitutedFnDescriptor(new f.FunctionSpec("finalHandler", "finalhandler", void 0), a, !1);
        f.tag(c, b.moduleExports, a);
      } else {
        b = k.isFunction(a), a = a.length, h.warning(`${this.name}: instrumentation failed as exports did not match expected: ${b} ${a}`), n.reportInstrumentationError(this, `failed as exports did not match expected: ${b} ${a}`);
      }
    }
    makeFinalHandlerSubstituteClosure(b) {
      const a = this;
      return function(d, e, f) {
        d = b.call(this, d, e, f);
        return g.WebRequestSensorApi.isMonitored(e) && a.active ? c(d, e, a) : d;
      };
    }
  }
  a.FinalHandlerSensor = r;
});
S("src/lib/sensors/RestifySensor", "require exports http src/lib/Logger src/lib/Patch src/lib/sensors/SensorBase src/lib/sensors/WebRequestSensor src/lib/util/CoreUtil src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class c extends k.SensorBase {
    applyInstrumentation(a) {
      a.matchRequestPattern("response") && (a.load(), a = new f.FunctionSpec("send", "ServerResponse", e.ServerResponse.prototype), f.substitute(a, this.makeResponseSendSubstituteClosure()));
    }
    makeResponseSendSubstituteClosure() {
      const a = this;
      return function d() {
        if (n.WebRequestSensorApi.isMonitored(this) && 0 < arguments.length) {
          try {
            let c;
            m.isError(arguments[0]) ? c = arguments[0] : 1 < arguments.length && m.isError(arguments[1]) && (c = arguments[1]);
            null != c && (a.isDebugEnabled && h.debug(`${a.name}: capture error ${g.verboseExceptionObject(c)}`), n.WebRequestSensorApi.attachError(this, c));
          } catch (l) {
            h.debug(`RestifySensor: failed with ${g.verboseExceptionObject(l)}`);
          }
        }
        return f.invokeOriginal(d, this, arguments);
      };
    }
  }
  a.RestifySensor = c;
});
S("src/lib/transformer/PromiseTransformer", "require exports src/lib/Agent src/lib/util/CoreUtil src/lib/util/InvocationUtil src/lib/SubPathContext src/lib/Patch src/lib/transformer/PromiseTransformerUtilities".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class g {
    constructor(a = !1, b = !1, c) {
      this.instrumentInstanceInsteadOfPrototype = a;
      this.wrapCatch = b;
      this.sensor = c;
    }
    instrument(a) {
      function b() {
        const a = f.doInvoke(this, n.PatchedFnDescriptor.getOrigFn(b), arguments), c = new n.FunctionSpec("then", "Promise", a);
        n.substitute(c, d, n.cPolymorphicDefaultOptions);
        return a;
      }
      function d() {
        function b(b, a, d) {
          return function(b) {
            const a = r(c.spc), g = p.sensor.isDebugEnabled && null != a.spc;
            g && e.Logger.debug(`PromiseTransformer.defaultThenWrapper: activating context ${a.spc}`);
            a.activate();
            const h = f.safeInvoke(this, d, arguments);
            g && e.Logger.debug(`PromiseTransformer.defaultThenWrapper: deactivating context ${a.spc}`);
            a.deactivate();
            return h.rethrow();
          };
        }
        const a = m.PromiseEmbedder.createOrGet(this, () => new m.EmbeddedPromiseContext), c = r();
        c.didInitiateAsyncOp = !0;
        p.sensor.isDebugEnabled && null != c.spc && e.Logger.debug(`PromiseTransformer.wrappedThen: picked up context ${c.spc}`);
        var g;
        let l;
        1 <= arguments.length && h.isFunction(arguments[0]) && (g = arguments[0]);
        2 <= arguments.length && h.isFunction(arguments[1]) && (l = arguments[1]);
        const k = h.isFunction(a.customThenWrapper) ? a.customThenWrapper : b;
        h.isFunction(g) && (arguments[0] = k(a, !1, g));
        h.isFunction(l) && (arguments[1] = k(a, !0, l));
        g = f.doInvoke(this, n.PatchedFnDescriptor.getOrigFn(d), arguments);
        m.PromiseEmbedder.set(g, a);
        p.instrumentInstanceInsteadOfPrototype && (g.then = d);
        return g;
      }
      function g(b) {
        return this.then(void 0, b);
      }
      function r(b) {
        if (p.sensor.active) {
          let a = k.SubPathContext.getActiveContext();
          null == a && (a = b);
          return new c(a);
        }
        return new c(void 0);
      }
      const p = this;
      if (function() {
        return null == a ? (e.Logger.warning("Unable to instrument this particular promise implementation, because we don't have any exports at all."), !1) : null == a.Promise && null == a.promise ? (e.Logger.warning("Unable to instrument this particular promise implementation, because we don't have '.Promise'."), !1) : p.instrumentInstanceInsteadOfPrototype || m.PromiseTransformerUtilities.isActuallyAPromise(a.Promise.prototype) ? !0 : (e.Logger.warning("Unable to instrument this particular promise implementation, because we don't have '.Promise.prototype.then'."), 
        !1);
      }()) {
        if (this.instrumentInstanceInsteadOfPrototype) {
          var q = new n.FunctionSpec("", "Promise", a), v = h.isFunction(a.Promise);
          const c = h.isFunction(a.promise);
          v || c ? (v && !n.isApplied(a.Promise) && (v = a.Promise === a.promise, q.functionName = "Promise", n.substitute(q, b), Object.assign(a.Promise, n.PatchedFnDescriptor.getOrigFn(a.Promise)), v && (a.promise = a.Promise)), c && !n.isApplied(a.promise) && (q.functionName = "promise", n.substitute(q, b))) : e.Logger.warning("Unable to instrument this promise instance, because we can't find the constructor.");
        } else {
          h.isFunction(a.Promise) ? (n.isApplied(a.Promise.prototype.then) || (q = new n.FunctionSpec("then", "Promise", a.Promise.prototype), n.substitute(q, d)), p.wrapCatch && !n.isApplied(a.Promise.prototype.catch) && (q = new n.FunctionSpec("catch", "Promise", a.Promise.prototype), n.substitute(q, g))) : e.Logger.warning("Unable to instrument this promise instance, because we can't find the constructor.");
        }
      }
    }
  }
  a.PromiseTransformer = g;
  class c {
    constructor(a) {
      this.spc = a;
    }
    activate() {
      null != this.spc && this.spc.activate();
    }
    deactivate() {
      null != this.spc && this.spc.deactivate();
    }
    set didInitiateAsyncOp(a) {
      null != this.spc && (this.spc.didInitiateAsyncOp = a);
    }
  }
});
S("src/lib/sensors/PromiseSensor", ["require", "exports", "src/lib/sensors/SensorBase", "src/lib/transformer/PromiseTransformer", "src/lib/Agent"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k extends e.SensorBase {
    applyInstrumentation(a) {
      this.isDebugEnabled && f.Logger.debug(`${this.name}: instrumenting module ${a.toString(!0)}`);
      if (null != a.moduleExports) {
        var e = a.matchRequest("mpromise"), g = a.matchRequest("q");
        e = new h.PromiseTransformer(g, e, this);
        null != a.moduleExports.Promise || null != a.moduleExports.promise ? e.instrument(a.moduleExports) : (g = {Promise:a.moduleExports}, e.instrument(g), a.moduleExports = g.Promise);
      }
    }
  }
  a.PromiseSensor = k;
});
S("src/lib/sensors/TimerSensor", "require exports src/lib/sensors/SensorBase src/lib/Patch src/lib/RunTimeProperty src/lib/transformer/ContextPassingTransformer src/lib/util/CoreUtil".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class m extends e.SensorBase {
    constructor(a, c, e, b) {
      super(a, c, e, b);
      this.monitoredFn = ["setImmediate"];
      (new f.BooleanOption("TrackSetInterval", !1)).value && this.monitoredFn.push("setInterval");
    }
    applyInstrumentation(a) {
      if ("timers" === a.request) {
        var c = a.moduleExports, e = [], b = [];
        this.monitoredFn.forEach(a => {
          c[a] === global[a] ? b.push(a) : e.push(a);
        });
        var d = new k.ContextPassingTransformer(this);
        a = new h.ModuleSpec("timers", c, h.AsyncTrackingMode.CallbackFirst);
        h.applyToAll(a, this.monitoredFn, d);
        if (0 < e.length) {
          const b = new h.ModuleSpec("global", global, h.AsyncTrackingMode.CallbackFirst);
          h.applyToAll(b, e, d);
        }
        d = new k.ContextPassingTransformer(this, m.setTimeoutCondition);
        a = new h.FunctionSpec("setTimeout", a);
        h.applyToSingle(a, d);
        c.setTimeout === global.setTimeout ? b.push("setTimeout") : (a = new h.FunctionSpec("setTimeout", "global", global, h.AsyncTrackingMode.CallbackFirst), h.applyToSingle(a, d));
        b.forEach(b => {
          global[b] = c[b];
        });
      }
    }
    static setTimeoutCondition(a, c) {
      return n.isNumber(c) && c < m.timeoutOption.value;
    }
  }
  a.TimerSensor = m;
  m.timeoutOption = new f.NumberOption("TrackTimeoutValueMs", 1);
});
S("src/lib/sensors/CryptoSensor", "require exports src/lib/Patch src/lib/sensors/SensorBase src/lib/transformer/ContextPassingTransformer src/lib/util/CoreUtil".split(" "), function(t, a, e, h, f, k) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class n extends h.SensorBase {
    applyInstrumentation(a) {
      if ("crypto" === a.request) {
        var e = a.moduleExports, c = new f.ContextPassingTransformer(this), h = e.randomBytes !== e.pseudoRandomBytes, b = e.rng === e.randomBytes, d = e.prng === e.pseudoRandomBytes;
        this.applyPatch(a, c);
        h ? this.patchPseudoRandomBytes(e, c, "pseudoRandomBytes") : e.pseudoRandomBytes = e.randomBytes;
        b ? e.rng = e.randomBytes : k.isFunction(e.rng) && this.patchPseudoRandomBytes(e, c, "rng");
        d ? e.prng = e.pseudoRandomBytes : k.isFunction(e.prng) && this.patchPseudoRandomBytes(e, c, "prng");
      }
    }
    patchPseudoRandomBytes(a, f, c) {
      a = new e.FunctionSpec(c, "crypto", a, e.AsyncTrackingMode.CallbackLast);
      e.applyToSingle(a, f);
    }
  }
  a.CryptoSensor = n;
});
S("src/lib/sensors/MySqlAttachment", "require exports src/lib/Agent src/lib/AttachmentBase src/lib/sensors/SensorConstants src/lib/util/CoreUtil".split(" "), function(t, a, e, h, f, k) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.DATABASE_TYPE = "MySQL";
  a.DEFAULT_POOL_NAME = "default-pool";
  class n extends h.AttachmentBase {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_SQL_ID, 0);
    }
    fillMySqlQueryData(a) {
      this.setString(e.Agent.correlation.AttachmentFieldId.SQL_STATEMENT, a.queryString, e.Configuration.maxSqlStringLen);
    }
    setNumberOfRowsReturned(a) {
      this.attachment.setFieldInteger(e.Agent.correlation.AttachmentFieldId.SQL_NUM_ROWS_RETURNED, a);
    }
  }
  a.MySqlQueryAttachment = n;
  class m extends h.AttachmentBase {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_CONNECTION_POOL_ID, 0);
    }
    fillMySqlConnectionPoolData(c) {
      this.setMultipleFields(f => {
        const b = e.Agent.correlation, d = b.AttachmentFieldId;
        f.stringCached(d.CONNECTION_POOL_DB, c.dbName);
        f.stringCached(d.CONNECTION_POOL_URL, c.dbUrl);
        f.stringCached(d.CONNECTION_POOL_DBTYPE, a.DATABASE_TYPE);
        f.stringCached(d.CONNECTION_POOL_NAME, a.DEFAULT_POOL_NAME);
        f.stringCached(d.CONNECTION_POOL_DBHOST, c.dbHost);
        f.integer(d.CONNECTION_POOL_DBPORTNO, c.dbPort);
        f.integer(d.CONNECTION_POOL_TYPE, c.dbPoolType);
        f.integer(d.CONNECTION_POOL_AGGREGATION_MECHANISM, b.DbAggregationMechanism.DB_AGGREGATION_MECHANISM_UNDEFINED);
        f.integer(d.CONNECTION_POOL_SIZE, c.dbPoolSize);
      });
    }
  }
  a.MySqlConnectionPoolAttachment = m;
  class g {
    constructor(a, f, b = !1) {
      this.theDbHost = this.theDbUrl = this.theDbName = "";
      this.theDbPoolType = this.theDbPoolSize = this.theDbPort = -1;
      this.theQueryString = f;
      null != a ? (a = a.config, null != a && (this.theDbName = this.tryFindDbName(a), this.theDbHost = this.tryFindDbHost(a), this.theDbPort = this.tryFindDbPort(a), this.theDbPoolType = this.tryFindPoolType(a), this.theDbPoolSize = this.tryFindPoolSize(a), this.theDbUrl = this.buildDbUrl())) : b && e.Logger.warning("Trying to instantiate a MySqlData object w/o a connection");
    }
    get queryString() {
      return this.theQueryString;
    }
    get dbName() {
      return this.theDbName;
    }
    get dbUrl() {
      return this.theDbUrl;
    }
    get dbHost() {
      return this.theDbHost;
    }
    get dbPort() {
      return this.theDbPort;
    }
    get dbPoolSize() {
      return this.theDbPoolSize;
    }
    get dbPoolType() {
      return this.theDbPoolType;
    }
    tryFindDbName(a) {
      return a.database ? a.database : "";
    }
    tryFindDbHost(a) {
      return a.host ? a.host : "";
    }
    tryFindDbPort(a) {
      return null != a.port ? k.isNumber(a.port) ? a.port : parseInt(a.port, 10) || -1 : -1;
    }
    tryFindPoolType(a) {
      return null != a.pool ? f.CONNECTION_POOL_TYPE_GENERIC : f.CONNECTION_POOL_TYPE_NOT_A_POOL;
    }
    tryFindPoolSize(a) {
      return k.hasProperty(a.pool, "config", "connectionLimit") ? a.pool.config.connectionLimit : 0;
    }
    buildDbUrl() {
      return `mysql://${this.dbHost}${0 < this.dbPort ? `:${this.dbPort}` : ""}/${this.dbName}`;
    }
  }
  a.MySqlData = g;
});
S("src/lib/transformer/MySqlTransformer", "require exports src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/util/UniqueId src/lib/modules/AutoSensorModule src/lib/sensors/MySqlAttachment src/lib/sensors/ResultSetAttachment src/lib/Agent src/lib/CallbackWrappingHelper src/lib/Debug src/lib/Embedder src/lib/FunctionId src/lib/Patch src/lib/SubPathContext src/lib/transformer/EventEmitterTransformerBase src/lib/transformer/TransformerBase".split(" "), function(t, a, e, 
h, f, k, n, m, g, c, r, b, d, l, x, p, q, v) {
  function D() {
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class C {
    constructor(b) {
      this.mySqlData = b;
      this.execCount = 0;
      this.isCallbackSet = !1;
      this.id = k.UniqueId.getNext();
    }
    createAttachments(a) {
      null != this.mySqlData ? (this.mySqlQueryAttachment = new m.MySqlQueryAttachment(a), this.mySqlQueryAttachment.valid && this.mySqlQueryAttachment.fillMySqlQueryData(this.mySqlData), this.mySqlConnectionPoolAttachment = new m.MySqlConnectionPoolAttachment(a), this.mySqlConnectionPoolAttachment.valid && this.mySqlConnectionPoolAttachment.fillMySqlConnectionPoolData(this.mySqlData), this.mySqlResultSetAttachment = new g.ResultSetAttachment(a)) : b.fail(`${this}: CreateAttachment called without MySqlData!`);
    }
    setNumberOfRowsReturned(b) {
      null != this.mySqlQueryAttachment && this.mySqlQueryAttachment.valid && this.mySqlQueryAttachment.setNumberOfRowsReturned(b);
    }
    toString() {
      this.logPrefix || (this.logPrefix = `MySql ${k.UniqueId.asString(this.id)}`);
      return this.logPrefix;
    }
    static embeddTracker(b, a) {
      C.embedder.set(b, a);
    }
    static getEmbeddedTracker(b) {
      return C.embedder.get(b);
    }
    findCallbackIndex(b) {
      for (let a = 0; a < b.length; a++) {
        if (e.isFunction(b[a])) {
          return a;
        }
      }
      return -1;
    }
    wrapQueryCb(b, a, d = !1) {
      function e() {
        let b, a;
        try {
          if (d && c.Logger.debug(`${w}: mySqlCbSubstitute enter for ${g.name}`), null != w.virtualNodeActivation) {
            if (1 < arguments.length) {
              const b = arguments[1];
              null != b && null != b.length && w.setNumberOfRowsReturned(b.length);
            }
            var e = f.doInvoke(this, r.errorFromFirstArg, arguments);
            w.virtualNodeActivation.exitOrException(e);
            b = new l.FunctionId(g);
            a = v.TransformerBase.createCallbackActivation(w.virtualNodeActivation.spc, b);
          }
        } catch (N) {
          h.logAgentException(N);
        }
        e = f.safeInvoke(this, g, arguments);
        try {
          null != w.virtualNodeActivation && (null != a && (n.addSample(b), a.done(e.exception)), w.virtualNodeActivation.spc.end());
        } catch (N) {
          h.logAgentException(N);
        }
        d && c.Logger.debug(`${w}: mySqlCbSubstitute exit for ${g.name}, didThrow: ${e.didThrow}`);
        return e.rethrow();
      }
      const g = b[a], w = this;
      this.isCallbackSet = !0;
      e._dTWrapped = !0;
      b[a] = e;
      return b;
    }
    setResultSetAttachmentData() {
      null != this.mySqlResultSetAttachment && this.mySqlResultSetAttachment.valid && null != this.virtualNodeActivation && c.Agent.correlation.setSqlResultSetData(this.virtualNodeActivation.spc.path, this.virtualNodeActivation.serialNo, this.execCount, 0, 0);
    }
    get hasCallback() {
      return this.isCallbackSet;
    }
  }
  C.embedder = d.create("mysql");
  class u extends v.TransformerBase {
    constructor() {
      super(...arguments);
      this.queryType = D;
    }
    generateSubstitute(b) {
      const a = this, d = new l.FunctionId(b);
      return function() {
        const g = a.controlParams.isDebugEnabled;
        g && c.Logger.debug(`MySql: ${b.functionName} querySubstitute enter`);
        let l, w;
        var k = arguments;
        if (a.controlParams.active) {
          try {
            if (a.controlParams.entrypoint || null != p.SubPathContext.getActiveContext()) {
              const f = a.getSqlString(arguments), h = new m.MySqlData(this, f, g);
              l = 0 < arguments.length ? C.getEmbeddedTracker(arguments[0]) : void 0;
              null != l ? l.mySqlData = h : l = new C(h);
              const u = l.findCallbackIndex(arguments);
              0 <= u && e.isFunction(arguments[u]) && !e.hasProperty(arguments[u], "_dTWrapped") && (k = l.wrapQueryCb(arguments, u));
              w = a.tryStartAsyncActivation({functionId:d, category:c.Agent.correlation.MethodCategory.Database, attachmentCreator:l, vPathOption:2});
              null != w ? (l.virtualNodeActivation = w.vNodeActivation, l.spc = w.initiatorActivation.spc, l.spc.didInitiateAsyncOp = !0) : g && c.Logger.debug(`${l}: ${b.functionName} querySubstitute no activation, active spc: ${p.SubPathContext.getActiveContext()}`);
            } else {
              g && c.Logger.debug(`MySql: ${b.functionName} skip path creation as no active spc and entrypoint is false`);
            }
          } catch (G) {
            h.logAgentException(G);
          }
        }
        k = f.safeInvoke(this, b.origFn, k);
        try {
          if (null != l) {
            if (!k.didThrow && null != k.retVal) {
              const b = k.retVal;
              e.isFunction(b._callback) || (g && c.Logger.debug(`${l}: mySql embedding tracker on query: ${b.sql}`), C.embeddTracker(k.retVal, l));
            }
            k.didThrow && null != l.virtualNodeActivation && (l.virtualNodeActivation.exitOrException(k.exception), l.virtualNodeActivation.spc.end());
            null != w && (n.addSample(d), w.initiatorActivationDone(k.exception));
          }
        } catch (G) {
          h.logAgentException(G);
        }
        g && c.Logger.debug(`${l || "MySql"}: ${b.functionName} querySubstitute exit, didThrow: ${k.didThrow}`);
        return k.rethrow();
      };
    }
    isAQuery(b) {
      return b instanceof this.queryType;
    }
    getSqlString(b) {
      if (null == b) {
        return "";
      }
      let a;
      0 < b.length && (b = b[0], a = this.isAQuery(b) || e.hasProperty(b, "sql") ? b.sql : b);
      return a ? `${a}` : "";
    }
  }
  a.ConnectionQueryTransformer = u;
  class z {
    constructor(b) {
      this.controlParams = b;
      this.queryType = D;
    }
    generateSubstitute(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        d && c.Logger.debug(`MySql: ${b.functionName} createQuerySubstitute enter`);
        let g;
        var l = arguments;
        if (a.controlParams.active) {
          try {
            if (a.controlParams.entrypoint || null != p.SubPathContext.getActiveContext()) {
              g = 0 < arguments.length ? C.getEmbeddedTracker(arguments[0]) : void 0;
              null == g && (g = new C);
              const b = g.findCallbackIndex(arguments);
              0 <= b && e.isFunction(arguments[b]) && !e.hasProperty(arguments[b], "_dTWrapped") && (l = g.wrapQueryCb(arguments, b));
            } else {
              d && c.Logger.debug(`MySql: ${b.functionName} createQuerySubstitute: No active spc and entrypoint is false`);
            }
          } catch (Q) {
            h.logAgentException(Q);
          }
        }
        l = f.safeInvoke(this, b.origFn, l);
        try {
          null != g && (l.didThrow || C.embeddTracker(l.retVal, g));
        } catch (Q) {
          h.logAgentException(Q);
        }
        d && c.Logger.debug(`${g || "MySql"}: ${b.functionName} createQuerySubstitute exit, didThrow: ${l.didThrow}`);
        return l.rethrow();
      };
    }
  }
  a.ConnectionCreateQueryTransformer = z;
  class B extends q.EventEmitterTransformerBase {
    constructor(b) {
      super(b, "result fields end error data row".split(" "));
    }
    shallWrap(b) {
      return null != C.getEmbeddedTracker(b);
    }
    getWrappedListener(b, a, c) {
      if (!this.shallWrap(b, a)) {
        return c;
      }
      const d = q.EventEmitterTransformerBase.getUnwrappedListener(c);
      return function(e) {
        const g = C.getEmbeddedTracker(b);
        try {
          null != g && null != g.virtualNodeActivation && (g.virtualNodeActivation.isExited || null != g.exitTicks || (g.exitTicks = g.virtualNodeActivation.spc.path.getExitTimeStamps()), "result" === a || "data" === a || "row" === a ? g.execCount++ : "end" === a && g.virtualNodeActivation.spc.open ? (g.setResultSetAttachmentData(), g.virtualNodeActivation.isExited || g.hasCallback || (g.virtualNodeActivation.exit(g.exitTicks), g.virtualNodeActivation.spc.end())) : ("error" === a || e instanceof 
          Error) && !g.virtualNodeActivation.isExited && (g.virtualNodeActivation.methodException(e, g.exitTicks), g.virtualNodeActivation.spc.end()), null != g.spc && g.spc.activate());
        } catch (G) {
          h.logAgentException(G);
        }
        const k = f.safeInvoke(this, c, arguments);
        try {
          c === d && n.addSample(() => new l.FunctionId(d)), null != g && null != g.spc && g.spc.deactivate();
        } catch (G) {
          h.logAgentException(G);
        }
        return k.rethrow();
      };
    }
  }
  a.QueryEmitterTransformer = B;
  class A {
    constructor(b) {
      this.controlParams = b;
    }
    generateSubstitute(b) {
      const a = this;
      return function(d) {
        const e = a.controlParams.isDebugEnabled;
        d = f.safeInvoke(this, b.origFn, d);
        if (null != d.retVal) {
          try {
            const b = d.retVal, f = C.getEmbeddedTracker(this);
            null != f && (e && c.Logger.debug(`${f || "MySql"}: embedding tracker from query on stream`), C.embeddTracker(b, f));
            const g = new B(a.controlParams), h = new x.ModuleSpec("Readable", b);
            g.applyTransformation(h);
          } catch (H) {
            h.logAgentException(H);
          }
        }
        return d.rethrow();
      };
    }
  }
  a.QueryStreamTransformer = A;
});
S("src/lib/sensors/MySqlSensor", "require exports path semver src/lib/Agent src/lib/Patch src/lib/transformer/ContextPassingTransformer src/lib/transformer/MySqlTransformer src/lib/sensors/SensorBase".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.cApiRealm = "mysql";
  class c {
    constructor(b, a) {
      this.moduleVersion = b;
      this.connectionQueryTransformer = new m.ConnectionQueryTransformer(a);
      this.connectionCreateQueryTransformer = new m.ConnectionCreateQueryTransformer(a);
      this.queryStreamTransformer = new m.QueryStreamTransformer(a);
      this.queryEmitterTransformer = new m.QueryEmitterTransformer(a);
    }
  }
  class r extends g.SensorBase {
    constructor() {
      super(...arguments);
      this.moduleMap = {};
    }
    applyInstrumentation(b) {
      b.matchRequest("mysql") && this.pushSensorState(b);
      b.matchRequestPattern("Pool.js") && this.patchPoolModule(b);
      b.matchRequestPattern("Connection.js") && this.patchConnectionModule(b);
      b.matchRequestPattern("Query.js") && this.patchQueryModule(b);
    }
    patchPoolModule(b) {
      const a = new n.ContextPassingTransformer(this);
      this.patchGetConnectionCommand(b.moduleExports, a);
      this.patchAcquireConnectionCommand(b.moduleExports, a);
    }
    patchConnectionModule(b) {
      var a = this.getSensorState(b.resolvedModulePath);
      null != a && (this.patchQueryCommand(b.moduleExports, a.connectionQueryTransformer), this.patchCreateQueryCommand(b.moduleExports, a.connectionCreateQueryTransformer), a.moduleVersion ? h.satisfies(a.moduleVersion, "<2.4") && (a = new n.ContextPassingTransformer(this), this.patchBeginTransactionCommand(b.moduleExports, a), this.patchCommitCommand(b.moduleExports, a), this.patchRollbackCommand(b.moduleExports, a)) : f.Logger.info("MySql client version >2.4 detected. Not patching 'beginTransaction', 'commit' and 'rollback'."));
    }
    pushSensorState(b) {
      const a = e.dirname(b.resolvedModulePath);
      null == this.moduleMap[a] && (b = new c(b.moduleInfo.version, this), this.moduleMap[a] = b);
    }
    patchQueryModule(b) {
      const a = this.getSensorState(b.resolvedModulePath);
      null != a && (a.connectionQueryTransformer.queryType = b.moduleExports, a.connectionCreateQueryTransformer.queryType = b.moduleExports, this.transformQueryEmitter(b.moduleExports, a.queryEmitterTransformer), this.transformQueryStream(b.moduleExports, a.queryStreamTransformer));
    }
    getSensorState(b) {
      for (const a in this.moduleMap) {
        if (0 === b.indexOf(a)) {
          return this.moduleMap[a];
        }
      }
    }
    patchGetConnectionCommand(b, c) {
      b = new k.FunctionSpec("getConnection", "", b.prototype, k.AsyncTrackingMode.CallbackLast, a.cApiRealm);
      k.applyToSingle(b, c);
    }
    patchQueryCommand(b, c) {
      b = new k.FunctionSpec("query", "", b.prototype, a.cApiRealm);
      k.applyToSingle(b, c);
    }
    patchCreateQueryCommand(b, c) {
      b = new k.FunctionSpec("createQuery", "", b, a.cApiRealm);
      k.applyToSingle(b, c);
    }
    patchBeginTransactionCommand(b, c) {
      b = new k.FunctionSpec("beginTransaction", "", b.prototype, a.cApiRealm);
      k.applyToSingle(b, c);
    }
    patchCommitCommand(b, c) {
      b = new k.FunctionSpec("commit", "", b.prototype, a.cApiRealm);
      k.applyToSingle(b, c);
    }
    patchRollbackCommand(b, c) {
      b = new k.FunctionSpec("rollback", "", b.prototype, a.cApiRealm);
      k.applyToSingle(b, c);
    }
    patchAcquireConnectionCommand(b, c) {
      b = new k.FunctionSpec("acquireConnection", "", b.prototype, k.AsyncTrackingMode.CallbackLast, a.cApiRealm);
      k.applyToSingle(b, c);
    }
    transformQueryEmitter(b, a) {
      b = new k.ModuleSpec("Query", b.prototype);
      a.applyTransformation(b);
    }
    transformQueryStream(b, c) {
      b = new k.FunctionSpec("stream", "Query", b.prototype, a.cApiRealm);
      k.applyToSingle(b, c);
    }
  }
  a.MySqlSensor = r;
});
S("src/lib/sensors/MySql2Sensor", ["require", "exports", "src/lib/Patch", "src/lib/sensors/MySqlSensor", "src/lib/transformer/ContextPassingTransformer"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k extends h.MySqlSensor {
    applyInstrumentation(a) {
      (a.matchRequest("mysql2") || a.matchRequest("mysql2/promise")) && this.pushSensorState(a);
      a.matchRequestPattern("Pool.js") && this.patchPoolModule(a);
      if (a.matchRequestPattern("Connection.js")) {
        const e = this.getSensorState(a.resolvedModulePath);
        null != e && (this.patchConnectionModule(a), this.patchExecuteCommand(a.moduleExports, e.connectionQueryTransformer));
      }
      a.matchRequestPattern("Query.js") && this.patchQueryModule(a);
    }
    patchPoolModule(a) {
      const e = new f.ContextPassingTransformer(this);
      this.patchGetConnectionCommand(a.moduleExports, e);
    }
    patchExecuteCommand(a, f) {
      a = new e.FunctionSpec("execute", "", a.prototype, h.cApiRealm);
      e.applyToSingle(a, f);
    }
  }
  a.MySql2Sensor = k;
});
S("src/lib/sensors/PostgresAttachment", ["require", "exports", "src/lib/Agent", "src/lib/AttachmentBase", "src/lib/util/CoreUtil"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k extends h.AttachmentBase {
  }
  class n extends k {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_SQL_ID, 0);
    }
    fillSqlQueryData(a) {
      null != this.attachment && null != a && null != a.queryString && this.setString(e.Agent.correlation.AttachmentFieldId.SQL_STATEMENT, a.queryString, e.Configuration.maxSqlStringLen);
    }
    updateAttachment(a, g) {
      null != this.attachment && (f.isNumber(a) && this.attachment.setFieldInteger(e.Agent.correlation.AttachmentFieldId.SQL_NUM_ROWS_RETURNED, a), f.isNumber(g) && this.attachment.setFieldInteger(e.Agent.correlation.AttachmentFieldId.SQL_METHOD_TYPE, g));
    }
  }
  a.PostgreSQLAttachment = n;
  class m extends k {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_CONNECTION_POOL_ID, 0);
    }
    fillSqlConnectionPoolData(a) {
      null != this.attachment && null != a && this.setMultipleFields(c => {
        const b = e.Agent.correlation.AttachmentFieldId;
        c.stringCachedOrUnavailable(b.CONNECTION_POOL_DB, a.dbName);
        c.stringCachedOrUnavailable(b.CONNECTION_POOL_URL, a.dbUrl);
        c.stringCached(b.CONNECTION_POOL_DBTYPE, "PostgreSQL");
        c.stringCached(b.CONNECTION_POOL_NAME, "default-pool");
        c.stringCachedOrUnavailable(b.CONNECTION_POOL_DBHOST, a.dbHost);
        c.integer(b.CONNECTION_POOL_DBPORTNO, a.dbPort);
        c.integer(b.CONNECTION_POOL_TYPE, a.dbPoolType);
        c.integer(b.CONNECTION_POOL_AGGREGATION_MECHANISM, e.Agent.correlation.DbAggregationMechanism.DB_AGGREGATION_MECHANISM_UNDEFINED);
        c.integer(b.CONNECTION_POOL_SIZE, a.dbPoolSize);
      });
    }
  }
  a.PostgresConnectionPoolAttachment = m;
  class g {
    constructor(a, e) {
      a = a.connectionParameters || {};
      f.isString(e) ? this.queryString = e : this.queryString = e.text || "<?>";
      this.dbName = a.database;
      this.dbHost = a.host;
      this.dbPort = this.getDbPort(a);
      this.dbPoolSize = this.dbPoolType = 0;
      this.dbUrl = "";
    }
    getDbPort(a) {
      return null != a.port ? f.isNumber(a.port) ? a.port : parseInt(a.port, 10) || -1 : -1;
    }
  }
  a.PostgresData = g;
});
S("src/lib/transformer/PostgresTracker", "require exports src/lib/util/UniqueId src/lib/sensors/PostgresAttachment src/lib/AsyncTracker src/lib/CallbackWrappingHelper src/lib/Debug src/lib/Embedder".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class g extends f.default {
    constructor(a, f, b) {
      super(f, b);
      this.postgresData = a;
      this.errorExtractor = k.errorFromFirstArg;
      this.returnsPromise = !1;
      this.id = e.UniqueId.getNext();
    }
    createAttachments(a) {
      null != this.postgresData ? ("query" === this.descriptor.functionName && (this.sqlAttachment = new h.PostgreSQLAttachment(a), this.sqlAttachment.valid && this.sqlAttachment.fillSqlQueryData(this.postgresData)), this.connectionPoolAttachment = new h.PostgresConnectionPoolAttachment(a), this.connectionPoolAttachment.valid && this.connectionPoolAttachment.fillSqlConnectionPoolData(this.postgresData)) : n.fail("CreateAttachment called without PostgresData!");
    }
    updateSQLAttachment(a) {
      "query" === this.descriptor.functionName && null != this.sqlAttachment && this.sqlAttachment.valid && this.sqlAttachment.updateAttachment(a, void 0);
    }
    static setTracker(a, e) {
      g.embedder.set(a, e);
    }
    static getTracker(a) {
      return g.embedder.get(a);
    }
    toString() {
      this.logPrefix || (this.logPrefix = `PostgresTracker ${e.UniqueId.asString(this.id)}`);
      return this.logPrefix;
    }
  }
  a.PostgresTracker = g;
  g.embedder = m.create("query");
});
S("src/lib/transformer/PostgresTransformer", "require exports src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/Agent src/lib/FunctionId src/lib/SubPathContext src/lib/modules/AutoSensorModule src/lib/sensors/PostgresAttachment src/lib/transformer/AsyncTransformerBase src/lib/transformer/PostgresTracker src/lib/transformer/PromiseTransformerUtilities src/lib/transformer/TransformerBase".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d, l) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class x extends r.AsyncTransformerBase {
    generateSubstitute(a) {
      const d = this, e = new n.FunctionId(a);
      return function() {
        const l = d.controlParams.isDebugEnabled;
        l && k.Logger.debug(`${a.functionName} querySubstitute enter`);
        let u;
        var p = arguments;
        let q;
        if (d.controlParams.active) {
          try {
            const f = new c.PostgresData(this, 0 < arguments.length ? arguments[0] : "");
            u = new b.PostgresTracker(f, d, a);
            q = d.tryStartAsyncActivation({functionId:e, category:k.Agent.correlation.MethodCategory.Database, attachmentCreator:u, vPathOption:1});
            null != q ? (u.virtualNodeActivation = q.vNodeActivation, p = u.manipulateArguments(p)) : l && k.Logger.debug(`${u}: no activation, active spc: ${m.SubPathContext.getActiveContext()}`);
          } catch (A) {
            h.logAgentException(A);
          }
        }
        p = f.safeInvoke(this, a.origFn, p);
        try {
          null != q && (p.didThrow ? (q.vNodeActivation.exitOrException(p.exception), q.vNodeActivation.spc.end()) : u.manipulateReturnValue(p), g.addSample(e), q.initiatorActivationDone(p.exception));
        } catch (A) {
          h.logAgentException(A);
        }
        l && k.Logger.debug(`${a.functionName} querySubstitute exit, didThrow: ${p.didThrow}`);
        return p.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this;
      return function() {
        const c = a.controlParams.isDebugEnabled;
        let d, e;
        try {
          if (c && k.Logger.debug(`${b}: postgresCbSubstitute enter for ${b.origCb.name}`), null != b.virtualNodeActivation) {
            a.updateSQLAttachment(arguments, b);
            var p = f.doInvoke(this, b.errorExtractor, arguments);
            b.virtualNodeActivation.exitOrException(p);
            b.injectedCallback || (d = new n.FunctionId(b.origCb), e = l.TransformerBase.createCallbackActivation(b.virtualNodeActivation.spc, d));
          }
        } catch (B) {
          h.logAgentException(B);
        }
        p = f.safeInvoke(this, b.origCb, arguments);
        try {
          null != b.virtualNodeActivation && (null != e && (g.addSample(d), e.done(p.exception)), b.virtualNodeActivation.spc.end());
        } catch (B) {
          h.logAgentException(B);
        }
        c && k.Logger.debug(`${b}: postgresCbSubstitute exit for ${b.origCb.name}, didThrow: ${p.didThrow}`);
        return p.rethrow();
      };
    }
    wrapReturnValue(a, c) {
      function g(b, c, d) {
        return function(b) {
          var e;
          {
            var g = b, u = arguments;
            (e = m) && k.Logger.debug(`${a}: enter then call, isCatch ${c}`);
            let w;
            try {
              if (null != a.virtualNodeActivation) {
                if (!a.virtualNodeActivation.isExited) {
                  a.virtualNodeActivation.exitOrException(c ? g : void 0), a.virtualNodeActivation.spc.end(), e && k.Logger.debug(`${a}: ended virtual node and path`);
                } else {
                  if (d !== p) {
                    const b = new n.FunctionId(d);
                    w = l.TransformerBase.createCallbackActivation(a.virtualNodeActivation.spc, b);
                    e && k.Logger.debug(`${a}: new callback node for ${b.functionName}`);
                  }
                }
              }
            } catch (H) {
              h.logAgentException(H);
            }
            g = f.safeInvoke(this, d, u);
            try {
              null != w && w.done(g.exception);
            } catch (H) {
              h.logAgentException(H);
            }
            e && k.Logger.debug(`${a}: exit then call, didThrow ${g.didThrow}`);
            e = g.rethrow();
          }
          return e;
        };
      }
      const m = this.controlParams.isDebugEnabled;
      c = c.retVal;
      e.hasProperty(c, "on") && (m && k.Logger.debug(`${a}: postgres wrapping event listeners on query`), b.PostgresTracker.setTracker(c, a));
      d.PromiseTransformerUtilities.isActuallyAPromise(c) && (m && k.Logger.debug(`${a}: register then wrapper and install dummy handlers`), d.PromiseTransformerUtilities.registerThenWrapper(c, g), a.returnsPromise = !0);
    }
    updateSQLAttachment(b, a) {
      1 < b.length && (b = b[1], null != b && null != b.rowCount && a.updateSQLAttachment(b.rowCount));
    }
  }
  a.PostgresClientTransformer = x;
  const p = () => {
  };
});
S("src/lib/transformer/PostgresQueryTransformer", "require exports src/lib/modules/AutoSensorModule src/lib/transformer/EventEmitterTransformerBase src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/CallbackWrappingHelper src/lib/FunctionId src/lib/Logger src/lib/transformer/AsyncTransformerBase src/lib/transformer/PostgresTracker src/lib/transformer/PromiseTransformerUtilities src/lib/transformer/PromiseTransformer src/lib/transformer/TransformerBase".split(" "), function(t, a, e, h, f, 
k, n, m, g, c, r, b, d, l) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class x extends h.EventEmitterTransformerBase {
    constructor(b) {
      super(b, ["row", "end", "error"]);
    }
    shallWrap(b) {
      return null != r.PostgresTracker.getTracker(b);
    }
    getWrappedListener(b, a, c) {
      const d = r.PostgresTracker.getTracker(b);
      if (null == d) {
        return c;
      }
      const u = this.controlParams.isDebugEnabled, p = h.EventEmitterTransformerBase.getUnwrappedListener(c);
      return function(b) {
        let a, h;
        try {
          null != p && "" !== p.name && (a = new m.FunctionId(p), u && g.debug(`PostgresQuery event ${a.functionName}`)), null != d.virtualNodeActivation && (d.virtualNodeActivation.isExited || (b instanceof Error ? d.virtualNodeActivation.methodException(b) : d.virtualNodeActivation.exit(), d.virtualNodeActivation.spc.end()), null != a && (h = l.TransformerBase.createCallbackActivation(d.virtualNodeActivation.spc, a)));
        } catch (K) {
          f.logAgentException(K);
        }
        const q = k.safeInvoke(this, c, arguments);
        try {
          null != a && c === p && e.addSample(a), null != h && h.done(q.exception);
        } catch (K) {
          f.logAgentException(K);
        }
        return q.rethrow();
      };
    }
  }
  a.PostgresQueryTransformer = x;
  class p extends c.AsyncTransformerBase {
    constructor(b, a) {
      super(b);
      this.sensor = b;
      this.transformer = a;
    }
    generateSubstitute(a) {
      const c = this;
      return function() {
        const d = c.controlParams.isDebugEnabled, e = k.safeInvoke(this, a.origFn, arguments);
        try {
          if (b.PromiseTransformerUtilities.isActuallyAPromise(e.retVal)) {
            d && g.debug(`PostgresQuery6x: wrapping promise ${e.retVal.functionName}`);
            const b = r.PostgresTracker.getTracker(this);
            null != b && c.transformer.wrapReturnValue(b, e);
          }
        } catch (u) {
          f.logAgentException(u);
        }
        return e.rethrow();
      };
    }
    wrapCallback(b) {
      return n.CallbackWrappingHelper.wrapCallbackContextPassing(b);
    }
    wrapReturnValue(a, c) {
      b.PromiseTransformerUtilities.isActuallyAPromise(c.retVal) && (c.didThrow || (new d.PromiseTransformer(!0, !0, this.sensor)).instrument(c.retVal));
    }
  }
  a.PostgresQuery6xTransformer = p;
});
S("src/lib/sensors/PostgresSensor", "require exports semver path src/lib/Agent src/lib/Patch src/lib/transformer/ContextPassingTransformer src/lib/transformer/PostgresQueryTransformer src/lib/transformer/PostgresTransformer src/lib/sensors/SensorBase".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class r extends c.SensorBase {
    constructor() {
      super(...arguments);
      this.transformerMap = {};
    }
    applyInstrumentation(b) {
      if (b.matchRequest("pg")) {
        var a = `PostgreSQL (pg) v${b.moduleInfo.version} detected`;
        r.isV7orLater(b) ? f.Logger.info(`${a}: ${b.resolvedModulePath}`) : f.Logger.info(`${a}, this version may not be fully supported!`);
        a = h.dirname(b.resolvedModulePath);
        null == this.transformerMap[a] && (this.transformerMap[a] = new g.PostgresClientTransformer(this));
      }
      if (b.matchRequestPattern("client")) {
        a = new n.ContextPassingTransformer(this);
        const c = this.getTransformer(b);
        null != c && (this.patchClientConnect(b.moduleExports, a), this.patchClientQuery(b.moduleExports, c));
      }
      b.matchRequestPattern("query") && !r.isV7orLater(b) && (a = this.getTransformer(b), null != a && this.transformQuery(b.moduleExports, a));
    }
    patchClientQuery(b, a) {
      b = new k.FunctionSpec("query", "", b.prototype, k.AsyncTrackingMode.CallbackLastOrPromise, "postgres");
      k.applyToSingle(b, a);
    }
    patchClientConnect(b, a) {
      b = new k.FunctionSpec("connect", "", b.prototype, k.AsyncTrackingMode.CallbackLastOrPromise, "postgres");
      k.applyToSingle(b, a);
    }
    transformQuery(b, a) {
      const c = new k.ModuleSpec("Query", b.prototype);
      (new m.PostgresQueryTransformer(this)).applyTransformation(c);
      a = new m.PostgresQuery6xTransformer(this, a);
      b = new k.FunctionSpec("then", "", b.prototype, k.AsyncTrackingMode.None, "postgres");
      k.applyToSingle(b, a);
    }
    static isV7orLater(b) {
      return e.satisfies(b.moduleInfo.version, ">=7.0.0");
    }
    getTransformer(b) {
      b = h.dirname(b.resolvedModulePath);
      return this.transformerMap[b];
    }
  }
  a.PostgresSensor = r;
});
S("src/lib/sensors/CouchbaseAttachment", "require exports net url util src/lib/util/CoreUtil src/lib/util/JsonObfuscatorUtil src/lib/util/UniqueId src/lib/sensors/SensorConstants src/lib/Agent src/lib/AttachmentBase src/lib/CallbackWrappingHelper src/lib/Debug src/lib/Embedder".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d, l) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class x extends r.AttachmentBase {
    constructor(b) {
      super(b, c.Agent.correlation.AttachmentId.ATTACHMENT_SQL_ID, 0);
    }
    fillEntryData(b, a) {
      this.setMultipleFields(d => {
        const e = c.Agent.correlation.AttachmentFieldId;
        d.string(e.SQL_STATEMENT, b, c.Configuration.maxSqlStringLen);
        null != a && d.integer(e.SQL_METHOD_TYPE, a);
      });
    }
    fillExitData(b) {
      Number.isInteger(b) && 0 <= b && this.attachment.setFieldInteger(c.Agent.correlation.AttachmentFieldId.SQL_NUM_ROWS_RETURNED, b);
    }
  }
  a.CouchbaseSQLAttachment = x;
  class p extends r.AttachmentBase {
    constructor(b) {
      super(b, c.Agent.correlation.AttachmentId.ATTACHMENT_CONNECTION_POOL_ID, 0);
    }
    fillConn(b, a) {
      let d = [];
      null != b.getQueryhosts() ? (b.debug && c.Logger.debug(`${b} 	| Using queryhosts=${b.getQueryhosts()}`), d = b.getQueryhosts()) : null != b.getHosts() ? (b.debug && c.Logger.debug(`${b} 	| Using hosts=${f.inspect(b.getHosts())}`), d = b.getHosts()) : (b.debug && c.Logger.debug(`${b} 	| Using fallback host.`), d.push(["<unknown host>", -1]));
      0 === d.length && (b.debug && c.Logger.debug(`${b}	| encountered empty hosts array. adding fallback host.`), d.push(["<unknown host>", -1]));
      this.setMultipleFields(e => {
        const f = c.Agent.correlation.AttachmentFieldId;
        e.stringCached(f.CONNECTION_POOL_DB, b.name);
        e.stringCached(f.CONNECTION_POOL_URL, d.toString());
        e.stringCached(f.CONNECTION_POOL_DBTYPE, "Couchbase");
        e.stringCached(f.CONNECTION_POOL_NAME, "default-pool");
        e.stringCached(f.CONNECTION_POOL_DBHOST, d[0][0]);
        e.integer(f.CONNECTION_POOL_DBPORTNO, 8093);
        e.integer(f.CONNECTION_POOL_TYPE, g.CONNECTION_POOL_TYPE_NOT_A_POOL);
        e.integer(f.CONNECTION_POOL_AGGREGATION_MECHANISM, a);
        e.integer(f.CONNECTION_POOL_SIZE, d.length);
      });
    }
  }
  a.CouchbaseConnectionAttachment = p;
  class q {
    constructor(a, c) {
      this.data = c;
      this.debug = a.controlParams.isDebugEnabled;
      this.ID = m.UniqueId.getNext();
      this.errorExtractor = b.errorFromFirstArg;
    }
    toString() {
      this.prefix || (this.prefix = `CouchbaseTracker(#${this.ID})`);
      return this.prefix;
    }
    aggregationType() {
      return c.Agent.correlation.DbAggregationMechanism.DB_AGGREGATION_MECHANISM_UNDEFINED;
    }
    fillEntryData() {
      this.debug && c.Logger.debug(`${this} | starting to fill entry data`);
      null != this.cPoolAttch && null != this.sqlAttch && (this.sqlAttch.fillEntryData(this.formSQLString(), this.aggregationType()), this.cPoolAttch.fillConn(this.data, c.Agent.correlation.DbAggregationMechanism.DB_AGGREGATION_MECHANISM_NO_AGGREGATION));
    }
    getServiceTypeFromMethodName(b) {
      switch(b.replace(/^_+/, "")) {
        case "upsert":
        case "insert":
        case "remove":
        case "replace":
        case "append":
        case "prepend":
        case "counter":
        case "mutateIn":
        case "binaryPrepend":
        case "binaryAppend":
          b = c.Agent.correlation.DbServiceType.DB_SERVICE_TYPE_COUCHBASE_DB_WRITE;
          break;
        case "get":
        case "getAndLock":
        case "getAndTouch":
        case "getReplica":
        case "getMulti":
        case "lookupIn":
        case "exists":
          b = c.Agent.correlation.DbServiceType.DB_SERVICE_TYPE_COUCHBASE_DB_READ;
          break;
        default:
          this.debug && (c.Logger.debug(`${this} | Got unknown methodname=${b}`), d.fail()), b = c.Agent.correlation.DbServiceType.DB_SERVICE_TYPE_UNDEFINED;
      }
      return b;
    }
  }
  class v extends q {
    constructor(b, a, c) {
      super(b, c);
      this.descriptor = a;
      this.hasPromiseHandled = !1;
    }
    createAttachments(b) {
      this.debug && c.Logger.debug(`${this} | creating attachments. activation=${b}`);
      this.cPoolAttch = new p(b);
      this.sqlAttch = new x(b);
      this.fillEntryData();
    }
    fillExitData(b) {
      null != this.sqlAttch && this.sqlAttch.fillExitData(b);
    }
    get virtualNodeActivation() {
      d.isEnabled() && null == this.activationResult && d.fail("activationResult is undefined");
      return this.activationResult.vNodeActivation;
    }
    toString() {
      this.prefix || (this.prefix = `CouchbaseTracker(${this.ID})`);
      return this.prefix;
    }
    get spc() {
      d.isEnabled() && null == this.activationResult && d.fail("activationResult is undefined");
      return this.activationResult.initiatorActivation.spc;
    }
    formSQLString() {
      const b = this.descriptor.functionName.replace(/^_+/, "");
      return `${this.data.name}.${b}()`;
    }
    aggregationType() {
      const b = this.descriptor.functionName.replace(/^_+/, "");
      return this.getServiceTypeFromMethodName(b);
    }
  }
  a.CouchbaseV3Tracker = v;
  class D extends v {
    constructor(b, a, c, d) {
      super(b, a, c);
      this.query = d;
    }
    formSQLString() {
      return this.query;
    }
    aggregationType() {
      return c.Agent.correlation.DbServiceType.DB_SERVICE_TYPE_COUCHBASE_DB_QUERY;
    }
  }
  a.CouchbaseQueryTracker = D;
  class C extends v {
    constructor(b, a, d, e) {
      super(b, a, d);
      this.cmdCount = null == e ? 0 : e.length;
      this.errorExtractor = function(b, a) {
        if (k.isError(b)) {
          return b;
        }
        if (k.hasProperty(a, "results")) {
          const b = a.results.filter(b => null != b.error).map(b => b.error);
          return k.hasElements(b, 1) ? b[0] : void 0;
        }
        c.Logger.warning(`${this} | can not extract error. argc=${arguments.length}, errorCnt=${b}, defined(doc)=${null != a}`);
      };
    }
    formSQLString() {
      const b = this.descriptor.functionName.replace(/^_+/, "");
      return `${this.data.name}.${b}(${this.obfuscatedOpString()})`;
    }
    obfuscatedOpString() {
      return 0 === this.cmdCount ? "" : "[?" + ",?".repeat(this.cmdCount - 1) + "]";
    }
  }
  a.CouchbaseSubDocumentTracker = C;
  class u extends q {
    constructor(b, a, c, d) {
      super(b, c);
      this.descriptor = a;
      this.options = d;
    }
    createAttachments(b) {
      this.debug && c.Logger.debug(`${this} | creating attachments. activation=${b}`);
      this.cPoolAttch = new p(b);
      this.sqlAttch = new x(b);
      this.fillEntryData();
    }
    fillExitData(b) {
      null != this.sqlAttch && this.sqlAttch.fillExitData(b);
    }
    get virtualNodeActivation() {
      d.isEnabled() && null == this.activationResult && d.fail("activationResult is undefined");
      return this.activationResult.vNodeActivation;
    }
    get spc() {
      d.isEnabled() && null == this.activationResult && d.fail("activationResult is undefined");
      return this.activationResult.initiatorActivation.spc;
    }
    formSQLString() {
      const b = this.descriptor.functionName.replace(/^_+/, "");
      return `${this.data.name}.${b}(${void 0 === this.options ? "" : n.QueryNormalizer.normalizeQueryToString(this.options)})`;
    }
    aggregationType() {
      const b = this.descriptor.functionName.replace(/^_+/, "");
      return this.getServiceTypeFromMethodName(b);
    }
  }
  a.CouchbaseV2Tracker = u;
  u.trackerEmbedder = l.create("cbTracker");
  class z extends u {
    constructor(b, a, c, d, e) {
      super(b, a, c, "");
      this.query = d;
      this.viewQualifier = e;
      this.hasCallback = this.injectedCallback = !1;
      this.rowCnt = 0;
    }
    createAttachments(b) {
      this.cPoolAttch = new p(b);
      this.sqlAttch = new x(b);
      this.fillEntryData();
    }
    setTracker(b) {
      z.emitterEmbedder.hasData(b) ? this.debug && c.Logger.debug("Trying to embed twice!") : null != b ? (this.debug && c.Logger.debug(`${this} | embedded Tracker!`), z.emitterEmbedder.set(b, this)) : this.debug && null == b && c.Logger.debug(`${this} | Trying to embed on ${b}!`);
    }
    static getTracker(b) {
      return z.emitterEmbedder.get(b);
    }
    fillExitData(b = this.rowCnt) {
      null != this.sqlAttch && this.sqlAttch.fillExitData(b);
    }
    toString() {
      this.prefix || (this.prefix = `CouchbaseQueryTracker(${this.ID})`);
      return this.prefix;
    }
    calledRowEvent() {
      return ++this.rowCnt;
    }
    aggregationType() {
      let b = c.Agent.correlation.DbServiceType.DB_SERVICE_TYPE_UNDEFINED;
      switch(this.descriptor.functionName) {
        case "_cbas":
        case "_n1ql":
          b = c.Agent.correlation.DbServiceType.DB_SERVICE_TYPE_COUCHBASE_DB_QUERY;
          break;
        case "_view":
          b = c.Agent.correlation.DbServiceType.DB_SERVICE_TYPE_COUCHBASE_DB_VIEW;
          break;
        case "_fts":
          b = c.Agent.correlation.DbServiceType.DB_SERVICE_TYPE_COUCHBASE_DB_VIEW;
          break;
        default:
          c.Logger.warning(`${this.data} | found unknown query method=${this.descriptor.functionName}`), d.fail();
      }
      return b;
    }
    formSQLString() {
      let b = "";
      switch(this.descriptor.functionName) {
        case "_cbas":
        case "_n1ql":
          b = this.query.options.statement;
          break;
        case "_view":
          b = this.parsePseudoSQLViewQuery(this.query);
          break;
        case "_fts":
          b = this.parsePseudoSQLSearchQuery(this.query);
          break;
        default:
          c.Logger.warning(`${this.data} | found unknown query method=${this.descriptor.functionName}`), d.fail();
      }
      return b;
    }
    parsePseudoSQLSearchQuery(b) {
      return `(${this.data.name}.${b.data.indexName}).FTSearch(${n.QueryNormalizer.normalizeQueryToString(b)})`;
    }
    parsePseudoSQLViewQuery(b) {
      return `(${this.data.name}.${this.viewQualifier}).ViewQuery(` + n.QueryNormalizer.normalizeQueryToString(b, "stale skip limit group group_level key keys startkey endkey startkey_docid endkey_docid full_set reduce bbox".split(" ")) + ")";
    }
  }
  a.CouchbaseV2QueryTracker = z;
  z.onRow = function() {
    const b = z.getTracker(this);
    if (null != b) {
      const a = b.calledRowEvent();
      b.debug && 0 === a && c.Logger.debug(`${b} | handled first row event. Will omit logging others.`);
    } else {
      c.Logger.debug("Called CouchbaseQueryTracker#onRow without embedded tracker? ");
    }
  };
  z.emitterEmbedder = l.create("tracker");
  class B extends u {
    constructor(b, a, d, e) {
      super(b, a, d, e);
      this.errorExtractor = function(b, a) {
        if (k.hasProperty(a, "contents")) {
          const b = a.contents.filter(b => null != b.error).map(b => b.error);
          return k.hasElements(b, 1) ? b[0] : void 0;
        }
        c.Logger.warning(`${this} | can not extract error. argc=${arguments.length}, errorCnt=${b}, defined(doc)=${null != a}`);
      };
    }
  }
  a.CouchbaseBuilderTracker = B;
  class A {
    constructor(b) {
      this.debug = A.debug;
      this.ID = m.UniqueId.getNext();
      this.name = b;
      this.hosts = [];
    }
    static createV2(b) {
      A.connStr && (b.dsnObj = A.connStr.normalize(b.dsnObj), A.connStr.stringify(b.dsnObj));
      const a = new A(b.dsnObj.bucket);
      if (Array.isArray(b.dsnObj.hosts)) {
        for (var d of b.dsnObj.hosts) {
          if (b = 0 > d[A.HOSTINDEX].indexOf("://"), b = h.parse((b ? "fillerProtocol://" : "") + d[A.HOSTINDEX] + ":" + d[A.PORTINDEX]), b.hostname) {
            if (b.hostname.match(/^([a-zA-Z])/)) {
              const d = b.port ? parseInt(b.port, 10) : -1;
              a.hosts.push([b.hostname, 0 === d ? -1 : d]);
              a.debug && c.Logger.debug(`${a} | Pushed: ${[b.hostname, 0 === d ? -1 : d]}`);
            } else {
              e.isIPv4(d[A.HOSTINDEX]) || e.isIPv6(d[A.HOSTINDEX]) ? (b = d[A.PORTINDEX], a.hosts.push([d[A.HOSTINDEX], void 0 === b ? -1 : b]), a.debug && c.Logger.debug(`${a} | Pushed: ${[d[A.HOSTINDEX], void 0 === b ? -1 : b]}`)) : a.debug && c.Logger.debug(`${a} | Could not parse ${f.inspect(d)}`);
            }
          }
        }
      } else {
        d = parseInt(b.dsnObj.hosts.port, 10), a.hosts.push([b.dsnObj.hosts.host, 0 === d ? -1 : d]), a.debug && c.Logger.debug(`${a} | Pushed non array: ${f.inspect(b.dsnObj.hosts)}`);
      }
      return a;
    }
    static createV3(b) {
      const a = new A(null == b.bucketName ? "" : b.bucketName);
      var d = b.connStr.indexOf("://");
      b = b.connStr.substr(0 < d ? d + 3 : 0).split(/[;,]/);
      for (const e of b) {
        d = e.split(":", 2), 2 <= d.length ? (b = d[0].replace(/[\[\]]/gm, ""), d = 1 < d.length ? parseInt(d[1], 10) : -1, a.hosts.push([b, d]), a.debug && c.Logger.debug(`${a} | Pushed: ${[b, d]}`)) : a.debug && c.Logger.debug(`${a} | failed to parse '${e}'`);
      }
      return a;
    }
    getHosts() {
      return this.hosts;
    }
    getQueryhosts() {
      return this.qHosts;
    }
    setQueryhosts(b) {
      if (void 0 === b) {
        return !1;
      }
      Array.isArray(b) || (b = b.split(","));
      const a = [];
      for (let d of b) {
        if (d) {
          d = A.connStr.normalize(d);
          var c = h.parse(d);
          b = c.hostname || "<unknown>";
          c = c.port ? parseInt(c.port, 10) : -1;
          a.push([b, c]);
        }
      }
      this.qHosts = a;
      return !0;
    }
    static getData(b) {
      return A.dataEmbedder.get(b);
    }
    setData(b) {
      A.dataEmbedder.set(b, this);
    }
    toString() {
      this.prefix || (this.prefix = `CbData(${this.name}#${this.ID})`);
      return this.prefix;
    }
  }
  a.CbData = A;
  A.HOSTINDEX = 0;
  A.PORTINDEX = 1;
  A.dataEmbedder = l.create("cbData");
});
S("src/lib/transformer/CouchbaseDbTransformer", "require exports src/lib/util/CoreUtil src/lib/util/InvocationUtil src/lib/util/ErrorUtil src/lib/util/JsonObfuscatorUtil src/lib/modules/AutoSensorModule src/lib/sensors/CouchbaseAttachment src/lib/Agent src/lib/Debug src/lib/FunctionId src/lib/Patch src/lib/SubPathContext src/lib/transformer/EventEmitterTransformerBase src/lib/transformer/TransformerBase src/lib/transformer/PromiseTransformerUtilities".split(" "), function(t, a, e, h, f, k, n, m, 
g, c, r, b, d, l, x, p) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class q extends x.TransformerBase {
    constructor(b) {
      super(b);
    }
    wrapCallback(b) {
      return function(a, c) {
        b.debug && g.Logger.debug(`${b} | entered base transformer wrapped callback`);
        let d, e;
        try {
          if (null != b.virtualNodeActivation) {
            var l = b.errorExtractor(a, c);
            null != c && (null != c.value ? b.fillExitData(1) : Array.isArray(c.contents) ? b.fillExitData(c.contents.length) : Array.isArray(c.results) && b.fillExitData(c.results.length));
            b.debug && g.Logger.debug(`${b} | exiting virtual node=${b.virtualNodeActivation} didThrow=${void 0 !== a}`);
            b.virtualNodeActivation.exitOrException(l);
            d = new r.FunctionId(b.origCb);
            e = x.TransformerBase.createCallbackActivation(b.virtualNodeActivation.spc, d);
            null == e && b.debug && g.Logger.debug(`${b} | could not create callback method activation`);
          }
        } catch (L) {
          f.logAgentException(L);
        }
        l = h.safeInvoke(this, b.origCb, arguments);
        try {
          null != b.virtualNodeActivation && (null != e && (n.addSample(d), e.done(l.exception)), b.virtualNodeActivation.spc.end(), b.debug && g.Logger.debug(`${b} | ending spc=${b.virtualNodeActivation.spc} in callback.`));
        } catch (L) {
          f.logAgentException(L);
        }
        return l.rethrow();
      };
    }
    wrapReturnValue(b) {
      b.debug && c.fail();
    }
    extractCallback(b) {
      for (let a = b.length - 1; 0 <= a; a--) {
        if (e.isFunction(b[a])) {
          return {index:a, callback:b[a]};
        }
      }
    }
    getCbIndex(b, a) {
      return 0 < a.length && e.isFunction(a[b - 1]) ? b - 1 : 2 < a.length && e.isFunction(a[b - 2]) ? b - 2 : -1;
    }
    get debug() {
      return this.controlParams.isDebugEnabled;
    }
  }
  a.CouchbaseDbTransformer = q;
  class v extends q {
    generateSubstitute(b) {
      const a = this, c = new r.FunctionId(b);
      return function() {
        if (!a.controlParams.active) {
          return h.doInvoke(this, b.origFn, arguments);
        }
        const l = a.controlParams.isDebugEnabled;
        var k = arguments;
        let u, p;
        try {
          const f = a.extractCallback(arguments), h = m.CbData.getData(this._conn), w = d.SubPathContext.getActiveContext();
          if (null != h) {
            if (u = new m.CouchbaseV3Tracker(a, b, h), p = a.tryStartAsyncActivation({functionId:c, category:g.Agent.correlation.MethodCategory.Database, attachmentCreator:u, vPathOption:1}), null != p && (l && g.Logger.debug(`${u} | opened asyncActivation=${p.initiatorActivation} on spc=${w}`), u.activationResult = p, null != f)) {
              u.origCb = f.callback;
              const b = a.wrapCallback(u);
              k[f.index] = b;
              l && g.Logger.debug(`${u} | wrappedCallback=${e.isFunction(f.callback)} at index=${f.index}`);
            }
          } else {
            g.Logger.warning("CouchbaseDbCollectionTransformer | Can not get data");
          }
        } catch (G) {
          f.logAgentException(G);
        }
        k = h.safeInvoke(this, b.origFn, k);
        try {
          null != p && (n.addSample(c), p.initiatorActivationDone(k.exception), l && g.Logger.debug(`${u} | closed asyncActivation=${p.initiatorActivation} on spc=${p.initiatorActivation.spc}`), k.didThrow && null != u.virtualNodeActivation ? (p.vNodeActivation.exitOrException(k.exception), u.virtualNodeActivation.spc.end()) : (u.hasPromiseHandled = null != u.origCb, a.wrapReturnValue(u, k)));
        } catch (G) {
          f.logAgentException(G);
        }
        return k.rethrow();
      };
    }
    wrapReturnValue(b, a) {
      const c = p.PromiseTransformerUtilities.isActuallyAPromise(a.retVal), d = b.debug;
      if (c && !a.didThrow) {
        const c = this;
        a = a.retVal;
        d && g.Logger.debug(`${b} | wrapping returned promise`);
        p.PromiseTransformerUtilities.registerThenWrapper(a, function(a, d, e) {
          return function(a) {
            return c.handleThenCall(this, b, d, a, e, arguments);
          };
        });
      }
    }
    handleThenCall(b, a, d, e, l, k) {
      let u;
      const p = null != a && a.debug;
      try {
        p && g.Logger.debug(`${a} | enter handleThenCall, isCatch=${d}`), a.hasPromiseHandled || (a.virtualNodeActivation.isExited ? (u = x.TransformerBase.createCallbackActivation(a.virtualNodeActivation.spc, new r.FunctionId(l)), a.hasPromiseHandled = null != u, p && null != u && g.Logger.debug(`${a} | opening node=${u.activation}, spc=${u.activation.spc}`)) : (d || null == e || (null != e.value ? a.fillExitData(1) : Array.isArray(e.contents) ? a.fillExitData(e.contents.length) : p && (g.Logger.debug(`\n.\n.\n.\n${a} | How to handle this result type?\n${JSON.stringify(e, 
        void 0, 4)}\n.\n.\n.`), c.fail())), a.virtualNodeActivation.exitOrException(d ? e : void 0), a.virtualNodeActivation.spc.end(), p && g.Logger.debug(`${a} | closing vNode=${a.virtualNodeActivation} and ending spc=${a.virtualNodeActivation.spc} in handleThenCall`))), p && g.Logger.debug(`${a} | Promise handle then call.`);
      } catch (J) {
        f.logAgentException(J);
      }
      b = h.safeInvoke(b, l, k);
      try {
        null != u && (u.done(b.exception), p && g.Logger.debug(`${a} | closing node=${u.activation}, spc=${u.activation.spc}`), u.activation.spc.open && (u.activation.spc.end(), p && g.Logger.debug(`${a} | exiting spc=${u.activation.spc}`))), p && g.Logger.debug(`${a} | exit handleThenCall, didThrow ${b.didThrow}`);
      } catch (J) {
        f.logAgentException(J);
      }
      return b.rethrow();
    }
  }
  a.CouchbaseDbCollectionTransformer = v;
  class D extends q {
    generateSubstitute(b) {
      const a = this, c = new r.FunctionId(b);
      return function() {
        if (!a.controlParams.active) {
          return h.doInvoke(this, b.origFn, arguments);
        }
        let e, l;
        const k = a.debug;
        var u = arguments;
        const p = d.SubPathContext.getActiveContext();
        try {
          const d = this._getClusterConn(), f = m.CbData.getData(d);
          if (null != f) {
            if (e = new m.CouchbaseQueryTracker(a, b, f, u[0].toString()), l = a.tryStartAsyncActivation({functionId:c, category:g.Agent.correlation.MethodCategory.Database, attachmentCreator:e, vPathOption:1}), null != l) {
              e.activationResult = l;
              k && g.Logger.debug(`${e} | opened asyncActivation=${l.initiatorActivation} with vNode=${e.virtualNodeActivation} on spc=${p}`);
              const b = a.extractCallback(u);
              if (null != b) {
                e.origCb = b.callback;
                const c = a.wrapCallback(e);
                u[b.index] = c;
                k && g.Logger.debug(`${e} | wrapped callback`);
              }
            }
          } else {
            k && g.Logger.debug("CouchbaseQueryTransformer | missing data on Cluster connection!");
          }
        } catch (J) {
          f.logAgentException(J);
        }
        u = h.safeInvoke(this, b.origFn, u);
        try {
          null != e && null != l && (k && g.Logger.debug(`${e} | closing initActivation=${l.initiatorActivation} on spc=${l.initiatorActivation.spc}` + `(virtActivation=${l.vNodeActivation})`), l.initiatorActivationDone(u.exception), u.didThrow ? (l.vNodeActivation.exitOrException(u.exception), l.vNodeActivation.spc.end()) : null == e.origCb && a.wrapReturnValue(e, u));
        } catch (J) {
          f.logAgentException(J);
        }
        return u.rethrow();
      };
    }
    wrapReturnValue(b, a) {
      const c = p.PromiseTransformerUtilities.isActuallyAPromise(a.retVal), d = b.debug;
      if (c && !a.didThrow) {
        const c = this;
        a = a.retVal;
        d && g.Logger.debug(`${b} | wrapping returned promise`);
        p.PromiseTransformerUtilities.registerThenWrapper(a, function(a, d, e) {
          return function(a) {
            return c.handleThenCall(this, b, d, a, e, arguments);
          };
        });
      }
    }
    wrapCallback(b) {
      return function(a, c) {
        try {
          null != c && null != c.rows && b.fillExitData(c.rows.length), b.virtualNodeActivation.exitOrException(a), b.virtualNodeActivation.spc.end(), b.debug && g.Logger.debug(`${b} | ending vNode=${b.virtualNodeActivation} and spc=${b.spc} in callback, hasCallback=${null != b.origCb} with err=${null != a}`);
        } catch (L) {
          f.logAgentException(L);
        }
        if (null != b.origCb) {
          var d = b.virtualNodeActivation.spc;
          try {
            var e = new r.FunctionId(b.origCb);
            var l = x.TransformerBase.createCallbackActivation(d, e);
            b.debug && g.Logger.debug(`${b} | created callbackActivation=${l} on spc=${d} for fnId=${e}`);
          } catch (L) {
            f.logAgentException(L);
          }
          e = h.safeInvoke(this, b.origCb, arguments);
          try {
            null != l && (l.done(e.exception), b.debug && g.Logger.debug(`${b} | finished callbackActivation=${l} on spc=${d}`));
          } catch (L) {
            f.logAgentException(L);
          }
          return e.rethrow();
        }
      };
    }
    handleThenCall(b, a, c, d, e, l) {
      let k;
      const u = a.virtualNodeActivation.spc;
      try {
        if (!a.virtualNodeActivation.isExited) {
          c || null == d || null == d.rows || a.fillExitData(d.rows.length), a.virtualNodeActivation.exitOrException(c ? d : void 0), a.virtualNodeActivation.spc.end(), a.debug && g.Logger.debug(`${a} | ending vNode=${a.virtualNodeActivation}` + ` and spc=${a.spc} in promise, hasCallback=` + `${null != a.origCb} with err=${c}`);
        } else {
          if (!a.hasPromiseHandled) {
            a.hasPromiseHandled = !0;
            const b = new r.FunctionId(e);
            k = x.TransformerBase.createCallbackActivation(u, b);
            a.debug && g.Logger.debug(`${a} | created callbackActivation=${k} on spc=${u} for fnId=${b} isCatc=${c}`);
          }
        }
      } catch (J) {
        f.logAgentException(J);
      }
      b = h.safeInvoke(b, e, l);
      try {
        null != k && (k.done(b.exception), a.debug && g.Logger.debug(`${a} | finished callbackActivation=${k} on spc=${u}`));
      } catch (J) {
        f.logAgentException(J);
      }
      return b.rethrow();
    }
  }
  a.CouchbaseQueryTransformer = D;
  class C extends q {
    generateSubstitute(b) {
      const a = this, c = new r.FunctionId(b);
      return function() {
        if (!a.controlParams.active) {
          return h.doInvoke(this, b.origFn, arguments);
        }
        const l = a.controlParams.isDebugEnabled;
        var k = arguments;
        let u, p;
        try {
          const f = a.extractCallback(arguments), h = m.CbData.getData(this._conn), q = d.SubPathContext.getActiveContext();
          if (null != h) {
            if (u = new m.CouchbaseSubDocumentTracker(a, b, h, k[1]), p = a.tryStartAsyncActivation({functionId:c, category:g.Agent.correlation.MethodCategory.Database, attachmentCreator:u, vPathOption:1}), null != p && (l && g.Logger.debug(`${u} | opened asyncActivation=${p.initiatorActivation} on spc=${q}`), u.activationResult = p, null != f)) {
              u.origCb = f.callback;
              const b = a.wrapCallback(u);
              k[f.index] = b;
              l && g.Logger.debug(`${u} | wrappedCallback=${e.isFunction(f.callback)} at index=${f.index}`);
            }
          } else {
            g.Logger.warning("CouchbaseSubDocumentTransformer | Can not get data");
          }
        } catch (G) {
          f.logAgentException(G);
        }
        k = h.safeInvoke(this, b.origFn, k);
        try {
          null != p && (n.addSample(c), p.initiatorActivationDone(k.exception), l && g.Logger.debug(`${u} | closed asyncActivation=${p.initiatorActivation} on spc=${p.initiatorActivation.spc}`), k.didThrow && null != u.virtualNodeActivation ? (p.vNodeActivation.exitOrException(k.exception), u.virtualNodeActivation.spc.end()) : (u.hasPromiseHandled = null != u.origCb, a.wrapReturnValue(u, k)));
        } catch (G) {
          f.logAgentException(G);
        }
        return k.rethrow();
      };
    }
    wrapReturnValue(b, a) {
      const c = p.PromiseTransformerUtilities.isActuallyAPromise(a.retVal), d = b.debug;
      if (c && !a.didThrow) {
        const c = this;
        a = a.retVal;
        d && g.Logger.debug(`${b} | wrapping returned promise`);
        p.PromiseTransformerUtilities.registerThenWrapper(a, function(a, d, e) {
          return function(a) {
            return c.handleThenCall(this, b, d, a, e, arguments);
          };
        });
      }
    }
    handleThenCall(b, a, d, e, l, u) {
      let p;
      const m = null != a && a.debug;
      try {
        if (m && g.Logger.debug(`${a} | enter handleThenCall, isCatch=${d}`), a.hasPromiseHandled) {
          m && g.Logger.debug(`${a} | Promise handle then call.`);
        } else {
          if (a.virtualNodeActivation.isExited) {
            p = x.TransformerBase.createCallbackActivation(a.virtualNodeActivation.spc, new r.FunctionId(l)), null != p && (a.hasPromiseHandled = !0, m && g.Logger.debug(`${a} | opening node=${p.activation}, spc=${p.activation.spc}`));
          } else {
            const b = a.errorExtractor(e, e);
            d || null == e || (null != e.value || null != e.cas ? a.fillExitData(1) : Array.isArray(e.contents) ? a.fillExitData(e.contents.length) : Array.isArray(e.results) ? a.fillExitData(e.results.length) : m && (g.Logger.debug(`\n.\n${a} | How to handle this result type?\n${k.QueryNormalizer.normalizeQueryToString(e)}\n.`), c.fail()));
            a.virtualNodeActivation.exitOrException(b);
            a.virtualNodeActivation.spc.end();
            m && g.Logger.debug(`${a} | closing vNode=${a.virtualNodeActivation} and ending spc=${a.virtualNodeActivation.spc} in handleThenCall`);
          }
        }
      } catch (J) {
        f.logAgentException(J);
      }
      b = h.safeInvoke(b, l, u);
      try {
        null != p && (p.done(b.exception), m && g.Logger.debug(`${a} | closing node=${p.activation}, spc=${p.activation.spc}`), p.activation.spc.open && (p.activation.spc.end(), m && g.Logger.debug(`${a} | exiting spc=${p.activation.spc}`)));
      } catch (J) {
        f.logAgentException(J);
      }
      m && g.Logger.debug(`${a} | exit handleThenCall, didThrow ${b.didThrow}`);
      return b.rethrow();
    }
  }
  a.CouchbaseSubDocumentTransformer = C;
  class u extends q {
    generateSubstitute(b) {
      const a = this, c = new r.FunctionId(b);
      return function() {
        if (!a.controlParams.active) {
          return h.doInvoke(this, b.origFn, arguments);
        }
        const l = a.controlParams.isDebugEnabled;
        var k = arguments;
        let u, p;
        try {
          const f = a.extractOptions(b.functionName, k), h = a.extractCallback(k), q = m.CbData.getData(this), n = d.SubPathContext.getActiveContext();
          if (q && null != h) {
            if (u = new m.CouchbaseV2Tracker(a, b, q, f), p = a.tryStartAsyncActivation({functionId:c, category:g.Agent.correlation.MethodCategory.Database, attachmentCreator:u}), null != p) {
              l && g.Logger.debug(`${u} | opened asyncActivation=${p.initiatorActivation} on spc=${n}`);
              u.activationResult = p;
              u.origCb = h.callback;
              const b = a.wrapCallback(u);
              k[h.index] = b;
              l && g.Logger.debug(`${u} | wrappedCallback=${e.isFunction(h.callback)} at index=${h.index}`);
            }
          } else {
            g.Logger.warning("CouchbaseRestTransformer | Bucket exists which hasn't been patched: " + `this=${this}, ` + `this.protoype=${this.prototype}, ` + `this.__proto__=${this.__proto__}, ` + `this.super_=${this.super_}`);
          }
        } catch (G) {
          f.logAgentException(G);
        }
        k = h.safeInvoke(this, b.origFn, k);
        try {
          null != p && (n.addSample(c), p.initiatorActivationDone(k.exception), l && g.Logger.debug(`${u} | closed asyncActivation=${p.initiatorActivation} on spc=${p.initiatorActivation.spc}`), k.didThrow && null != u.virtualNodeActivation && (p.vNodeActivation.exitOrException(k.exception), u.virtualNodeActivation.spc.end()));
        } catch (G) {
          f.logAgentException(G);
        }
        return k.rethrow();
      };
    }
    extractOptions(b, a) {
      b = this.getMaxArgumentCount(b);
      if (-1 !== b && !(a.length > b || 2 > a.length || b - 1 === a.length)) {
        return a[b - 2];
      }
    }
    getMaxArgumentCount(b) {
      switch(b) {
        case "upsert":
        case "insert":
        case "replace":
        case "append":
        case "prepend":
        case "getAndTouch":
        case "counter":
        case "get":
          return 4;
        case "remove":
        case "getAndLock":
        case "getReplica":
        case "getMulti":
          return 3;
        default:
          return -1;
      }
    }
  }
  a.CouchbaseDbRestTransformer = u;
  class z extends q {
    wrapCallback(b) {
      return function() {
        b.debug && g.Logger.debug(`${b} | entering query callback`);
        let a, c;
        try {
          if (null != b.virtualNodeActivation) {
            if (!b.virtualNodeActivation.isExited) {
              var d = h.doInvoke(b, b.errorExtractor, arguments);
              null == d && (b.debug && g.Logger.debug(`${b} | filling exit data in callback`), b.fillExitData());
              b.debug && g.Logger.debug(`${b} | exiting vNode=${b.virtualNodeActivation} with err=${d}`);
              b.virtualNodeActivation.exitOrException(d);
            }
            b.injectedCallback || (a = new r.FunctionId(b.origCb), c = x.TransformerBase.createCallbackActivation(b.virtualNodeActivation.spc, a), null != c ? b.debug && g.Logger.debug(`${b} | creating callback node for function ${b.origCb.name}. spc=${c.activation.spc}`) : b.debug && g.Logger.debug(`${b} | could not create callback method activation`));
          }
        } catch (H) {
          f.logAgentException(H);
        }
        d = h.safeInvoke(this, b.origCb, arguments);
        try {
          null != b.virtualNodeActivation && (null != c && (b.debug && g.Logger.debug(`${b} | closing callback node.`), n.addSample(a), c.done(d.exception)), b.virtualNodeActivation.spc.end());
        } catch (H) {
          f.logAgentException(H);
        }
        return d.rethrow();
      };
    }
    generateSubstitute(b) {
      const a = this, c = this.getQueryType(b.functionName), l = new r.FunctionId(b);
      return function() {
        if (!a.controlParams.active) {
          return h.doInvoke(this, b.origFn, arguments);
        }
        const k = a.debug;
        var u = arguments;
        let p, q;
        try {
          const f = u[Math.max(0, u.length - 3)];
          let h = u[u.length - 1];
          e.isFunction(h) || (h = void 0);
          const n = m.CbData.getData(this), r = d.SubPathContext.getActiveContext();
          n ? (n.setQueryhosts(this.queryhosts) && n.setData(this), p = new m.CouchbaseV2QueryTracker(a, b, n, f, 2 === c ? `${u[1]}.${u[2]}` : ""), q = a.tryStartAsyncActivation({functionId:l, category:g.Agent.correlation.MethodCategory.Database, attachmentCreator:p, vPathOption:1}), null != q && (k && g.Logger.debug(`${p} | opened asyncActivation=${q.initiatorActivation} on spc=${r}`), p.activationResult = q, null != h ? (p.origCb = h, p.injectedCallback = !1, p.hasCallback = !0, h = a.wrapCallback(p), 
          u[u.length - 1] = h) : (p.hasCallback = !1, p.injectedCallback = !1, p.origCb = void 0), k && g.Logger.debug(`${p} | hasCallback=${p.hasCallback},injectedCallback=${p.injectedCallback}`))) : g.Logger.warning("CouchbaseLegacyQueryTransformer | Bucket exists which hasn't been patched: " + `this=${this}, ` + `this.protoype=${this.prototype}, ` + `this.__proto__=${this.__proto__}, ` + `this.super_=${this.super_}`);
        } catch (J) {
          f.logAgentException(J);
        }
        u = h.safeInvoke(this, b.origFn, u);
        try {
          null != q && (n.addSample(l), a.wrapReturnValue(p, u), q.initiatorActivationDone(u.exception), k && g.Logger.debug(`${p} | closed asyncActivation=${q.initiatorActivation} on spc=${q.initiatorActivation.spc}`), u.didThrow && (q.vNodeActivation.exitOrException(u.exception), q.vNodeActivation.spc.end()));
        } catch (J) {
          f.logAgentException(J);
        }
        return u.rethrow();
      };
    }
    wrapReturnValue(a, c) {
      a.debug && g.Logger.debug(`${a} | trying to register EmitterTransformer on response object. didThrow=${c.didThrow}`);
      if (!c.didThrow) {
        a.setTracker(c.retVal);
        c.retVal.on("row", m.CouchbaseV2QueryTracker.onRow);
        const d = new A(this.controlParams, a.hasCallback);
        c = new b.ModuleSpec("Readable", c.retVal);
        d.applyTransformation(c);
        a.debug && g.Logger.debug(`${a} | registered EmitterTransformer on response object`);
      }
    }
    getQueryType(b) {
      let a = 4;
      switch(b) {
        case "_n1ql":
          a = 1;
          break;
        case "_view":
          a = 2;
          break;
        case "_fts":
          a = 0;
          break;
        case "_cbas":
          a = 3;
          break;
        default:
          this.isDebugEnabled && g.Logger.warning(`Unrecognized query type, got=${b}`);
      }
      return a;
    }
  }
  a.CouchbaseLegacyQueryTransformer = z;
  class B extends q {
    generateSubstitute(b) {
      const a = this, c = new r.FunctionId(b);
      return function(l, k) {
        if (!a.controlParams.active) {
          return h.doInvoke(this, b.origFn, arguments);
        }
        const u = a.debug;
        var p = arguments;
        let q, r;
        try {
          const f = m.CbData.getData(this), h = d.SubPathContext.getActiveContext();
          f && null != k ? (q = new m.CouchbaseBuilderTracker(a, b, f, l.data), r = a.tryStartAsyncActivation({functionId:c, category:g.Agent.correlation.MethodCategory.Database, attachmentCreator:q}), null != r && (u && g.Logger.debug(`${q} | opened asyncActivation=${r.initiatorActivation} on spc=${h}`), q.activationResult = r, q.origCb = k, k = a.wrapCallback(q), p[p.length - 1] = k, u && g.Logger.debug(`${q} | wrappedCallback=${e.isFunction(k)}`))) : g.Logger.warning("CouchbaseBuilderTransformer | Bucket exists which hasn't been patched: " + 
          `this=${this}, ` + `this.protoype=${this.prototype}, ` + `this.__proto__=${this.__proto__}, ` + `this.super_=${this.super_}`);
        } catch (N) {
          f.logAgentException(N);
        }
        p = h.safeInvoke(this, b.origFn, p);
        try {
          null != r && (n.addSample(c), r.initiatorActivationDone(p.exception), u && g.Logger.debug(`${q} | closed asyncActivation=${r.initiatorActivation} on spc=${r.initiatorActivation.spc}`), p.didThrow && (r.vNodeActivation.exitOrException(p.exception), r.vNodeActivation.spc.end()));
        } catch (N) {
          f.logAgentException(N);
        }
        return p.rethrow();
      };
    }
  }
  a.CouchbaseBuilderTransformer = B;
  class A extends l.EventEmitterTransformerBase {
    constructor(b, a) {
      super(b, a ? ["error", "end", "rows"] : ["error", "end"]);
    }
    shallWrap(b) {
      return null != m.CouchbaseV2QueryTracker.getTracker(b);
    }
    getWrappedListener(b, a, c) {
      const d = this, k = m.CouchbaseV2QueryTracker.getTracker(b);
      if (null == k) {
        return c;
      }
      k.debug && g.Logger.debug(`${k} | wrapping ${c.name} for event ${a.toString()}`);
      const u = l.EventEmitterTransformerBase.getUnwrappedListener(c);
      return function(l) {
        const k = new r.FunctionId(u);
        let p;
        const q = m.CouchbaseV2QueryTracker.getTracker(b);
        try {
          if (null != q) {
            if (null != q.virtualNodeActivation) {
              if (q.virtualNodeActivation.isExited || (e.isError(l) ? (q.virtualNodeActivation.methodException(l), d.debug && g.Logger.debug(`${q} | exiting vNode=${q.virtualNodeActivation} for event=${a.toString()} with exception=${l} on spc=${q.virtualNodeActivation.spc}`)) : (q.fillExitData(), q.debug && g.Logger.debug(`${q} | filled exit data in ${a.toString()} event`), q.virtualNodeActivation.exit(), d.debug && g.Logger.debug(`${q} | exiting vNode=${q.virtualNodeActivation} for event=${a.toString()} on spc=${q.virtualNodeActivation.spc}`)), 
              q.virtualNodeActivation.spc.end(), q.debug && g.Logger.debug(`${q} | exiting spc=${q.virtualNodeActivation.spc}`)), p = x.TransformerBase.createCallbackActivation(q.virtualNodeActivation.spc, k), d.debug) {
                var z = p ? p.activation : void 0;
                g.Logger.debug(`${q} | entered ${a.toString()}-event activation=${z} on spc=${z ? z.spc : void 0}`);
              }
            } else {
              d.debug && g.Logger.debug(`${q} | on spc=${q.spc} has no virtualNodeActivation`);
            }
          } else {
            d.debug && g.Logger.debug("CouchbaseEmitterTransformer | emitter did not have tracker embedded.");
          }
        } catch (R) {
          f.logAgentException(R);
        }
        z = h.safeInvoke(this, c, arguments);
        try {
          null != q && q.debug && g.Logger.debug(`${q} | handled ${a.toString()} event(${c.name}). didThrow=${z.didThrow}`), c === u && n.addSample(k), null != p && (p.done(z.exception), null != q && q.debug && g.Logger.debug(`${q} | exiting ${p.activation} on spc=${p.activation.spc} didThrow=${z.didThrow}`));
        } catch (R) {
          f.logAgentException(R);
        }
        return z.rethrow();
      };
    }
    get debug() {
      return this.controlParams.isDebugEnabled;
    }
  }
  a.CouchbaseEmitterTransformer = A;
  a.dtBucket = function(b) {
    const a = new this.__proto__.constructor(b);
    m.CbData.createV2(b).setData(a);
    return a;
  };
  a.dtConnection = function(b) {
    const a = new this.__proto__.constructor(b);
    m.CbData.createV3(b).setData(a);
    return a;
  };
});
S("src/lib/sensors/CouchbaseDbSensor", "require exports semver src/lib/Agent src/lib/Patch src/lib/sensors/SensorBase src/lib/Debug src/lib/transformer/CouchbaseDbTransformer src/lib/transformer/ContextPassingTransformer src/lib/sensors/CouchbaseAttachment".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class r extends k.SensorBase {
    applyInstrumentation(b) {
      var a = b.moduleInfo.version;
      e.satisfies(a, ">=2.4.0") ? (this.isDebugEnabled && h.Logger.debug(`Found version couchbase module: ${a}, sensor is ${this.active ? "en" : "dis"}abled`), a = e.satisfies(a, ">=3.0.0"), this.isDebugEnabled && h.Logger.debug(`${this.name}: patching ${b.request}`), a ? this.applyInstrumentationPost3(b) : this.applyInstrumentationPre3(b)) : h.Logger.info(`Found unsupported version of ${this.name}. Support starts with version ${"2.4.0"}, but is ${a}!`);
    }
    applyInstrumentationPost3(b) {
      if (b.matchRequestPattern("collection")) {
        let d = new m.CouchbaseDbCollectionTransformer(this);
        for (var a of "upsert insert remove replace _binaryAppend _binaryPrepend _counter get getAndLock getAndTouch _getReplica exists".split(" ")) {
          var c = this.patchFunction(a, d, b.moduleExports.prototype);
          this._debugOutput(c, a);
        }
        d = new m.CouchbaseSubDocumentTransformer(this);
        for (var e of ["lookupIn", "mutateIn"]) {
          c = this.patchFunction(e, d, b.moduleExports.prototype), this._debugOutput(c, e);
        }
      } else {
        if (b.matchRequestPattern("connection")) {
          a = b.moduleExports, m.dtConnection.prototype = a.prototype, b.moduleExports = m.dtConnection, e = new f.SubstitutedFnDescriptor(new f.FunctionSpec("Connection", "", b.moduleExports, "couchbase"), a, !1), f.tag(e, b.moduleExports, a), this._debugOutput(!0, "Connection constructor");
        } else {
          if (b.matchRequestPattern("cluster")) {
            e = new m.CouchbaseQueryTransformer(this);
            for (c of ["analyticsQuery", "query", "searchQuery"]) {
              a = this.patchFunction(c, e, b.moduleExports.prototype), this._debugOutput(a, c);
            }
          }
        }
      }
    }
    applyInstrumentationPre3(b) {
      var a = e.satisfies(b.moduleInfo.version, ">=2.6.0");
      this.isDebugEnabled && h.Logger.debug(`AnalyticsQuery ${a ? "en" : "dis"}abled`);
      if (b.matchRequest("couchbase")) {
        var l = new m.CouchbaseDbRestTransformer(this);
        for (const a of "upsert insert remove replace append prepend counter".split(" ")) {
          var k = this.patchFunction(a, l, b.moduleExports.BucketImpl.prototype);
          this._debugOutput(k, a);
        }
        for (const a of ["get", "getAndLock", "getAndTouch", "getReplica", "getMulti"]) {
          k = this.patchFunction(a, l, b.moduleExports.BucketImpl.prototype), this._debugOutput(k, a);
        }
        l = new g.ContextPassingTransformer(this);
        k = this.patchFunction("openBucket", l, b.moduleExports.Cluster.prototype);
        this._debugOutput(k, "openBucket");
        for (var p of ["disconnect"]) {
          k = this.patchFunction(p, l, b.moduleExports.BucketImpl.prototype), this._debugOutput(k, p);
        }
        p = new m.CouchbaseLegacyQueryTransformer(this);
        k = ["_n1ql", "_view", "_fts"];
        a && k.push("_cbas");
        for (var q of k) {
          k = this.patchFunction(q, p, b.moduleExports.BucketImpl.prototype), this._debugOutput(k, `Bucket::${q}`);
        }
        q = ["_n1ql", "_fts"];
        a && q.push("_cbas");
        for (var n of q) {
          k = this.patchFunction(n, p, b.moduleExports.Cluster.prototype), this._debugOutput(k, `Cluster::${n}`);
        }
        l = new m.CouchbaseBuilderTransformer(this);
        for (const a of ["_mutateIn", "_lookupIn"]) {
          k = this.patchFunction(a, l, b.moduleExports.BucketImpl.prototype), this._debugOutput(k, a);
        }
      }
      b.matchRequestPattern("bucket") && (a = b.moduleExports, m.dtBucket.prototype = a.prototype, b.moduleExports = m.dtBucket, n = new f.SubstitutedFnDescriptor(new f.FunctionSpec("Bucket", "", b.moduleExports, "couchbase"), a, !1), f.tag(n, b.moduleExports, a), this._debugOutput(!0, "Bucket constructor"));
      b.matchRequestPattern("connstr") && (c.CbData.connStr = b.moduleExports, c.CbData.debug = this.isDebugEnabled, null == b.moduleExports.normalize && h.Logger.warning(`Found connstr module without normalize method, cbVersion=${b.moduleInfo.version}`), this.isDebugEnabled && h.Logger.debug("Using couchbases connstr to parse URLs."));
    }
    patchFunction(b, a, c) {
      b = new f.FunctionSpec(b, "", c, f.AsyncTrackingMode.CallbackLast, "couchbase");
      return void 0 !== f.applyToSingle(b, a);
    }
    _debugOutput(b, a) {
      this.isDebugEnabled && b ? h.Logger.debug(`        patched ${a}`) : b || (h.Logger.warning(`could not patch ${a}`), n.fail());
    }
  }
  a.CouchbaseDbSensor = r;
});
S("src/lib/sensors/AwsSdkSensor", "require exports src/lib/sensors/SensorBase src/lib/Agent src/lib/AttachmentBase src/lib/CallbackWrappingHelper src/lib/Debug src/lib/FunctionId src/lib/Patch src/lib/SubPathContext src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/Tracing src/lib/util/HttpHeader src/lib/util/InvocationUtil src/lib/transformer/TransformerBase".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class q {
    constructor(b, a, c) {
      this.cc = b;
      this.origCcStr = a;
      this.isDebugEnabled = c;
    }
    static fromBase64(b, a = !1) {
      let c;
      if (null != b) {
        try {
          const d = Buffer.from(b, "base64").toString();
          a && h.Logger.debug(`ClientContextManipulator: modifying application client context '${d}'`);
          c = JSON.parse(d);
        } catch (B) {
          a && h.Logger.debug(`ClientContextManipulator: failed to parse existing client context (${B})`);
        }
      } else {
        c = Object.create(null);
      }
      return new q(c, b, a);
    }
    static fromClientContext(b, a = !1) {
      return new q(b, void 0, a);
    }
    getTag() {
      const b = this.getCustomProp();
      return null != b ? b[q.cDtTagPropertyName] : void 0;
    }
    extractTag() {
      const b = this.getTag();
      if (null != b) {
        try {
          delete this.getCustomProp()[q.cDtTagPropertyName];
        } catch (u) {
        }
      }
      return b;
    }
    setTag(b) {
      if (null != this.cc) {
        try {
          const a = this.getCustomProp();
          null == a ? (this.cc.custom = Object.create(null), this.cc.custom[q.cDtTagPropertyName] = b) : !Array.isArray(a) && r.isObject(a) ? a[q.cDtTagPropertyName] = b : this.isDebugEnabled && h.Logger.debug(`ClientContextManipulator: tag not set. Custom isArray - typeof Custom=${typeof a}`);
        } catch (u) {
          this.isDebugEnabled && h.Logger.debug(`ClientContextManipulator: error setting tag '${u}'`);
        }
      }
    }
    toBase64() {
      if (null == this.cc) {
        return this.origCcStr;
      }
      let b;
      try {
        const a = Buffer.from(JSON.stringify(this.cc));
        this.isDebugEnabled && h.Logger.debug(`ClientContextManipulator: modified client context '${a.toString()}'`);
        b = a.toString("base64");
        b.length >= q.cClientContextLengthMax && (this.isDebugEnabled && h.Logger.info(`ClientContextManipulator: exceeded length limit embedding to ClientContext (${b.length})`), b = this.origCcStr);
      } catch (u) {
        this.isDebugEnabled && h.Logger.debug(`ClientContextManipulator: embedding to ClientContext failed with ${u}`);
      }
      return b;
    }
    getCustomProp() {
      return null != this.cc ? this.cc.custom || this.cc.Custom : void 0;
    }
  }
  a.ClientContextManipulator = q;
  q.cDtTagPropertyName = "dynatrace-link";
  q.cClientContextLengthMax = 3583;
  class v extends p.TransformerBase {
    constructor(b) {
      super(b);
      h.Logger.info(`AwsSdk: cRequestIdBase=${v.cRequestIdBase}`);
    }
    createAttachments(b) {
      this.attachment = new f.AttachmentBase(b, h.Agent.correlation.AttachmentId.ATTACHMENT_AWS_LAMBDA_CLIENT_ID, 0);
    }
    generateSubstitute(a) {
      const e = this, f = new m.FunctionId(a);
      return function() {
        e.isDebugEnabled && h.Logger.debug(`${e.toString(this)} enter Request.send api=${this.service.api.apiVersion} svc=${this.service.serviceIdentifier} op=${this.operation}, type=${this.params.InvocationType}`);
        if (e.doIgnoreRequest(this)) {
          return e.isDebugEnabled && h.Logger.debug(`${e.toString(this)} ignoring ${e.controlParams.active ? "sensor inactive" : "not a targeted request"}`), x.doInvoke(this, a.origFn, arguments);
        }
        var g = "invoke" === this.operation || null == this.params.InvocationType || "RequestResponse" === this.params.InvocationType;
        let l, k, u = arguments, p;
        try {
          let b;
          l = e.tryStartAsyncActivation({functionId:f, attachmentCreator:e});
          if (null != l) {
            b = l.vNodeActivation.spc.createAddSerializeLink(g, h.Agent.correlation.TaggingMode.DT_ONLY);
            if (e.isDebugEnabled) {
              const a = d.Tracing.traceContextToString(b);
              h.Logger.debug(`${e.toString(this)} ${l}, tag: ${a}, att: ${e.attachment}`);
            }
            k = this.params.ClientContext;
            if (null != b && null != b.dtTag) {
              const a = q.fromBase64(this.params.ClientContext, e.isDebugEnabled);
              a.setTag(b.dtTag);
              this.params.ClientContext = a.toBase64();
            }
            null != e.attachment && (p = e.attachment, e.attachment = void 0, e.fillAttachmentFieldsFromRequest(p, this), this.on("httpHeaders", e.makeHttpHeadersEventHandler(p)));
            0 < u.length ? r.isFunction(u[0]) ? u[0] = e.wrapCallback(l, u[0]) : e.isDebugEnabled && h.Logger.debug(`${e.toString(this)} argument[0] is not a function (${u[0]})`) : u = [e.wrapCallback(l)];
          } else {
            e.isDebugEnabled && h.Logger.debug(`${e.toString(this)} no method activation, active spc: ${c.SubPathContext.getActiveContext()}`);
          }
        } catch (O) {
          b.logAgentException(O);
        }
        g = x.safeInvoke(this, a.origFn, u);
        if (null != l) {
          try {
            g.didThrow && e.closeAsyncPath(l.vNodeActivation, g.exception), l.initiatorActivationDone(g.exception), null != k ? this.params.ClientContext = k : delete this.params.ClientContext;
          } catch (O) {
            b.logAgentException(O);
          }
          e.isDebugEnabled && h.Logger.debug(`${e.toString(this)} exit Request.send`);
        }
        return g.rethrow();
      };
    }
    toString(b) {
      return null == b ? "AwsSdk:" : `AwsSdk(${b.startTime.valueOf() - v.cRequestIdBase}):`;
    }
    doIgnoreRequest(b) {
      return !this.controlParams.active || b.service.serviceIdentifier !== v.cLambdaServiceIdentifier || !v.cSupportedApiVersions.some(a => a === b.service.api.apiVersion) || "invoke" !== b.operation || "DryRun" === b.params.InvocationType;
    }
    wrapCallback(b, a) {
      const c = null != a;
      c || (a = v.dtInjectedSendCallback);
      return k.CallbackWrappingHelper.wrapCallbackCreateActivation({injectedCallback:!c, virtualNodeActivation:b.vNodeActivation, origCb:a, errorExtractor:b => b});
    }
    makeHttpHeadersEventHandler(a) {
      const c = this;
      return function(d, e) {
        try {
          c.isDebugEnabled && h.Logger.debug(`${c.toString(this)} httpHeaders event`), c.fillAttachmentFieldsFromResponseHeaders(a, this, e);
        } catch (A) {
          b.logAgentException(A);
        }
      };
    }
    fillAttachmentFieldsFromRequest(b, a) {
      const c = this.parseFunctionName(`${a.params.FunctionName}`), d = `${a.httpRequest.region}`, e = h.Agent.correlation.AttachmentFieldId;
      b.setStringCached(e.AWS_LAMBDA_CLIENT_FUNCTION_NAME, c);
      b.setStringCached(e.AWS_LAMBDA_CLIENT_REGION, d);
      this.isDebugEnabled && h.Logger.debug(`${this.toString(a)} attachment FnName=${c}, region=${d}`);
    }
    fillAttachmentFieldsFromResponseHeaders(b, a, c) {
      (new l.HeadersObjectManipulator(c, 0, !1)).forMatching(v.headerData, (c, d, e) => {
        b.setString(e.associatedData(), c.firstValue);
        this.isDebugEnabled && h.Logger.debug(`${this.toString(a)} attachment ${c.rawName}=${c.firstValue}`);
      });
    }
    closeAsyncPath(a, c) {
      if (null != a) {
        try {
          this.controlParams.isDebugEnabled && h.Logger.debug(`${this} closeAsyncPath spc: ${a.spc}, err: ${b.verboseExceptionObject(c)}`), a.exitOrException(c), a.spc.end();
        } catch (z) {
          b.logAgentException(z);
        }
      }
    }
    parseFunctionName(b) {
      var a = b.split(":");
      1 === a.length ? a = b : "arn" === a[0] ? a = 7 <= a.length && "function" === a[5] && "lambda" === a[2] ? a[6] : b : 2 === a.length ? a = a[1] : (a = b, this.isDebugEnabled && h.Logger.debug(`${this} malformed function name '${b}'`));
      this.isDebugEnabled && b !== a && h.Logger.debug(`${this} parsed '${a}' from '${b}'`);
      return a;
    }
    static dtInjectedSendCallback() {
    }
  }
  a.AwsSdkRequestTransformer = v;
  v.cLambdaServiceIdentifier = "lambda";
  v.cRequestIdBase = Date.now().valueOf();
  v.cSupportedApiVersions = ["2015-03-31"];
  v.headerData = [new l.HeaderAssociatedData("x-amzn-trace-id", () => h.Agent.correlation.AttachmentFieldId.AWS_LAMBDA_CLIENT_TRACE_ID), new l.HeaderAssociatedData("x-amzn-requestid", () => h.Agent.correlation.AttachmentFieldId.AWS_LAMBDA_CLIENT_REQUEST_ID)];
  class D extends e.SensorBase {
    applyInstrumentation(b, a) {
      "AwsSdk.Core" === a ? (b = new g.FunctionSpec("send", b.request, b.moduleExports.Request.prototype, g.AsyncTrackingMode.CallbackFirst, "http"), g.applyToSingle(b, new v(this))) : n.fail(`AwsSdkSensor: unexpected rule key ${a}`);
    }
  }
  a.AwsSdkSensor = D;
});
S("src/lib/sensors/AwsLambdaSensor", "require exports path src/lib/transformer/TransformerBase src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/Agent src/lib/AttachmentBase src/lib/FunctionId src/lib/sensors/SensorBase src/lib/sensors/SensorConstants src/lib/sensors/AwsSdkSensor src/lib/RunTimeProperty src/lib/util/ErrorUtil src/lib/Patch".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class q {
    constructor(b, a) {
      this.lambdaContext = b;
      this.lambdaEvent = a;
      this.tsStart = f.getTimeStamp();
    }
    get duration() {
      return f.getDurationMillis(this.tsStart);
    }
  }
  a.InvocationContext = q;
  class v {
    constructor(a) {
      this.propPath = a;
      this.lookupTag = a[a.length - 1].toLowerCase() === b.cHttpTaggingHeader ? this.lookupHeaderAuthoredPropertyPath : this.lookupExactPropertyPath;
    }
    toString() {
      return this.propPath.join(".");
    }
    lookupExactPropertyPath(b) {
      return f.getPropertyByPath(b, this.propPath);
    }
    lookupHeaderAuthoredPropertyPath(a) {
      for (var c = 0; null != a;) {
        const d = this.propPath[c];
        if (c === this.propPath.length - 1) {
          return c = Object.keys(a).find(a => a.toLowerCase() === b.cHttpTaggingHeader), null != c ? a[c] : void 0;
        }
        a = a[d];
        ++c;
      }
    }
  }
  a.AwsLambdaDtTagPropertyPath = v;
  class D extends h.TransformerBase {
    constructor(a) {
      super(a);
      this.onBeforeExit = () => {
        this.isDebugEnabled && m.Logger.debug(`${this}: beforeExit enter`);
        this.onEndOfInvocation();
      };
      this.dtTagEventPropertyPath = [new v(["headers", b.cHttpTaggingHeader]), new v(["params", "header", b.cHttpTaggingHeader])];
      this.invocationCount = 0;
      a = m.Agent.agentInitOptions.dynatraceTagPropertyPath;
      if (f.isString(a)) {
        const b = a.split(".");
        0 < b.length ? this.dtTagEventPropertyPath.unshift(new v(b)) : m.Logger.info(`\u00b4Lambda: invalid dynatraceTagPropertyPath: '${a}'`);
      }
    }
    createAttachments(b) {
      const a = this.currentInvocation;
      if (null != a) {
        const c = a.lambdaContext;
        this.isDebugEnabled && m.Logger.debug(`${this}: creating service attachment with fnName=${c.functionName}, fnArn=${c.invokedFunctionArn}`);
        b = new g.AttachmentBase(b, m.Agent.correlation.AttachmentId.ATTACHMENT_AWS_LAMBDA_SERVICE_ID, 0);
        const d = m.Agent.correlation.AttachmentFieldId;
        b.setMultipleFields(b => {
          b.stringCached(d.AWS_LAMBDA_SERVICE_FUNCTION_NAME, c.functionName);
          b.stringCached(d.AWS_LAMBDA_SERVICE_INVOKED_FUNCTION_ARN, c.invokedFunctionArn);
          b.stringCached(d.AWS_LAMBDA_SERVICE_ACCOUNT_ID, this.getAccountIdFromArn(c.invokedFunctionArn));
          b.stringCached(d.AWS_LAMBDA_SERVICE_REGION, D.getRegionName());
        });
      } else {
        m.Logger.info(`${this}: createAttachment w/o context object`);
      }
    }
    transform(b) {
      const a = this, d = new c.FunctionId(b);
      this.installBeforeExitHandler();
      return function(...c) {
        let e;
        ++a.invocationCount;
        const g = c[0], l = c[1], h = c[2];
        try {
          null != a.currentInvocation && (m.Logger.warning(`${this}: context of previous invocation leaked or parallel invocations`), a.closeVNodeActivation(), a.currentInvocation = void 0);
          a.isDebugEnabled && m.Logger.debug(`${a}: handler enter fn=${l.functionName}@${l.functionVersion}, reqId=${l.awsRequestId}`);
          if (1 === a.invocationCount) {
            a.onInitialInvocation(l);
          }
          const b = a.lookupTag(g, l);
          let k;
          f.isString(b) && (k = m.Agent.correlation.deserializeLinkFromString(b));
          a.currentInvocation = new q(l, g);
          e = a.tryStartIncomingAsyncSubPath({functionId:d, link:k, attachmentCreator:a});
          null != e ? (a.patchContextFunctions(l), a.currentInvocation.vNodeActivation = e.vNodeActivation, null != h && (c[2] = a.wrapFnDoneHandler(h, "callback", l.callbackWaitsForEmptyEventLoop))) : a.currentInvocation = void 0;
        } catch (H) {
          k.logAgentException(H);
        }
        c = n.safeInvoke(this, b, c);
        try {
          if (null != e && (a.isDebugEnabled && m.Logger.debug(`${a}: closing initiator activation and path ${e.initiatorActivation} with rc.exception=${c.exception}`), e.initiatorActivationDone()), c.didThrow) {
            a.onEndOfInvocation(c.exception);
          }
        } catch (H) {
          k.logAgentException(H);
        }
        a.isDebugEnabled && m.Logger.debug(`${a}: handler exit`);
        return c.rethrow();
      };
    }
    toString() {
      return `Lambda[${this.invocationCount}]`;
    }
    installBeforeExitHandler() {
      process.prependListener("beforeExit", this.onBeforeExit);
    }
    onInitialInvocation(b) {
      this.isDebugEnabled && (m.Logger.debug(`${this}: onInitialInvocation (${b.invokedFunctionArn})`), Object.getOwnPropertyNames(process.env).forEach(b => {
        /(LAMBDA|AWS|HANDLER)/.test(b) && m.Logger.debug(`${this}: ${b}='${process.env[b]}'`);
      }));
      m.Agent.nativeAgent.setAwsLambdaFunctionInfo(`${b.invokedFunctionArn}`);
    }
    getAccountIdFromArn(b) {
      const a = b.split(":");
      5 <= a.length ? b = a[4] : (this.isDebugEnabled && m.Logger.info(`${this}: failed to parse account id from function ARN '${b}'`), b = "");
      return b;
    }
    static getRegionName() {
      return process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION || "";
    }
    isProxyIntegrationEvent(b) {
      let a = 0;
      return D.cProxyIntegrationEventPropNames.some(c => {
        null != b[c] && ++a;
        return a >= D.cMinMatchingProxyIntegrationEventPropNames;
      });
    }
    onEndOfInvocation(b) {
      if (null != this.currentInvocation) {
        try {
          this.isDebugEnabled && m.Logger.debug(`${this}: onEndOfInvocation enter`);
          this.closeVNodeActivation(b);
          const a = !D.disableFlushOnEndOfFunction.value;
          this.isDebugEnabled && m.Logger.debug(`${this}: flushing message queues${a ? "" : " is disabled"}`);
          if (a) {
            m.Agent.nativeAgent.onPotentialSuspension();
          }
          this.isDebugEnabled && m.Logger.debug(`${this}: queue ${a ? "" : "not "}flushed. calling original function, ${this.currentInvocation.duration}ms function execution duration`);
        } catch (z) {
          x.logAgentException(z);
        } finally {
          this.currentInvocation = void 0;
        }
      }
    }
    onLambdaFnDone(b, a, c, d) {
      if (null != this.currentInvocation) {
        try {
          if (this.isDebugEnabled && m.Logger.debug(`${this}: ${b} error=${c}`), null != this.currentInvocation.vNodeActivation) {
            b = c;
            const e = this.currentInvocation.lambdaEvent;
            if (null != e && null != d && null == b && this.isProxyIntegrationEvent(e)) {
              this.isDebugEnabled && m.Logger.debug(`${this}: API GW proxy integration event`);
              this.isDebugEnabled && m.Logger.debug(`${this}: proxy integration statusCode=${d.statusCode}`);
              const a = this.extractProxyIntegrationResultStatusCode(d);
              !Number.isNaN(a) && (100 > a || 399 < a) && (b = `Failed with status code ${a}`);
            }
            if (a) {
              this.onEndOfInvocation(b);
            } else {
              this.closeVNodeActivation(b);
            }
          } else {
            this.isDebugEnabled && m.Logger.debug(`${this}: ${b} - vnode already closed`);
          }
        } catch (w) {
          k.logAgentException(w);
        }
      }
    }
    closeVNodeActivation(b) {
      if (null != this.currentInvocation) {
        var a = this.currentInvocation.vNodeActivation;
        if (null != a) {
          try {
            this.isDebugEnabled && m.Logger.debug(`${this}: closing virtual activation ${a}, error=${b}`), a.exitOrException(b);
          } catch (B) {
            k.logAgentException(B);
          } finally {
            this.currentInvocation.vNodeActivation = void 0;
          }
        } else {
          this.isDebugEnabled && m.Logger.debug(`${this}: no pending virtual activation`);
        }
      }
    }
    wrapFnDoneHandler(b, a, c) {
      const d = this;
      return function(e, f) {
        d.onLambdaFnDone(a, c, e, f);
        return n.doInvoke(this, b, arguments);
      };
    }
    patchContextFunctions(b) {
      const a = this;
      if (f.isFunction(b.done)) {
        var c = new p.FunctionSpec("done", "Context", b);
        p.substitute(c, this.wrapFnDoneHandler(b.done, "Context.done", !0));
      }
      if (f.isFunction(b.succeed)) {
        const d = b.succeed;
        c = new p.FunctionSpec("succeed", "Context", b);
        p.substitute(c, function(b) {
          a.onLambdaFnDone("Context.succeed", !0, void 0, b);
          return n.doInvoke(this, d, arguments);
        });
      }
      if (f.isFunction(b.fail)) {
        const c = b.fail;
        b = new p.FunctionSpec("fail", "Context", b);
        p.substitute(b, function(b) {
          a.onLambdaFnDone("Context.fail", !0, b, void 0);
          return n.doInvoke(this, c, arguments);
        });
      }
    }
    extractProxyIntegrationResultStatusCode(b) {
      this.isDebugEnabled && m.Logger.debug(`${this}: proxy integration statusCode=${b.statusCode}`);
      return f.isNumber(b.statusCode) ? b.statusCode : +("" + b.statusCode);
    }
    tryGetTagFromEventObject(b) {
      let a, c = 0;
      for (; c !== this.dtTagEventPropertyPath.length;) {
        const d = this.dtTagEventPropertyPath[c];
        a = d.lookupTag(b);
        if (null != a) {
          this.isDebugEnabled && m.Logger.debug(`Lambda: found tag '${a}' at ${d}`);
          break;
        }
        ++c;
      }
      return a;
    }
    lookupTag(b, a) {
      b = this.tryGetTagFromEventObject(b);
      null == b && (this.isDebugEnabled && m.Logger.debug(`${this}: no tag in event.${this.dtTagEventPropertyPath}, trying to extract tag from client context`), b = this.tryGetTagFromClientContext(a));
      null == b || f.isString(b) || (this.isDebugEnabled && m.Logger.debug(`${this}: ignoring non string tag ${b}`), b = void 0);
      return b;
    }
    tryGetTagFromClientContext(b) {
      const a = d.ClientContextManipulator.fromClientContext(b.clientContext).extractTag();
      this.isDebugEnabled && (null != a ? m.Logger.debug(`${this}: tag from context.clientContext=${a}`) : m.Logger.debug(`${this}: no tag in client context '${JSON.stringify(b.clientContext)}'`));
      return a;
    }
  }
  a.AwsLambdaTransformer = D;
  D.cProxyIntegrationEventPropNames = "headers httpMethod isBase64Encoded requestContext path resource".split(" ");
  D.cMinMatchingProxyIntegrationEventPropNames = 4;
  D.disableFlushOnEndOfFunction = new l.BooleanProperty("DisableFlushOnEndOfFunction", !1);
  class C extends r.SensorBase {
    constructor(b, a, c) {
      super(b, a, c);
      this.exportObjectGetter = (b, a) => {
        if (!f.isString(a)) {
          throw Error(`unexpected user handler property key '${String(a)} (${typeof a})'`);
        }
        this.isDebugEnabled && m.Logger.debug(`Lambda: getter for property ${a}`);
        b = /([^$@]+)[$@](.+)/.exec(a);
        if (null == b) {
          throw m.Logger.info(`Lambda: failed to decompose handler name ${a}`), Error(`Dynatrace agent: failed to decompose handler name ${a}`);
        }
        a = this.composeAbsModulePath(b[1]);
        this.isDebugEnabled && m.Logger.debug(`Lambda: requiring user function from ${a} [${b[2]}]`);
        let c;
        try {
          const d = this.require(a);
          c = this.resolveHandler(d, b);
        } catch (K) {
          throw m.Logger.info(`Lambda: failed to require Lambda function: '${K}'`), K;
        }
        return c;
      };
      m.Logger.info(`${this}: Agent.habitat = ${m.Agent.habitat}`);
      if ("AWS.Lambda" === m.Agent.habitat) {
        m.Agent.createAgentResult.createAwsLambdaExportsInterceptor = this.createLambdaFnHandlerInterceptorFn(), m.Logger.info(`${this}: configuring createAgentResult for AWS Lambda`);
      } else {
        if ("AWS.Lambda-Layer" === m.Agent.habitat) {
          const b = new D(this);
          m.Agent.createAgentResult.wrapAwsLambdaHandlerFunction = a => b.transform(a);
          m.Logger.info(`${this}: configuring createAgentResult for AWS Lambda Layer`);
        }
      }
    }
    composeAbsModulePath(b) {
      return e.join(process.env.LAMBDA_TASK_ROOT || "/var/task", b);
    }
    transformHandler(b) {
      let a;
      f.isFunction(b) ? (a = (new D(this)).transform(b), this.isDebugEnabled && m.Logger.info(`${this}: transformed user handler ${b.name}`)) : (a = b, m.Logger.info(`${this}: handler ${b} is not a function`));
      return a;
    }
    resolveHandler(b, a) {
      var c = process.env._HANDLER;
      b = b[a[2]];
      if (null == c) {
        return m.Logger.info(`${this}: _HANDLER is not set`), b;
      }
      this.isDebugEnabled && m.Logger.debug(`${this}: handlerPath='${c}'`);
      var d = c.indexOf(a[0]);
      d + a[0].length < c.length ? (c = c.slice(d + a[0].length + 1), a = c.split("."), this.isDebugEnabled && m.Logger.debug(`${this}: resolving handler from nested export object '${c}'`), c = f.getPropertyByPath(b, a), d = this.transformHandler(c), c !== d && (b = a.reduceRight((b, a) => Object.defineProperty(Object.create(null), a, {value:b}), d))) : (this.isDebugEnabled && m.Logger.debug(`${this}: resolving trivial handler path`), b = this.transformHandler(b));
      return b;
    }
    require(b) {
      return t(b);
    }
    createLambdaFnHandlerInterceptorFn() {
      const b = this;
      return function() {
        return new Proxy(b, {get:b.exportObjectGetter});
      };
    }
  }
  a.AwsLambdaSensor = C;
});
S("src/lib/sensors/MessagingAttachment", ["require", "exports", "src/lib/Agent", "src/lib/AttachmentBase", "src/lib/util/CoreUtil"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k extends h.AttachmentBase {
    constructor(b) {
      super(b, e.Agent.correlation.AttachmentId.ATTACHMENT_MESSAGING_CLIENT_ID, 0);
    }
    fillAttachment(b, a) {
      this.setMultipleFields(d => {
        var f = new c(b, a), g = e.Agent.correlation;
        const l = g.AttachmentFieldId;
        this.setServiceDetectionFeatureFlags(d, l);
        d.integer(l.MESSAGING_NODE_TYPE, g.MessagingMessagetype.AMQP_MESSAGE);
        d.stringCached(l.MESSAGING_NODE_QUEUE_VENDOR, "RabbitMQ");
        d.stringCached(l.MESSAGING_NODE_DESTINATION, f.getDestinationName());
        d.stringCached(l.MESSAGING_NODE_DESTINATION_TYPE, f.getDestinationType());
        d.integer(l.MESSAGING_NODE_SIZE, f.getMsgSize());
        d.integer(l.MESSAGING_NODE_TOPOLOGY, f.getTopology());
        d.stringCached(l.MESSAGING_NODE_HOSTNAME, f.getHostName());
        d.integer(l.MESSAGING_NODE_PORT, f.getPort());
        d.integer(l.MESSAGING_NODE_IS_TEMPORARY_QUEUE, f.isTmpQueue() ? 1 : 0);
        g = f.getCorrelationId();
        null != g && d.string(l.MESSAGING_NODE_VENDOR_CORRELATION_ID, g);
        f = f.getMsgId();
        null != f && d.string(l.MESSAGING_NODE_VENDOR_MESSAGE_ID, f);
      });
    }
    setServiceDetectionFeatureFlags(b, a) {
      b.integer(a.MESSAGING_NODE_WILL_HAVE_DESTINATION_TYPE, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_IPCONTAINER, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_TOPOLOGY, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_TEMPORARY_QUEUE, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_QUEUE_VENDOR_NAME, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_MQ_QUEUE_MANAGER_NAME, 0);
    }
  }
  a.MessagingProducerAttachment = k;
  class n extends h.AttachmentBase {
    constructor(b) {
      super(b, e.Agent.correlation.AttachmentId.ATTACHMENT_MESSAGING_SERVER_ID, 0);
    }
    fillAttachment(b, a) {
      this.setMultipleFields(c => {
        var d = new r(b, a), f = e.Agent.correlation;
        const g = f.AttachmentFieldId;
        this.setServiceDetectionFeatureFlags(c, g);
        c.integer(g.MESSAGING_NODE_TYPE, f.MessagingMessagetype.AMQP_MESSAGE);
        c.stringCached(g.MESSAGING_NODE_QUEUE_VENDOR, "RabbitMQ");
        c.integer(g.MESSAGING_NODE_TRANSMISSION_TYPE, f.TransmissionType.RECEIVE);
        c.stringCached(g.MESSAGING_NODE_DESTINATION, d.getDestinationName());
        c.stringCached(g.MESSAGING_NODE_DESTINATION_TYPE, d.getDestinationType());
        c.integer(g.MESSAGING_NODE_SIZE, d.getMsgSize());
        c.integer(g.MESSAGING_NODE_TOPOLOGY, d.getTopology());
        c.stringCached(g.MESSAGING_NODE_HOSTNAME, d.getHostName());
        c.integer(g.MESSAGING_NODE_PORT, d.getPort());
        c.integer(g.MESSAGING_NODE_IS_TEMPORARY_QUEUE, d.isTmpQueue() ? 1 : 0);
        f = d.getCorrelationId();
        null != f && c.string(g.MESSAGING_NODE_VENDOR_CORRELATION_ID, f);
        d = d.getMsgId();
        null != d && c.string(g.MESSAGING_NODE_VENDOR_MESSAGE_ID, d);
      });
    }
    setServiceDetectionFeatureFlags(b, a) {
      b.integer(a.MESSAGING_NODE_WILL_HAVE_DESTINATION_TYPE, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_IPCONTAINER, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_TOPOLOGY, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_TEMPORARY_QUEUE, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_QUEUE_VENDOR_NAME, 1);
      b.integer(a.MESSAGING_NODE_WILL_HAVE_MQ_QUEUE_MANAGER_NAME, 0);
    }
  }
  a.MessagingConsumerAttachment = n;
  class m {
    constructor(b, a, c) {
      this.host = b;
      this.port = a;
      this.topology = c;
    }
  }
  class g {
    constructor(b) {
      f.hasProperty(b, "connection", "muxer", "out") && (b = b.connection.muxer.out.address(), this.connInfo = null != b ? new m(b.address, b.port, e.Agent.correlation.MessagingTopology.EXTERNAL) : new m("localhost", -1, e.Agent.correlation.MessagingTopology.EMBEDDED));
    }
    getDestinationName() {
      return f.hasProperty(this.fields, "exchange") && 0 < this.fields.exchange.length ? this.fields.exchange : this.fields.routingKey || "";
    }
    getHostName() {
      return null != this.connInfo ? this.connInfo.host : "";
    }
    getPort() {
      return null != this.connInfo ? this.connInfo.port : -1;
    }
    getTopology() {
      return null != this.connInfo ? this.connInfo.topology : e.Agent.correlation.MessagingTopology.NOT_SET;
    }
    isTmpQueue() {
      if (null != this.fields) {
        var b = this.fields.exchange;
        if (null != b && 0 < b.length) {
          return !1;
        }
        b = this.fields.routingKey;
        if (!f.isString(b)) {
          return !1;
        }
        if (b.startsWith("amq.gen") || b.startsWith("amq.rabbitmq.reply-to") || b.match(/^amqpSendAndReceive[0-9a-fA-F]{8}-(?:[a-fA-F0-9]{4}-){3}[a-fA-F0-9]{12}$/)) {
          return !0;
        }
      }
      return !1;
    }
    getDestinationType() {
      if (null != this.fields) {
        var b = this.fields.exchange;
        if (null != b && 0 < b.length) {
          return "Topic";
        }
        b = this.fields.routingKey;
        if (null != b && 0 < b.length) {
          return "Queue";
        }
      }
      return "";
    }
    getMsgSize() {
      return null != this.msgContent ? this.msgContent.length : 0;
    }
  }
  class c extends g {
    constructor(b, a) {
      super(b);
      3 === a.length && (this.fields = a[0], this.msgContent = a[2]);
    }
    getCorrelationId() {
      if (f.hasProperty(this.fields, "correlationId")) {
        return `${this.fields.correlationId}`;
      }
    }
    getMsgId() {
      if (f.hasProperty(this.fields, "messageId")) {
        return `${this.fields.messageId}`;
      }
    }
  }
  class r extends g {
    constructor(b, a) {
      super(b);
      f.hasProperty(a, "fields") && (this.fields = a.fields);
      f.hasProperty(a, "properties") && (this.props = a.properties);
      f.hasProperty(a, "content") && (this.msgContent = a.content);
    }
    getCorrelationId() {
      if (f.hasProperty(this.props, "correlationId")) {
        return `${this.props.correlationId}`;
      }
    }
    getMsgId() {
      if (f.hasProperty(this.props, "messageId")) {
        return `${this.props.messageId}`;
      }
    }
  }
});
S("src/lib/transformer/RabbitMqTransformer", "require exports src/lib/Agent src/lib/CallbackWrappingHelper src/lib/Embedder src/lib/FunctionId src/lib/SubPathContext src/lib/util/CoreUtil src/lib/util/InvocationUtil src/lib/util/ErrorUtil src/lib/modules/AutoSensorModule src/lib/sensors/MessagingAttachment src/lib/transformer/TransformerBase".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class l {
    constructor(b, a, c, d) {
      this.channel = b;
      this.args = a;
      this.isConsumerTracker = c;
      this.isDebug = d;
      this.errorExtractor = h.errorFromFirstArg;
    }
    createAttachments(a) {
      null != this.channel && null != this.args ? (this.isConsumerTracker ? new b.MessagingConsumerAttachment(a) : new b.MessagingProducerAttachment(a)).fillAttachment(this.channel, this.args) : this.isDebug && e.Logger.debug(`RabbitMqSensor: trying to create attachment w/o data objects for ${this.isConsumerTracker ? "consumer" : "producer"}`);
    }
    static cbIsWrapped(b) {
      return null != b ? !!l.embedder.get(b) : !1;
    }
    static getMessageObjectFromArgs(b) {
      if (0 < b.length) {
        return b[b.length - 1];
      }
    }
    static getLinkFromMessage(b) {
      if (m.hasProperty(b, "properties", "headers", "dtdTraceTagInfo")) {
        return b.properties.headers.dtdTraceTagInfo;
      }
    }
  }
  l.embedder = f.create("amqptracker");
  class x extends d.TransformerBase {
    generateSubstitute(b) {
      const a = this, d = new k.FunctionId(b);
      return function(f) {
        const h = a.controlParams.isDebugEnabled;
        h && e.Logger.debug("RabbitMqSensor: Channel.sendMessage substitute enter");
        if (!a.controlParams.active) {
          return h && e.Logger.debug("RabbitMqSensor: Channel.sendMessage exit - inactive"), g.doInvoke(this, b.origFn, arguments);
        }
        let k;
        try {
          var p = new l(this, arguments, !1, h);
          k = a.tryStartActivation({functionId:d, attachmentCreator:p});
          if (null != k) {
            const b = k.mActivation.spc;
            if (m.hasProperty(f, "headers")) {
              const a = b.createAddSerializeLink(!1, e.Agent.correlation.TaggingMode.DT_ONLY);
              null != a && null != a.dtTag ? f.headers.dtdTraceTagInfo = a.dtTag : h && e.Logger.debug("RabbitMqSensor: Channel.sendMessage - link invalid");
            }
          } else {
            h && e.Logger.debug(`RabbitMqSensor:: no activation, active spc: ${n.SubPathContext.getActiveContext()}`);
          }
        } catch (A) {
          c.logAgentException(A);
        }
        p = g.safeInvoke(this, b.origFn, arguments);
        try {
          null != k && (r.addSample(d), k.methodActivationDone(p.exception));
        } catch (A) {
          c.logAgentException(A);
        }
        h && e.Logger.debug("RabbitMqSensor: Channel.sendMessage substitute exit");
        return p.rethrow();
      };
    }
  }
  a.AmqpProducerTransformer = x;
  class p extends d.TransformerBase {
    generateSubstitute(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        d && e.Logger.debug("RabbitMqSensor: Channel.dispatchMessage substitute enter");
        if (!a.controlParams.active) {
          return d && e.Logger.debug("RabbitMqSensor: Channel.dispatchMessage exit - inactive"), g.doInvoke(this, b.origFn, arguments);
        }
        var f = arguments;
        try {
          if (m.hasProperty(this, "consumers")) {
            const b = l.getMessageObjectFromArgs(arguments);
            if (m.hasProperty(b, "fields", "consumerTag")) {
              if (null != l.getLinkFromMessage(b)) {
                const c = b.fields.consumerTag, f = this.consumers[c];
                a.currentChannel = this;
                if (l.cbIsWrapped(f)) {
                  d && e.Logger.debug("RabbitMqSensor: Channel.dispatchMessage - callback already wrapped");
                } else {
                  d && e.Logger.debug("RabbitMqSensor: Channel.dispatchMessage - wrapping callback");
                  const b = a.wrapCallback(f);
                  l.embedder.set(b, !0);
                  this.consumers[c] = b;
                }
              } else {
                d && e.Logger.debug("RabbitMqSensor: no tag found on message");
              }
            } else {
              d && e.Logger.debug("RabbitMqSensor: No callback for wrapping available");
            }
          }
        } catch (u) {
          c.logAgentException(u);
        }
        f = g.safeInvoke(this, b.origFn, f);
        d && e.Logger.debug("RabbitMqSensor: Channel.dispatchMessage substitute exit");
        return f.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this, d = new k.FunctionId(b);
      return function() {
        const f = a.controlParams.isDebugEnabled;
        let h;
        try {
          f && e.Logger.debug("RabbitMqSensor: consumer callback substitute enter");
          var k = l.getMessageObjectFromArgs(arguments);
          const b = l.getLinkFromMessage(k);
          let c;
          null != b && (c = e.Agent.correlation.deserializeLinkFromString(b));
          const g = new l(a.currentChannel, k, !0, f);
          h = a.tryStartIncomingSubPath({functionId:d, link:c, attachmentCreator:g});
          null == h && f && e.Logger.debug(`RabbitMqSensor:: no activation, active spc: ${n.SubPathContext.getActiveContext()}`);
        } catch (B) {
          c.logAgentException(B);
        }
        k = g.safeInvoke(this, b, arguments);
        try {
          null != h && (r.addSample(d), h.methodActivationDone(k.exception)), f && e.Logger.debug("RabbitMqSensor: consumer callback substitute exit");
        } catch (B) {
          c.logAgentException(B);
        }
        return k.rethrow();
      };
    }
    wrapReturnValue() {
    }
  }
  a.AmqpConsumerTransformer = p;
});
S("src/lib/sensors/RabbitMqSensor", "require exports src/lib/Patch src/lib/transformer/ContextPassingTransformer src/lib/transformer/RabbitMqTransformer src/lib/sensors/SensorBase".split(" "), function(t, a, e, h, f, k) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class n extends k.SensorBase {
    applyInstrumentation(a) {
      (a.matchRequest("amqplib") || a.matchRequest("amqplib/callback_api")) && this.patchConnect(a.moduleExports);
      a.matchRequestPattern("channel") && (this.patchChannelSendMessageCommand(a.moduleExports), this.patchChannelDispatchMessageCommand(a.moduleExports));
      if (a.matchRequestPattern("channel_model") || a.matchRequestPattern("callback_model")) {
        this.patchChannelrpcCommand(a.moduleExports), this.patchChannelAssertExchangeCommand(a.moduleExports);
      }
    }
    patchChannelSendMessageCommand(a) {
      const g = new f.AmqpProducerTransformer(this);
      a = new e.FunctionSpec("sendMessage", "Channel", a.Channel.prototype, e.AsyncTrackingMode.None, "amqp");
      e.applyToSingle(a, g);
    }
    patchChannelrpcCommand(a) {
      const f = new h.ContextPassingTransformer(this);
      a = new e.FunctionSpec("rpc", "Channel", a.Channel.prototype, e.AsyncTrackingMode.CallbackLastOrPromise, "amqp");
      e.applyToSingle(a, f);
    }
    patchChannelAssertExchangeCommand(a) {
      const f = new h.ContextPassingTransformer(this);
      a = new e.FunctionSpec("assertExchange", "Channel", a.Channel.prototype, e.AsyncTrackingMode.CallbackLastOrPromise, "amqp");
      e.applyToSingle(a, f);
    }
    patchChannelDispatchMessageCommand(a) {
      const g = new f.AmqpConsumerTransformer(this);
      a = new e.FunctionSpec("dispatchMessage", "Channel", a.BaseChannel.prototype, e.AsyncTrackingMode.CallbackLastOrPromise, "amqp");
      e.applyToSingle(a, g);
    }
    patchConnect(a) {
      const f = new h.ContextPassingTransformer(this);
      a = new e.FunctionSpec("connect", "", a, e.AsyncTrackingMode.CallbackLastOrPromise, "amqp");
      e.applyToSingle(a, f);
    }
  }
  a.RabbitMqSensor = n;
});
S("src/lib/sensors/RemoteCallAttachment", ["require", "exports", "src/lib/Agent", "src/lib/AttachmentBase"], function(t, a, e, h) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class f extends h.AttachmentBase {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_REMOTE_CALL_CLIENT_ID, 0);
    }
    fillAttachmentData(a) {
      this.setMultipleFields(f => {
        const g = e.Agent.correlation.AttachmentFieldId;
        f.integer(g.REMOTE_CALL_CHANNEL_TYPE_ID, a.getChannelTypeId());
        f.stringCached(g.REMOTE_CALL_CHANNEL_ENDPOINT_ID, a.getChannelEndpointId());
        f.stringCached(g.REMOTE_CALL_SERVICE_ENDPOINT_ID, a.getServiceEndpointId());
        a.hasHostnameId() && f.stringCached(g.REMOTE_CALL_HOSTNAME_ID, a.getHostnameId());
        f.integer(g.REMOTE_CALL_PORTNO_ID, a.getPortNoId());
        f.stringCached(g.REMOTE_CALL_SERVICE_METHOD_ID, a.getServiceMethodId());
        f.stringCached(g.REMOTE_CALL_SERVICE_NAME_ID, a.getServiceNameId());
        f.integer(g.REMOTE_CALL_PROTOCOL_TYPE_ID, a.getWireProtocolTypeId());
        a.hasWireProtocolName() && f.stringCached(g.REMOTE_CALL_PROTOCOL_NAME_ID, a.getWireProtocolName());
      });
    }
  }
  a.RemoteCallClientAttachment = f;
  class k extends h.AttachmentBase {
    constructor(a) {
      super(a, e.Agent.correlation.AttachmentId.ATTACHMENT_REMOTE_CALL_SERVER_ID, 0);
    }
    fillAttachmentData(a) {
      this.setMultipleFields(f => {
        const g = e.Agent.correlation.AttachmentFieldId;
        f.stringCached(g.REMOTE_CALL_SERVICE_ENDPOINT_ID, a.getServiceEndpointId());
        f.stringCached(g.REMOTE_CALL_SERVICE_METHOD_ID, a.getServiceMethodId());
        f.stringCached(g.REMOTE_CALL_SERVICE_NAME_ID, a.getServiceNameId());
        f.integer(g.REMOTE_CALL_PROTOCOL_TYPE_ID, a.getWireProtocolTypeId());
        a.hasWireProtocolName() && f.stringCached(g.REMOTE_CALL_PROTOCOL_NAME_ID, a.getWireProtocolName());
      });
    }
  }
  a.RemoteCallServerAttachment = k;
});
S("src/lib/transformer/GrpcUtilities", "require exports src/lib/modules/AutoSensorModule src/lib/sensors/SensorConstants src/lib/sensors/RemoteCallAttachment src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/Agent src/lib/Embedder src/lib/FunctionId src/lib/Patch src/lib/SubPathContext src/lib/transformer/EventEmitterTransformerBase src/lib/transformer/TransformerBase src/lib/util/UniqueId".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class q {
    constructor() {
      this.id = p.UniqueId.getNext();
    }
  }
  a.GrpcTracker = q;
  class v extends q {
    constructor(b, a, c) {
      super();
      this.serviceInfo = b;
      this.address = a;
      this.isDebug = c;
    }
    createAttachments(b) {
      b = new f.RemoteCallClientAttachment(b);
      b.valid && b.fillAttachmentData(new D(this.serviceInfo, this.address, this.isDebug));
    }
    toString() {
      null == this.stringified && (this.stringified = `GRPCClientTracker#${this.id}`);
      return this.stringified;
    }
  }
  a.GrpcClientTracker = v;
  class D {
    constructor(b, a, c) {
      this.serviceInfo = b;
      this.address = a;
      this.isDebug = c;
      this.port = 0;
      null != a ? (a = a.split(":"), 2 === a.length && (this.hostname = a[0], this.port = +a[1])) : this.isDebug && g.Logger.debug("GRPCClientState.ctr: no adress available");
      null == b && this.isDebug && g.Logger.debug("GRPCClientState.ctr: no serviceInfo object available");
    }
    getChannelTypeId() {
      return g.Agent.correlation.ChannelType.TCP_IP;
    }
    getChannelEndpointId() {
      return null != this.address ? this.address : "";
    }
    getServiceEndpointId() {
      return "grpc://" + this.getServiceNameId();
    }
    hasHostnameId() {
      return null != this.hostname;
    }
    getHostnameId() {
      return this.hostname ? this.hostname : "";
    }
    getPortNoId() {
      return this.port;
    }
    getServiceMethodId() {
      if (null == this.methodName && null != this.serviceInfo && null != this.serviceInfo.path) {
        const b = this.serviceInfo.path.split("/");
        0 < b.length && (this.methodName = b[b.length - 1]);
      }
      return null != this.methodName ? this.methodName : "";
    }
    getServiceNameId() {
      if (null == this.serviceName && null != this.serviceInfo) {
        const b = this.serviceInfo.path;
        if (null != b) {
          const a = b.lastIndexOf("/");
          -1 === a ? this.serviceName = b : 0 === a ? this.serviceName = b.substring(a + 1, b.length) : b.startsWith("/") ? this.serviceName = b.substring(1, a) : this.serviceName = b.substring(0, a);
        }
      }
      return null != this.serviceName ? this.serviceName : "";
    }
    getWireProtocolTypeId() {
      const b = g.Agent.correlation.RemoteCallWireProtocol;
      if (k.hasProperty(this.serviceInfo, "requestStream") && k.hasProperty(this.serviceInfo, "responseStream")) {
        switch(z.getCallType(this.serviceInfo.requestStream, this.serviceInfo.responseStream)) {
          case z.CallType.UNARY:
            return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC_UNARY;
          case z.CallType.SERVER_STREAM:
          case z.CallType.SERVER_STREAM_JS:
            return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC_SERVERSTREAM;
          case z.CallType.CLIENT_STREAM:
          case z.CallType.CLIENT_STREAM_JS:
            return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC_CLIENTSTREAM;
          case z.CallType.BIDI:
            return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC_BIDI;
        }
      }
      return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC;
    }
    hasWireProtocolName() {
      return !1;
    }
    getWireProtocolName() {
      return "";
    }
  }
  class C {
    constructor(b, a) {
      this.type = b;
      this.serviceEndpoint = a;
    }
    getServiceEndpointId() {
      return "grpc://" + this.getServiceNameId();
    }
    getServiceMethodId() {
      if (null == this.methodName && null != this.serviceEndpoint) {
        const b = this.serviceEndpoint.split("/");
        0 < b.length && (this.methodName = b[b.length - 1]);
      }
      return this.methodName ? this.methodName : "";
    }
    getServiceNameId() {
      if (null == this.serviceName && null != this.serviceEndpoint) {
        const b = this.serviceEndpoint, a = b.lastIndexOf("/");
        -1 === a ? this.serviceName = b : 0 === a ? this.serviceName = b.substring(a + 1, b.length) : b.startsWith("/") ? this.serviceName = b.substring(1, a) : this.serviceName = b.substring(0, a);
      }
      return null != this.serviceName ? this.serviceName : "";
    }
    getWireProtocolTypeId() {
      const b = g.Agent.correlation.RemoteCallWireProtocol;
      if (null != this.type) {
        switch(this.type) {
          case z.CallType.UNARY:
            return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC_UNARY;
          case z.CallType.SERVER_STREAM:
          case z.CallType.SERVER_STREAM_JS:
            return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC_SERVERSTREAM;
          case z.CallType.CLIENT_STREAM:
          case z.CallType.CLIENT_STREAM_JS:
            return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC_CLIENTSTREAM;
          case z.CallType.BIDI:
            return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC_BIDI;
        }
      }
      return b.REMOTE_CALL_WIRE_PROTOCOL_GRPC;
    }
    hasWireProtocolName() {
      return !1;
    }
    getWireProtocolName() {
      return "";
    }
  }
  class u extends q {
    constructor(b, a) {
      super();
      this.type = b;
      this.serviceEndpoint = a;
    }
    createAttachments(b) {
      b = new f.RemoteCallServerAttachment(b);
      b.valid && b.fillAttachmentData(new C(this.type, this.serviceEndpoint));
    }
    toString() {
      null == this.stringified && (this.stringified = `GRPCServerTracker#${this.id}`);
      return this.stringified;
    }
  }
  a.GrpcServerTracker = u;
  class z {
    static isActuallyAChannel(b, a) {
      return b && b instanceof a;
    }
    static getTagString(b) {
      if (0 < b.length && null != b[0].metadata && (b = b[0].metadata.get(h.cHttpTaggingHeader), null != b && 1 === b.length)) {
        return b[0];
      }
    }
    static getCallbackIndex(b) {
      return 0 < b.length && k.isFunction(b[b.length - 1]) ? b.length - 1 : -1;
    }
    static getCallType(b, a) {
      return b ? a ? z.CallType.BIDI : z.CallType.CLIENT_STREAM : a ? z.CallType.SERVER_STREAM : z.CallType.UNARY;
    }
    static findServiceInfo(b, a) {
      let c = b[a];
      null == c && (c = b[z.recapitalizeServiceMethodName(a)]);
      return c;
    }
    static recapitalizeServiceMethodName(b) {
      const a = b.charAt(0);
      return a === a.toLowerCase() ? a.toUpperCase() + b.slice(1) : a.charAt(0).toLowerCase() + b.slice(1);
    }
    static patchServiceClient(a, c, d, e, f = !1) {
      if (null != a && ("ServiceClient" === a.name || "ServiceClientImpl" === a.name)) {
        e && g.Logger.debug("GrpcLoadTransformer.patchServiceClient: patching serviceclient");
        for (const k in a.prototype) {
          if (a.prototype.hasOwnProperty(k) && z.isServiceFunction(a.prototype[k])) {
            var h = k.toString(), l = a.service;
            let p;
            null != l && (p = z.findServiceInfo(l, h));
            e && g.Logger.debug("GRPCLoadTransformer.patchServiceClient: patching service function " + k);
            h = new B(p, c, f, d);
            l = new b.FunctionSpec(k, "ServiceClient", a.prototype, b.AsyncTrackingMode.CallbackLast, z.cApiRealm);
            b.applyToSingle(l, h);
          }
        }
      }
    }
    static isServiceFunction(b) {
      return k.isFunction(b) && ("wrapper" === b.name || "method_func" === b.name || k.hasProperty(b, "path"));
    }
    static isService(b) {
      return k.hasProperty(b, "name") && "ServiceClientImpl" === b.name;
    }
    static isProtoMessageDefinition(b) {
      return k.hasProperty(b, "fileDescriptorProtos");
    }
    static findAndPatchServiceClients(b, a, c, d) {
      if (k.isObject(b)) {
        for (const e in b) {
          if (b.hasOwnProperty(e)) {
            const f = b[e];
            z.isService(f) ? z.patchServiceClient(f, a, c, d, !0) : z.isProtoMessageDefinition(f) || z.findAndPatchServiceClients(f, a, c, d);
          }
        }
      }
    }
  }
  a.GrpcUtilities = z;
  z.CallType = {UNARY:"unary", SERVER_STREAM:"server_stream", CLIENT_STREAM:"client_stream", SERVER_STREAM_JS:"serverStream", CLIENT_STREAM_JS:"clientStream", BIDI:"bidi", UNKNOWN:"unknown"};
  z.TagEmbedder = c.create("grpclinktag");
  z.TrackerEmbedder = c.create("grpctracker");
  z.cApiRealm = "grpc";
  class B extends x.TransformerBase {
    constructor(b, a, c, d) {
      super(d);
      this.serviceInfo = b;
      this.channelType = a;
      this.isManagedGrpc = c;
      this.callType = z.CallType.UNKNOWN;
      null != b ? this.callType = z.getCallType(b.requestStream, b.responseStream) : this.isDebugEnabled && g.Logger.debug("GrpcClientTransformer.ctr: No service info available. Some attachment data will be missing.");
    }
    generateSubstitute(b) {
      const a = this, c = new r.FunctionId(b);
      return function() {
        var f = a.controlParams.isDebugEnabled;
        let h, l, k;
        const p = arguments;
        try {
          const b = a.getChannelTarget(this);
          h = new v(a.serviceInfo, b, a.isDebugEnabled);
          l = a.tryStartAsyncActivation({functionId:c, attachmentCreator:h, vPathOption:a.callType === z.CallType.SERVER_STREAM || a.callType === z.CallType.BIDI || a.callType === z.CallType.SERVER_STREAM_JS ? 2 : 1});
          if (null != l) {
            switch(h.virtualNodeActivation = l.vNodeActivation, k = l.vNodeActivation.spc.createAddSerializeLink(!0, g.Agent.correlation.TaggingMode.DT_ONLY), z.TagEmbedder.set(a.isManagedGrpc ? this.getChannel() : this.$channel, k ? k.dtTag : void 0), a.callType) {
              case z.CallType.UNARY:
              case z.CallType.CLIENT_STREAM:
                a.isDebugEnabled && g.Logger.debug("GRPCClientTransformer.clientCallSubstitute: '" + a.callType + "' call - wrapping callback");
                const b = z.getCallbackIndex(p);
                if (0 <= b) {
                  h.origFunction = p[b];
                  const c = a.wrapCallback(h);
                  p[b] = c;
                }
                break;
              default:
                a.isDebugEnabled && g.Logger.debug("GRPCClientTransformer.clientCallSubstitute: '" + a.callType + "' call - wrapping stream");
            }
          } else {
            f && g.Logger.debug(`${h}: no activation, active spc: ${d.SubPathContext.getActiveContext()}`);
          }
        } catch (J) {
          n.logAgentException(J);
        }
        f = m.safeInvoke(this, b.origFn, p);
        try {
          if (null != h) {
            f.didThrow && null != h.virtualNodeActivation && (a.isDebugEnabled && g.Logger.debug("GRPCClientTransformer.clientCallSubstitute: call ended with exception. Ending virtual path structure"), h.virtualNodeActivation.exitOrException(f.exception), h.virtualNodeActivation.spc.end());
            if (!f.didThrow) {
              switch(a.callType) {
                case z.CallType.SERVER_STREAM:
                case z.CallType.SERVER_STREAM_JS:
                case z.CallType.BIDI:
                  z.TrackerEmbedder.set(f.retVal, h);
                  a.patchReadableStream(f.retVal);
                  break;
                case z.CallType.UNKNOWN:
                  null != h.virtualNodeActivation && (h.virtualNodeActivation.exitOrException(f.exception), h.virtualNodeActivation.spc.end());
              }
            }
            null != l && (e.addSample(c), l.initiatorActivationDone(f.exception));
          }
        } catch (J) {
          n.logAgentException(J);
        }
        return f.rethrow();
      };
    }
    wrapCallback(b) {
      const a = this;
      return function() {
        const c = a.controlParams.isDebugEnabled;
        let d, f;
        try {
          null != b.virtualNodeActivation && (b.virtualNodeActivation.isExited || (0 < arguments.length && arguments[0] instanceof Error ? b.virtualNodeActivation.methodException(arguments[0]) : b.virtualNodeActivation.exit()), d = new r.FunctionId(b.origFunction), f = x.TransformerBase.createCallbackActivation(b.virtualNodeActivation.spc, d), null != f ? c && g.Logger.debug(`${b} | creating callback node for function ${b.origFunction.name}. spc=${f.activation.spc}`) : c && g.Logger.debug(`${b} | could not create callback method activation`));
        } catch (L) {
          n.logAgentException(L);
        }
        const h = m.safeInvoke(this, b.origFunction, arguments);
        try {
          null != b.virtualNodeActivation && (null != f && (c && g.Logger.debug(`${b} | closing callback node.`), e.addSample(d), f.done(h.exception)), b.virtualNodeActivation.spc.end());
        } catch (L) {
          n.logAgentException(L);
        }
        return h.rethrow();
      };
    }
    patchReadableStream(a) {
      const c = new A(this.controlParams);
      a = new b.ModuleSpec("Readable", a);
      c.applyTransformation(a);
    }
    getChannelTarget(b) {
      return k.hasProperty(b, "$channel") ? b.$channel.getTarget() : this.isManagedGrpc && k.isFunction(b.getChannel) ? b.getChannel().getTarget() : "";
    }
  }
  class A extends l.EventEmitterTransformerBase {
    constructor(b) {
      super(b, ["data", "end", "readable", "error", "close"]);
    }
    shallWrap(b) {
      return null != z.TrackerEmbedder.get(b);
    }
    getWrappedListener(b, a, c) {
      const d = z.TrackerEmbedder.get(b);
      if (null == d) {
        return c;
      }
      const f = l.EventEmitterTransformerBase.getUnwrappedListener(c);
      return function(b) {
        try {
          null != d && null != d.virtualNodeActivation && (d.virtualNodeActivation.isExited || (b instanceof Error ? d.virtualNodeActivation.methodException(b) : d.virtualNodeActivation.exit(), d.virtualNodeActivation.spc.open && d.virtualNodeActivation.spc.end()), d.virtualNodeActivation.spc.activate());
        } catch (G) {
          n.logAgentException(G);
        }
        const a = m.safeInvoke(this, c, arguments);
        try {
          c === f && e.addSample(() => new r.FunctionId(f)), null != d && null != d.virtualNodeActivation && d.virtualNodeActivation.spc.deactivate();
        } catch (G) {
          n.logAgentException(G);
        }
        return a.rethrow();
      };
    }
  }
});
S("src/lib/transformer/GrpcTransformer", "require exports src/lib/Agent src/lib/FunctionId src/lib/Patch src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/modules/AutoSensorModule src/lib/sensors/SensorConstants src/lib/transformer/TransformerBase src/lib/transformer/GrpcUtilities".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class d extends r.TransformerBase {
    constructor(b, a) {
      super(a);
      this.channelType = b;
    }
    generateSubstitute(a) {
      const c = this;
      return function() {
        const d = c.isDebugEnabled;
        try {
          d && e.Logger.debug(".makeClientCtrSubstitute: calling original");
        } catch (B) {
          n.logAgentException(B);
        }
        const f = m.safeInvoke(this, a.origFn, arguments);
        try {
          d && e.Logger.debug(".makeClientCtrSubstitute: wrapping client instance functions"), b.GrpcUtilities.patchServiceClient(f.retVal, c.channelType, c.controlParams, d);
        } catch (B) {
          n.logAgentException(B);
        }
        return f.rethrow();
      };
    }
  }
  a.GrpcMakeClientCtrTransformer = d;
  class l extends r.TransformerBase {
    constructor(b) {
      super(b);
    }
    generateSubstitute(a) {
      const c = this;
      return function() {
        const d = c.isDebugEnabled;
        try {
          d && e.Logger.debug("GrpcCallTransformer.callSubstitute: calling original");
        } catch (B) {
          n.logAgentException(B);
        }
        const f = m.safeInvoke(this, a.origFn, arguments);
        try {
          d && e.Logger.debug("GrpcCallTransformer.callSubstitute: wrapping call object start_patch");
          const a = b.GrpcUtilities.TagEmbedder.get(this);
          c.wrapReturnValue(void 0, f, a);
        } catch (B) {
          n.logAgentException(B);
        }
        return f.rethrow();
      };
    }
    wrapReturnValue(a, c, d) {
      a = c.retVal;
      b.GrpcUtilities.TagEmbedder.set(a, d);
      this.patchStartBatch(a);
    }
    patchStartBatch(b) {
      this.isDebugEnabled && e.Logger.debug("GrpcCallTransformer.patchStartPatch: patching Call.start_patch");
      b = new f.FunctionSpec("startBatch", "", b);
      const a = new x(this.controlParams);
      null == f.applyToSingle(b, a) && e.Logger.warning("GRPCCallTransformer: Failed to patch Call.start_patch");
    }
  }
  a.GrpcCallTransformer = l;
  class x extends r.TransformerBase {
    constructor(b) {
      super(b);
    }
    generateSubstitute(a) {
      const d = this;
      return function() {
        let f = b.GrpcUtilities.TagEmbedder.get(this);
        null == f && null != this.channel_ && (f = b.GrpcUtilities.TagEmbedder.get(this.channel_));
        if (null != f) {
          if (d.isDebugEnabled && e.Logger.debug("GrpcStartPatchTransformer.startPatchSubstitute: found embedded tag '" + f + "'"), 0 < arguments.length) {
            var g = arguments[0];
            null != g ? (g = g[0], k.hasProperty(g, "metadata") ? g.metadata[c.cHttpTaggingHeader] = [f] : null != g ? (d.isDebugEnabled && e.Logger.debug("GrpcStartPatchTransformer.startPatchSubstitute: adding tag '" + f + "' to metadata"), g[c.cHttpTaggingHeader] = [f]) : d.isDebugEnabled && e.Logger.debug("GrpcStartPatchTransformer.startPatchSubstitute: no metadata object found")) : d.isDebugEnabled && e.Logger.debug("GrpcStartPatchTransformer.startPatchSubstitute: no clientbatch object found");
          } else {
            d.isDebugEnabled && e.Logger.debug("GrpcStartPatchTransformer.startPatchSubstitute: no arguments to patch");
          }
        } else {
          d.isDebugEnabled && e.Logger.debug("GrpcStartPatchTransformer.startPatchSubstitute: no tag found");
        }
        d.isDebugEnabled && e.Logger.debug("GrpcStartPatchTransformer.startPatchSubstitute: calling original");
        return m.safeInvoke(this, a.origFn, arguments).rethrow();
      };
    }
  }
  class p extends r.TransformerBase {
    constructor(b) {
      super(b);
    }
    generateSubstitute(b) {
      const a = this;
      return function() {
        var c = arguments, d;
        const f = [], g = a.isDebugEnabled;
        try {
          if (null != c && 2 === c.length && (d = c[1]), null != d) {
            const b = Object.keys(d);
            g && e.Logger.debug(`GRPCAddServiceTransformer | found ${b.length} service functions`);
            for (const c of b) {
              if (!d[c].__dt_AlreadyWrapped) {
                const b = new q(a.controlParams);
                d[c] = b.wrapServiceFunction(d[c]);
                d[c].__dt_AlreadyWrapped = !0;
                f.push(b);
              }
            }
          }
        } catch (w) {
          n.logAgentException(w);
        }
        c = m.safeInvoke(this, b.origFn, c);
        try {
          if (a.isDebugEnabled && e.Logger.debug("GRPCAddServiceTransformer.addServiceSubstitute | filling in handlers"), null != this && k.hasProperty(this, "handlers")) {
            d = 0;
            let b;
            const c = this.handlers instanceof Map;
            b = c ? this.handlers : Object.keys(this.handlers);
            for (const h of b) {
              if (d < f.length) {
                const b = f[d], g = c ? h[0] : h, l = c ? h[1].type : this.handlers[h].type;
                b.serviceEndpointName = g;
                b.serviceType = l;
                a.isDebugEnabled && e.Logger.debug(`GRPCAddServiceTransformer.addServiceSubstitute | filling in handler#${d}: [${g} | ${l}]`);
                d++;
              } else {
                g && e.Logger.debug(`GRPCAddServiceTransformer.addServiceSubstitute | index out of bounds ${d}/${b.length}`);
              }
            }
          } else {
            a.isDebugEnabled && e.Logger.debug("GRPCAddServiceTransformer.addServiceSubstitute | no handlers found to wrap.");
          }
        } catch (w) {
          n.logAgentException(w);
        }
        return c.rethrow();
      };
    }
  }
  a.GrpcAddServiceTransformer = p;
  class q extends r.TransformerBase {
    constructor(b) {
      super(b);
      this.serviceType = this.serviceEndpointName = "";
    }
    wrapServiceFunction(a) {
      const c = this;
      return function() {
        let d, l;
        var p = arguments;
        let r, x;
        try {
          const g = b.GrpcUtilities.getTagString(arguments);
          x = new b.GrpcServerTracker(c.serviceType, c.serviceEndpointName);
          k.isString(g) && (c.isDebugEnabled && e.Logger.debug(`${x} | GRPCServiceFunctionTransformer.wrappedServiceFunction for (${a.name}): found tag '${g}'. Starting incoming subpath.`), r = e.Agent.correlation.deserializeLinkFromString(g));
          l = new h.FunctionId(a);
          d = c.tryStartIncomingAsyncSubPath({functionId:l, link:r, attachmentCreator:x});
          if (null != d) {
            switch(x.virtualNodeActivation = d.vNodeActivation, c.isDebugEnabled && e.Logger.debug(`${x} | started asyncActivation. initiator=` + `${d.initiatorActivation.toString(!0)}, ` + `vNode=${d.vNodeActivation.toString(!0)}`), c.serviceType) {
              case b.GrpcUtilities.CallType.UNARY:
              case b.GrpcUtilities.CallType.CLIENT_STREAM:
              case b.GrpcUtilities.CallType.CLIENT_STREAM_JS:
                c.isDebugEnabled && e.Logger.debug(`${x} | GRPCServiceFunctionTransformer.wrappedServiceFunction: '${c.serviceType}' call. Wrapping callback...`);
                const a = b.GrpcUtilities.getCallbackIndex(p);
                if (0 <= a) {
                  x.origFunction = p[a];
                  const b = c.wrapClientCallback(x);
                  p[a] = b;
                }
                break;
              case b.GrpcUtilities.CallType.SERVER_STREAM_JS:
              case b.GrpcUtilities.CallType.SERVER_STREAM:
              case b.GrpcUtilities.CallType.BIDI:
                c.isDebugEnabled && e.Logger.debug(`${x} | GRPCServiceFunctionTransformer.wrappedServiceFunction: '${c.serviceType}' call. Wrapping stream...`);
                b.GrpcUtilities.TrackerEmbedder.set(p[0], x);
                q.writableStreamPatched || (c.patchWritableStream(p[0]), q.writableStreamPatched = !0);
                const d = new v(c.controlParams), g = new f.FunctionSpec("end", "", p[0]);
                f.applyToSingle(g, d);
                break;
              default:
                c.isDebugEnabled && e.Logger.debug(`${x} | GRPCServiceFunctionTransformer.wrappedServiceFunction: unknown call type='${c.serviceType}'`);
            }
          }
        } catch (I) {
          n.logAgentException(I);
        }
        p = m.safeInvoke(this, a, p);
        try {
          null != d && null != x && (g.addSample(l), c.isDebugEnabled && e.Logger.debug(`${x} | ending initiator=${d.initiatorActivation.toString(!0)}, didThrow=${p.didThrow}`), d.initiatorActivationDone(p.exception));
        } catch (I) {
          n.logAgentException(I);
        }
        return p.rethrow();
      };
    }
    wrapClientCallback(b) {
      const a = this;
      return function() {
        try {
          null != b.virtualNodeActivation && (b.virtualNodeActivation.isExited ? a.isDebugEnabled && e.Logger.debug(`${b} | reentering callback, with ` + `closed vNode=${b.virtualNodeActivation.toString(!0)}`) : (a.isDebugEnabled && e.Logger.debug(`${b} | exiting vNode=${b.virtualNodeActivation.toString(!0)}`), b.virtualNodeActivation.exit()));
        } catch (u) {
          n.logAgentException(u);
        }
        return m.safeInvoke(this, b.origFunction, arguments).rethrow();
      };
    }
    patchWritableStream(b) {
      let a = new v(this.controlParams), c = new f.FunctionSpec("write", "", b.constructor.prototype);
      f.applyToSingle(c, a);
      a = new v(this.controlParams);
      c = new f.FunctionSpec("pipe", "", b.constructor.prototype);
      f.applyToSingle(c, a);
    }
  }
  q.writableStreamPatched = !1;
  class v extends r.TransformerBase {
    constructor(b) {
      super(b);
    }
    generateSubstitute(a) {
      const c = this;
      return function() {
        let d;
        try {
          d = b.GrpcUtilities.TrackerEmbedder.get(this), null != d && (c.isDebugEnabled && e.Logger.debug(`${d} | GRPCWritableStreamTransformer.writableStreamSubstitute(${a.functionName}): found embedded tracker`), null == d.virtualNodeActivation || d.virtualNodeActivation.isExited || (d.virtualNodeActivation.exit(), c.isDebugEnabled && e.Logger.debug(`${d} | GRPCWritableStreamTransformer.writableStreamSubstitute` + `(${a.functionName}): exiting virtual node=${d.virtualNodeActivation}`)));
        } catch (B) {
          n.logAgentException(B);
        }
        const f = m.safeInvoke(this, a.origFn, arguments);
        try {
          null != d && null != d.virtualNodeActivation && d.virtualNodeActivation.spc.open && (c.isDebugEnabled && e.Logger.debug(`${d} | GRPCWritableStreamTransformer.writableStreamSubstitute` + `(${a.functionName}): ending subpath=${d.virtualNodeActivation.spc}`), d.virtualNodeActivation.spc.end());
        } catch (B) {
          n.logAgentException(B);
        }
        return f.rethrow();
      };
    }
  }
});
S("src/lib/sensors/GrpcSensor", ["require", "exports", "src/lib/sensors/SensorBase", "src/lib/Patch", "src/lib/transformer/GrpcTransformer"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  let k;
  class n extends e.SensorBase {
    applyInstrumentation(a) {
      a.matchRequest("grpc") && this.patchServer(a.moduleExports);
      a.matchRequestPattern("client") && !a.matchRequestPattern("make-client") && this.patchMakeClientCtr(a.moduleExports);
      a.matchRequestPattern("grpc_extension") && (this.patchCall(a.moduleExports), this.patchCreateCall(a.moduleExports), k = a.moduleExports.Channel);
    }
    patchMakeClientCtr(a) {
      const e = new f.GrpcMakeClientCtrTransformer(k, this);
      a = new h.FunctionSpec("makeClientConstructor", "", a, h.AsyncTrackingMode.CallbackLast, "grpc");
      h.applyToSingle(a, e);
    }
    patchCall(a) {
      const e = new f.GrpcCallTransformer(this);
      a = new h.FunctionSpec("Call", "", a, h.AsyncTrackingMode.CallbackLast, "grpc");
      h.applyToSingle(a, e);
    }
    patchCreateCall(a) {
      const e = new f.GrpcCallTransformer(this);
      a = new h.FunctionSpec("createCall", "Channel", a.Channel.prototype, h.AsyncTrackingMode.CallbackLast, "grpc");
      h.applyToSingle(a, e);
    }
    patchServer(a) {
      const e = new f.GrpcAddServiceTransformer(this);
      let c = new h.FunctionSpec("addProtoService", "", a.Server.prototype, h.AsyncTrackingMode.CallbackLast, "grpc");
      h.applyToSingle(c, e);
      c = new h.FunctionSpec("addService", "", a.Server.prototype, h.AsyncTrackingMode.CallbackLast, "grpc");
      h.applyToSingle(c, e);
    }
  }
  a.GrpcSensor = n;
});
S("src/lib/transformer/GrpcManagedTransformer", "require exports src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/Agent src/lib/transformer/GrpcUtilities src/lib/transformer/TransformerBase src/lib/sensors/SensorConstants".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class g extends n.TransformerBase {
    constructor(a, b) {
      super(b);
      this.channelType = a;
    }
    generateSubstitute(a) {
      const b = this;
      return function() {
        const c = b.isDebugEnabled;
        try {
          c && f.Logger.debug(".loadPackageSubstitute: calling original");
        } catch (x) {
          e.logAgentException(x);
        }
        const g = h.safeInvoke(this, a.origFn, arguments);
        try {
          c && f.Logger.debug(".loadPackageSubstitute: wrapping client instance functions"), k.GrpcUtilities.findAndPatchServiceClients(g.retVal, b.channelType, b.controlParams, c);
        } catch (x) {
          e.logAgentException(x);
        }
        return g.rethrow();
      };
    }
  }
  a.GrpcLoadPackageTransformer = g;
  class c extends n.TransformerBase {
    constructor(a) {
      super(a);
    }
    generateSubstitute(a) {
      const b = this;
      return function() {
        let c;
        null != this.channel && (c = k.GrpcUtilities.TagEmbedder.get(this.channel));
        if (null != c) {
          if (b.isDebugEnabled && f.Logger.debug("GrpcSendMetadataTransformer.sendMedataSubstitute: found embedded tag '" + c + "'"), 0 < arguments.length) {
            const a = arguments[0];
            null != a ? (b.isDebugEnabled && f.Logger.debug("GrpcSendMetadataTransformer.sendMedataSubstitute: adding tag '" + c + "' to metadata"), a.add(m.cHttpTaggingHeader, c)) : b.isDebugEnabled && f.Logger.debug("GrpcSendMetadataTransformer.sendMedataSubstitute: no metadata object found");
          } else {
            b.isDebugEnabled && f.Logger.debug("GrpcSendMetadataTransformer.sendMedataSubstitute: no arguments to patch");
          }
        } else {
          b.isDebugEnabled && f.Logger.debug("GrpcSendMetadataTransformer.sendMedataSubstitute: no tag found");
        }
        b.isDebugEnabled && f.Logger.debug("GrpcSendMetadataTransformer.sendMedataSubstitute: calling original");
        return h.safeInvoke(this, a.origFn, arguments).rethrow();
      };
    }
  }
  a.GrpcSendMetadataTransformer = c;
});
S("src/lib/sensors/GrpcJsSensor", "require exports src/lib/sensors/SensorBase src/lib/Patch src/lib/transformer/GrpcTransformer src/lib/transformer/GrpcManagedTransformer src/lib/transformer/Http2ClientTransformer src/lib/transformer/Http2ServerTransformer".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  let g;
  class c extends e.SensorBase {
    constructor() {
      super(...arguments);
      this.checkForSuppression = a => this.active ? a.toLowerCase().startsWith("application/grpc") : !1;
    }
    applyInstrumentation(a) {
      a.matchRequest("@grpc/grpc-js") && (this.patchServer(a.moduleExports), this.patchLoadPackageDefinition(a.moduleExports), n.addCheckForOutgoingRequestSuppression(this.checkForSuppression), m.addCheckForIncomingRequestSuppression(this.checkForSuppression));
      a.matchRequestPattern("channel") && (g = a.moduleExports.Http2Channel);
      a.matchRequestPattern("call-stream") && this.patchSendMetadata(a.moduleExports);
      a.matchRequestPattern("make-client") && this.patchMakeClientCtr(a.moduleExports);
    }
    patchMakeClientCtr(a) {
      const b = new f.GrpcMakeClientCtrTransformer(g, this);
      a = new h.FunctionSpec("makeClientConstructor", "", a, h.AsyncTrackingMode.CallbackLast, "grpc");
      h.applyToSingle(a, b);
    }
    patchServer(a) {
      const b = new f.GrpcAddServiceTransformer(this);
      let c = new h.FunctionSpec("addProtoService", "", a.Server.prototype, h.AsyncTrackingMode.CallbackLast, "grpc");
      h.applyToSingle(c, b);
      c = new h.FunctionSpec("addService", "", a.Server.prototype, h.AsyncTrackingMode.CallbackLast, "grpc");
      h.applyToSingle(c, b);
    }
    patchLoadPackageDefinition(a) {
      const b = new k.GrpcLoadPackageTransformer(g, this);
      a = new h.FunctionSpec("loadPackageDefinition", "", a, h.AsyncTrackingMode.None, "grpc");
      h.applyToSingle(a, b);
    }
    patchSendMetadata(a) {
      const b = new k.GrpcSendMetadataTransformer(this);
      a = new h.FunctionSpec("sendMetadata", "", a.Http2CallStream.prototype, "grpc");
      h.applyToSingle(a, b);
    }
  }
  a.GrpcJsSensor = c;
});
S("src/lib/agentapi/Common", "require exports src/lib/Agent src/lib/CallbackWrappingHelper src/lib/FunctionId src/lib/transformer/TransformerBase src/lib/modules/AutoSensorModule src/lib/sensors/ExceptionAttachment src/lib/sensors/SensorBase src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/util/UniqueId".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.validateConnectionInfo = function(b) {
    if (null != b.host) {
      if (!c.isString(b.host)) {
        return ".host is invalid";
      }
      if (null != b.port && !c.isNumber(b.port)) {
        return ".port is invalid";
      }
    } else {
      if (null != b.socketPath) {
        if (!c.isString(b.socketPath)) {
          return ".socketPath is invalid";
        }
      } else {
        if (null != b.pipeName) {
          if (!c.isString(b.pipeName)) {
            return ".pipeName is invalid";
          }
        } else {
          if (null != b.channelType) {
            if (!c.isNumber(b.channelType) || 0 > b.channelType || 4 < b.channelType) {
              return ".channelType is invalid";
            }
          } else {
            return " contains no ConnectionInfo (host/port, socketPath, pipeName or channelType)";
          }
        }
      }
    }
  };
  class l extends g.SensorBase {
    constructor(b, a, c) {
      super(b, a, c);
      this.addToDebugLogDomain("Sdk");
    }
  }
  a.SdkSensorBase = l;
  class x {
    logWarn(b, a, c) {
      b && e.Logger.debug(`${a}: SDK warn: ${c}`);
      if (null != this.warnCb) {
        try {
          this.warnCb.call(void 0, c);
        } catch (H) {
          b && e.Logger.debug(`SDK: exception in warnCb: ${r.verboseExceptionObject(H)}`);
        }
      }
    }
    logError(b, a, c) {
      b && e.Logger.debug(`${a}: SDK error: ${c}`);
      if (null != this.errorCb) {
        try {
          this.errorCb.call(void 0, c);
        } catch (H) {
          b && e.Logger.debug(`SDK: exception in errorCb: ${r.verboseExceptionObject(H)}`);
        }
      }
    }
  }
  a.SdkContext = x;
  var p;
  (function(b) {
    b[b.CREATED = 0] = "CREATED";
    b[b.STARTED = 1] = "STARTED";
    b[b.ENDED = 2] = "ENDED";
  })(p = a.TracerState || (a.TracerState = {}));
  class q {
    start(b, ...a) {
      if (!c.isFunction(b)) {
        throw new TypeError(`OneAgent SDK: Tracer.start() first parameter must be a function, but received ${typeof b}`);
      }
      return b.call(void 0, ...a);
    }
    startWithContext(b, a, ...d) {
      if (!c.isFunction(b)) {
        throw new TypeError(`OneAgent SDK: Tracer.start() first parameter must be a function, but received ${typeof b}`);
      }
      return b.call(a, ...d);
    }
    error() {
      return this;
    }
  }
  a.DummyTracer = q;
  class v extends q {
    end() {
    }
  }
  a.DummyIncomingTracer = v;
  class D extends q {
    end(b, ...a) {
      return this.endWithContext(b, void 0, ...a);
    }
    endWithContext(b, a, ...d) {
      if (null != b) {
        if (!c.isFunction(b)) {
          throw new TypeError(`OneAgent SDK: Tracer.end() first parameter must be a function, but received ${typeof b}`);
        }
        return b.call(a, ...d);
      }
    }
  }
  a.DummyOutgoingTracer = D;
  class C extends D {
    getDynatraceStringTag() {
      return "";
    }
    getDynatraceByteTag() {
      return Buffer.alloc(0);
    }
  }
  a.DummyOutgoingTaggableTracer = C;
  class u extends k.TransformerBase {
    constructor(b, a, c) {
      super(b);
      this.sdkContext = a;
      this.moduleName = c;
      this.exitByException = !1;
      this.state = p.CREATED;
      this.id = d.UniqueId.getNext();
      this.isDebugEnabled && e.Logger.debug(`${this}: create tracer`);
    }
    start(b, ...a) {
      return this.startWithContext(b, void 0, ...a);
    }
    startWithContext(a, d, ...g) {
      if (!c.isFunction(a)) {
        throw this.sdkContext.logError(this.isDebugEnabled, this.moduleName, `start() first parameter must be a function, but received ${typeof a}`), new TypeError(`OneAgent SDK: Tracer.start() first parameter must be a function, but received ${typeof a}`);
      }
      let l, k;
      try {
        if (this.isDebugEnabled && e.Logger.debug(`${this}: start() state: ${p[this.state]}`), this.state === p.CREATED) {
          if (this.state = p.STARTED, l = new f.FunctionId(a), k = this.startAsyncPath(l), null != k) {
            if (this.isDebugEnabled) {
              var q = k.vNodeActivation;
              const b = k.initiatorActivation;
              e.Logger.debug(`${this}: start() vNode: ${q} @spc: ${q.spc}, initiator: ${b} @spc: ${b.spc}`);
            }
            this.vNodeActivation = k.vNodeActivation;
            var m = k.initiatorActivation.spc;
            for (q = 0; q < g.length; q++) {
              const b = g[q];
              c.isFunction(b) && (g[q] = h.CallbackWrappingHelper.wrapCallbackContextPassing({origCb:b, spc:m}));
            }
          } else {
            this.isDebugEnabled && e.Logger.debug(`${this}: start() no activation created`), this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "no subpath created");
          }
        } else {
          this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "start() is only allowed once after tracer creation");
        }
      } catch (J) {
        r.logAgentException(J);
      }
      if (null == k) {
        return b.doInvoke(d, a, g);
      }
      a = b.safeInvoke(d, a, g);
      try {
        n.addSample(l), k.initiatorActivationDone(a.exception);
      } catch (J) {
        r.logAgentException(J);
      }
      this.isDebugEnabled && e.Logger.debug(`${this}: start() exit didThrow: ${a.didThrow ? r.verboseExceptionObject(a.exception) : "-"}`);
      return a.rethrow();
    }
    error(b) {
      try {
        this.isDebugEnabled && e.Logger.debug(`${this}: error(): state: ${p[this.state]}, vNode: ${this.vNodeActivation}, err: ${b}`);
        if (this.state !== p.STARTED) {
          return this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "error() shall be called on a started tracer"), this;
        }
        if (null != this.vNodeActivation) {
          if (this.exitByException) {
            this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "it's not allowed to set more then one error on a tracer");
          } else {
            this.exitByException = !0;
            try {
              (new m.ExceptionAttachment(this.vNodeActivation)).fillExceptionData(b);
            } catch (K) {
              r.logAgentException(K);
            }
          }
        } else {
          this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "can't set error on this path");
        }
      } catch (K) {
        r.logAgentException(K);
      }
      return this;
    }
    toString() {
      this.logPrefix || (this.logPrefix = `${this.moduleName} ${d.UniqueId.asString(this.id)}`);
      return this.logPrefix;
    }
    endVNode(b) {
      try {
        if (this.isDebugEnabled && e.Logger.debug(`${this}: endVNode(${b}): state: ${p[this.state]}, vNode: ${this.vNodeActivation}`), this.state !== p.STARTED) {
          this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "can't end non started tracer");
        } else {
          if (this.state = p.ENDED, null != this.vNodeActivation) {
            const a = this.vNodeActivation.spc;
            this.exitByException ? this.vNodeActivation.methodException() : this.vNodeActivation.exit();
            this.vNodeActivation = void 0;
            b && a.end();
            return a;
          }
        }
      } catch (K) {
        r.logAgentException(K);
      }
    }
  }
  a.Tracer = u;
  class z extends u {
    endWithContext(a, d, ...g) {
      if (c.isFunction(a)) {
        const c = this.endVNode(!1);
        let h, l;
        try {
          null != c && (h = new f.FunctionId(a), l = k.TransformerBase.createCallbackActivation(c, h, e.Agent.correlation.Creator.ONEAGENT_SDK));
        } catch (G) {
          r.logAgentException(G);
        }
        a = b.safeInvoke(d, a, [...g]);
        try {
          null != l && (n.addSample(h), l.done(a.exception)), null != c && c.end();
        } catch (G) {
          r.logAgentException(G);
        }
        return a.rethrow();
      }
      this.endVNode(!0);
      if (null != a) {
        throw this.sdkContext.logError(this.isDebugEnabled, this.moduleName, `end() first parameter must be a function, but received ${typeof a}`), new TypeError(`OneAgent SDK: Tracer.end() first parameter must be a function, but received ${typeof a}`);
      }
    }
    end(b, ...a) {
      return this.endWithContext(b, void 0, ...a);
    }
  }
  a.OutgoingTracer = z;
  class B extends z {
    constructor(b, a, c, d) {
      super(b, a, c);
      this.syncLink = d;
    }
    getDynatraceStringTag() {
      try {
        if (this.state !== p.STARTED) {
          return this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "getDynatraceStringTag() shall be called on started tracer"), "";
        }
        if (null != this.stringTag) {
          return this.stringTag;
        }
        if (null != this.blobTag) {
          const b = e.Agent.correlation.deserializeLinkFromBlob(this.blobTag);
          this.stringTag = b.serialize().dtTag;
          b.purge();
          return this.stringTag || "";
        }
        if (null != this.vNodeActivation) {
          const b = this.vNodeActivation.spc.createAddSerializeLink(this.syncLink, e.Agent.correlation.TaggingMode.DT_ONLY);
          null != b && (this.stringTag = b.dtTag);
        } else {
          this.isDebugEnabled && e.Logger.debug(`${this}: getDynatraceStringTag() but no Activation`);
        }
      } catch (I) {
        r.logAgentException(I);
      }
      return this.stringTag || "";
    }
    getDynatraceByteTag() {
      try {
        if (this.state !== p.STARTED) {
          return this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "getDynatraceByteTag() shall be called on started tracer"), Buffer.alloc(0);
        }
        if (null != this.blobTag) {
          return this.blobTag;
        }
        if (null != this.stringTag) {
          const b = e.Agent.correlation.deserializeLinkFromString(this.stringTag);
          this.blobTag = b.toBlob();
          b.purge();
          return this.blobTag;
        }
        null != this.vNodeActivation ? this.blobTag = this.vNodeActivation.spc.createAddSerializeLinkToBlob(this.syncLink) : this.isDebugEnabled && e.Logger.debug(`${this}: getDynatraceByteTag() but no Activation`);
      } catch (I) {
        r.logAgentException(I);
      }
      return this.blobTag || Buffer.alloc(0);
    }
  }
  a.OutgoingTaggableTracer = B;
  class A extends u {
    end() {
      this.endVNode(!1);
    }
  }
  a.IncomingTracer = A;
  class w extends A {
    getLink(b) {
      let a;
      c.isString(b) ? a = e.Agent.correlation.deserializeLinkFromString(b) : Buffer.isBuffer(b) ? a = e.Agent.correlation.deserializeLinkFromBlob(b) : null != b && this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "ignoring invalid tag");
      return a;
    }
  }
  a.IncomingTaggableTracer = w;
});
S("src/lib/agentapi/IncomingRemoteCall", "require exports assert util src/lib/Agent src/lib/AttachmentBase src/lib/agentapi/AgentApi src/lib/agentapi/Common src/lib/util/CoreUtil src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  function r(b, a, c) {
    return g.isObject(c) ? g.isString(c.serviceEndpoint) ? g.isString(c.serviceMethod) ? g.isString(c.serviceName) ? !0 : (b.logError(a, "IncomingRemoteCall", "traceIncomingRemoteCall: startData.serviceName is invalid"), !1) : (b.logError(a, "IncomingRemoteCall", "traceIncomingRemoteCall: startData.serviceMethod is invalid"), !1) : (b.logError(a, "IncomingRemoteCall", "traceIncomingRemoteCall: startData.serviceEndpoint is invalid"), !1) : (b.logError(a, "IncomingRemoteCall", "traceIncomingRemoteCall: startData is not an object"), 
    !1);
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class b extends m.SdkSensorBase {
    constructor(a, c, d) {
      super(a, c, d);
      e.strictEqual(b.instance, void 0, "Multiple instances of SdkIncomingRemoteCallSensor created");
      b.instance = this;
    }
  }
  a.SdkIncomingRemoteCallSensor = b;
  a.getApis = function(a) {
    return {create:function(c) {
      const e = b.instance;
      if (null == e) {
        return a.logWarn(n.isDebug(), "IncomingRemoteCall", "traceIncomingRemoteCall: no trace created as sensor is disabled"), new m.DummyIncomingTracer;
      }
      if (!n.isActive()) {
        return a.logWarn(e.isDebugEnabled, "IncomingRemoteCall", "traceIncomingRemoteCall: no trace created as SDK is inactive"), new m.DummyIncomingTracer;
      }
      if (!e.active) {
        return a.logWarn(e.isDebugEnabled, "IncomingRemoteCall", "traceIncomingRemoteCall: no trace created as sensor is not active"), new m.DummyIncomingTracer;
      }
      if (!r(a, e.isDebugEnabled, c)) {
        return new m.DummyIncomingTracer;
      }
      e.isDebugEnabled && f.Logger.debug(`${"IncomingRemoteCall"}: create() data: ${h.inspect(c)}`);
      return new d(e, a, c);
    }};
  };
  class d extends m.IncomingTaggableTracer {
    constructor(b, a, c) {
      super(b, a, "IncomingRemoteCall");
      this.startData = c;
    }
    startAsyncPath(b) {
      const a = new x(this.startData, this.sdkContext, this.isDebugEnabled), c = this.getLink(this.startData.dynatraceTag);
      return this.tryStartIncomingAsyncSubPath({functionId:b, link:c, attachmentCreator:a, creator:f.Agent.correlation.Creator.ONEAGENT_SDK});
    }
  }
  class l extends k.AttachmentBase {
    constructor(b, a) {
      super(b, f.Agent.correlation.AttachmentId.ATTACHMENT_REMOTE_CALL_SERVER_ID, 0);
      this.debug = a;
    }
    fillEntryData(b, a) {
      this.setMultipleFields(c => {
        const d = f.Agent.correlation.AttachmentFieldId;
        c.integer(d.REMOTE_CALL_PROTOCOL_TYPE_ID, f.Agent.correlation.RemoteCallWireProtocol.REMOTE_CALL_WIRE_PROTOCOL_ADK);
        c.stringCached(d.REMOTE_CALL_SERVICE_METHOD_ID, b.serviceMethod);
        c.stringCached(d.REMOTE_CALL_SERVICE_NAME_ID, b.serviceName);
        c.stringCached(d.REMOTE_CALL_SERVICE_ENDPOINT_ID, b.serviceEndpoint);
        g.isString(b.protocolName) ? c.stringCached(d.REMOTE_CALL_PROTOCOL_NAME_ID, b.protocolName) : null != b.protocolName && a.logWarn(this.debug, "IncomingRemoteCall", "traceIncomingRemoteCall: ignoring invalid startData.protocolName");
      });
    }
  }
  class x {
    constructor(b, a, c) {
      this.entryData = b;
      this.sdkContext = a;
      this.debug = c;
    }
    createAttachments(b) {
      b = new l(b, this.debug);
      if (b.valid) {
        try {
          b.fillEntryData(this.entryData, this.sdkContext);
        } catch (q) {
          c.logAgentException(q);
        }
      }
    }
  }
});
S("src/lib/agentapi/OutgoingRemoteCall", "require exports assert util src/lib/Agent src/lib/AttachmentBase src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/agentapi/AgentApi src/lib/agentapi/Common".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  function r(b, a, d) {
    return n.isObject(d) ? n.isString(d.serviceEndpoint) ? n.isString(d.serviceMethod) ? n.isString(d.serviceName) ? (d = c.validateConnectionInfo(d)) ? (b.logError(a, "OutgoingRemoteCall", `traceOutgoingRemoteCall: startData${d}`), !1) : !0 : (b.logError(a, "OutgoingRemoteCall", "traceOutgoingRemoteCall: startData.serviceName is invalid"), !1) : (b.logError(a, "OutgoingRemoteCall", "traceOutgoingRemoteCall: startData.serviceMethod is invalid"), !1) : (b.logError(a, "OutgoingRemoteCall", "traceOutgoingRemoteCall: startData.serviceEndpoint is invalid"), 
    !1) : (b.logError(a, "OutgoingRemoteCall", "traceOutgoingRemoteCall: startData is not an object"), !1);
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class b extends c.SdkSensorBase {
    constructor(a, c, d) {
      super(a, c, d);
      e.strictEqual(b.instance, void 0, "Multiple instances of SdkOutgoingRemoteCallSensor created");
      b.instance = this;
    }
  }
  a.SdkOutgoingRemoteCallSensor = b;
  a.getApis = function(a) {
    return {create:function(e) {
      const l = b.instance;
      if (null == l) {
        return a.logWarn(g.isDebug(), "OutgoingRemoteCall", "traceOutgoingRemoteCall: no trace created as sensor is disabled"), new c.DummyOutgoingTaggableTracer;
      }
      if (!g.isActive()) {
        return a.logWarn(l.isDebugEnabled, "OutgoingRemoteCall", "traceOutgoingRemoteCall: no trace created as SDK is inactive"), new c.DummyOutgoingTaggableTracer;
      }
      if (!l.active) {
        return a.logWarn(l.isDebugEnabled, "OutgoingRemoteCall", "traceOutgoingRemoteCall: no trace created as sensor is not active"), new c.DummyOutgoingTaggableTracer;
      }
      if (!r(a, l.isDebugEnabled, e)) {
        return new c.DummyOutgoingTaggableTracer;
      }
      l.isDebugEnabled && f.Logger.debug(`${"OutgoingRemoteCall"}: create() data: ${h.inspect(e)}`);
      return new d(l, a, e);
    }};
  };
  class d extends c.OutgoingTaggableTracer {
    constructor(b, a, c) {
      super(b, a, "OutgoingRemoteCall", !0);
      this.startData = c;
    }
    startAsyncPath(b) {
      const a = new x(this.startData, this.sdkContext, this.isDebugEnabled);
      return this.tryStartAsyncActivation({functionId:b, attachmentCreator:a, creator:f.Agent.correlation.Creator.ONEAGENT_SDK});
    }
  }
  class l extends k.AttachmentBase {
    constructor(b, a) {
      super(b, f.Agent.correlation.AttachmentId.ATTACHMENT_REMOTE_CALL_CLIENT_ID, 0);
      this.debug = a;
    }
    fillEntryData(b, a) {
      this.setMultipleFields(c => {
        var d = f.Agent.correlation;
        const e = d.AttachmentFieldId;
        c.integer(e.REMOTE_CALL_PROTOCOL_TYPE_ID, d.RemoteCallWireProtocol.REMOTE_CALL_WIRE_PROTOCOL_ADK);
        n.isString(b.protocolName) ? c.stringCached(e.REMOTE_CALL_PROTOCOL_NAME_ID, b.protocolName) : null != b.protocolName && a.logWarn(this.debug, "OutgoingRemoteCall", "traceOutgoingRemoteCall: ignoring invalid startData.protocolName");
        c.stringCached(e.REMOTE_CALL_SERVICE_METHOD_ID, b.serviceMethod);
        c.stringCached(e.REMOTE_CALL_SERVICE_NAME_ID, b.serviceName);
        c.stringCached(e.REMOTE_CALL_SERVICE_ENDPOINT_ID, b.serviceEndpoint);
        d = f.Agent.correlation.ChannelType;
        let g;
        if (null != b.host) {
          d = d.TCP_IP, g = b.host, c.stringCached(e.REMOTE_CALL_HOSTNAME_ID, b.host), n.isNumber(b.port) && (c.integer(e.REMOTE_CALL_PORTNO_ID, b.port), g += `:${b.port}`);
        } else {
          if (null != b.socketPath) {
            d = d.UNIX_DOMAIN_SOCKET, g = b.socketPath;
          } else {
            if (null != b.pipeName) {
              d = d.NAMED_PIPE, g = b.pipeName;
            } else {
              switch(b.channelType) {
                case 1:
                  d = d.TCP_IP;
                  break;
                case 2:
                  d = d.UNIX_DOMAIN_SOCKET;
                  g = null;
                  break;
                case 3:
                  d = d.NAMED_PIPE;
                  g = null;
                  break;
                case 4:
                  d = d.IN_PROCESS;
                  break;
                default:
                  d = d.OTHER;
              }
            }
          }
        }
        c.integer(e.REMOTE_CALL_CHANNEL_TYPE_ID, d);
        void 0 !== g && c.stringCachedOrUnavailable(e.REMOTE_CALL_CHANNEL_ENDPOINT_ID, g);
      });
    }
  }
  class x {
    constructor(b, a, c) {
      this.entryData = b;
      this.sdkContext = a;
      this.debug = c;
    }
    createAttachments(b) {
      b = new l(b, this.debug);
      if (b.valid) {
        try {
          b.fillEntryData(this.entryData, this.sdkContext);
        } catch (q) {
          m.logAgentException(q);
        }
      }
    }
  }
});
S("src/lib/agentapi/MessagingCommon", "require exports src/lib/Agent src/lib/AttachmentBase src/lib/agentapi/Common src/lib/util/CoreUtil src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.validateSystemInfo = function(a) {
    return k.isObject(a) ? k.isString(a.vendorName) ? k.isString(a.destinationName) ? !k.isNumber(a.destinationType) || 0 > a.destinationType || 1 < a.destinationType ? ".destinationType is invalid" : f.validateConnectionInfo(a) : ".destinationName is invalid" : ".vendorName is invalid" : " is not an object";
  };
  class m {
    constructor(a, e, b, d) {
      this.attachmentId = a;
      this.messagingSystem = e;
      this.moduleName = b;
      this.debug = d;
    }
    createAttachments(a) {
      a = new g(a, this.attachmentId);
      if (a.valid) {
        try {
          this.attachment = a, a.fillEntryData(this.messagingSystem);
        } catch (r) {
          n.logAgentException(r);
        }
      }
    }
    setVendorMessageId(a, f, b) {
      if (null != this.attachment) {
        if (k.isString(a)) {
          try {
            this.debug && e.Logger.debug(`${this.moduleName}: setVendorMessageId(): ${a}`), this.attachment.setStringCached(e.Agent.correlation.AttachmentFieldId.MESSAGING_NODE_VENDOR_MESSAGE_ID, a);
          } catch (d) {
            n.logAgentException(d);
          }
        } else {
          f.logWarn(this.debug, this.moduleName, `${b}: setVendorMessageId() vendorMessageId is no string`);
        }
      } else {
        this.debug && e.Logger.debug(`${this.moduleName}: no valid MessagingAttachment in setVendorMessageId()`);
      }
    }
    setCorrelationId(a, f, b) {
      if (null != this.attachment) {
        if (k.isString(a)) {
          try {
            this.debug && e.Logger.debug(`${this.moduleName}: setCorrelationId(): ${a}`), this.attachment.setStringCached(e.Agent.correlation.AttachmentFieldId.MESSAGING_NODE_VENDOR_CORRELATION_ID, a);
          } catch (d) {
            n.logAgentException(d);
          }
        } else {
          f.logWarn(this.debug, this.moduleName, `${b}: setCorrelationId() correlationId is no string`);
        }
      } else {
        this.debug && e.Logger.debug(`${this.moduleName}: no valid MessagingAttachment in setCorrelationId()`);
      }
    }
  }
  a.MessagingAttachmentCreator = m;
  class g extends h.AttachmentBase {
    constructor(a, e) {
      super(a, e, 0);
    }
    fillEntryData(a) {
      this.setMultipleFields(c => {
        var b = e.Agent.correlation;
        const d = b.AttachmentFieldId;
        c.integer(d.MESSAGING_NODE_WILL_HAVE_DESTINATION_TYPE, 1);
        c.integer(d.MESSAGING_NODE_WILL_HAVE_TOPOLOGY, 1);
        c.integer(d.MESSAGING_NODE_WILL_HAVE_QUEUE_VENDOR_NAME, 1);
        this.id === b.AttachmentId.ATTACHMENT_MESSAGING_SERVER_ID && c.integer(d.MESSAGING_NODE_TRANSMISSION_TYPE, b.TransmissionType.PROCESS);
        c.stringCached(d.MESSAGING_NODE_DESTINATION_TYPE, 0 === a.destinationType ? "QUEUE" : "TOPIC");
        c.stringCached(d.MESSAGING_NODE_DESTINATION, a.destinationName);
        c.stringCached(d.MESSAGING_NODE_QUEUE_VENDOR, a.vendorName);
        b = b.MessagingTopology;
        if (null != a.host) {
          c.integer(d.MESSAGING_NODE_TOPOLOGY, b.EXTERNAL), c.stringCached(d.MESSAGING_NODE_HOSTNAME, a.host), k.isNumber(a.port) && c.integer(d.MESSAGING_NODE_PORT, a.port);
        } else {
          if (null != a.socketPath || null != a.pipeName) {
            c.integer(d.MESSAGING_NODE_TOPOLOGY, b.EXTERNAL);
          } else {
            switch(a.channelType) {
              case 1:
              case 2:
              case 3:
                c.integer(d.MESSAGING_NODE_TOPOLOGY, b.EXTERNAL);
                break;
              case 4:
                c.integer(d.MESSAGING_NODE_TOPOLOGY, b.EMBEDDED);
                break;
              default:
                c.integer(d.MESSAGING_NODE_TOPOLOGY, b.NOT_SET);
            }
          }
        }
      });
    }
  }
});
S("test/testUtil/NiGeneratedStubs", ["require", "exports"], function(t, a) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.SupportAlertTypeStub = {Crash:0, InstrumentationProblem:1, InstallationCorrupted:2};
  a.LogLevelStub = {INFO:0, WARNING:1, SEVERE:2, DEBUG:3, NONE:4};
  a.AgentMonitoringModeStub = {INVALID:0, FULL:1, CLOUD_INFRASTRUCTURE_MONITORING:2};
  a.AmbientSamplingServiceIndicationStub = {OFF_SERVICE:0, ON_SERVICE:1};
  a.AgentConfigurationStub = {DEFAULT_STRING_TRUNCATION_LIMIT:0, DEFAULT_WEBREQUEST_STRING_TRUNCATION_LIMIT:1};
  a.AttachmentFieldIdStub = {EXCEPTION_OBJECT_ID:0, EXCEPTION_MESSAGE:1, EXCEPTION_THROWABLE:2, EXCEPTION_STACKTRACE_NEXT_LINE:3, EXCEPTION_STACKTRACE_CLASS:4, EXCEPTION_STACKTRACE_METHOD:5, EXCEPTION_STACKTRACE_FILE:6, EXCEPTION_STACKTRACE_LINE_NUMBER:7, WEBREQUEST_CLIENT_IP:8, WEBREQUEST_REQUEST_METHOD:9, WEBREQUEST_URI:10, WEBREQUEST_QUERY_STRING:11, WEBREQUEST_REQUESTED_HOSTNAME:12, WEBREQUEST_REQUEST_HEADER_SIZE:13, WEBREQUEST_REQUEST_HEADERS:14, WEBREQUEST_FORWARDED_FOR:15, WEBREQUEST_REMOTE_ADRESS:16, 
  WEBREQUEST_RESPONSE_STATUS:17, WEBREQUEST_RESPONSE_HEADER_SIZE:18, WEBREQUEST_APPLICATION_ID:19, WEBREQUEST_RESPONSE_HEADERS:20, WEBREQUEST_REQUEST_PARAMETERS:21, WEBREQUEST_SERVERNAME:22, WEBREQUEST_CONTEXTROOT:23, CLIENT_WEB_REQUEST_URI:24, CLIENT_WEB_REQUEST_QUERY:25, CLIENT_WEB_REQUEST_METHOD:26, CLIENT_WEB_REQUEST_REQUEST_HEADER:27, CLIENT_WEB_REQUEST_RESPONSE_HEADER:28, CLIENT_WEB_REQUEST_RESPONSECODE:29, CLIENT_WEB_REQUEST_HOSTNAME:30, CLIENT_WEB_REQUEST_PORTNO:31, SQL_STATEMENT:32, SQL_BIND_VALUES:33, 
  SQL_NUM_ROWS_RETURNED:34, SQL_METHOD_TYPE:35, SQL_RESULTSET_FETCH_SIZE:36, SQL_ROUND_TRIPS:37, SQL_BIND_KEYS:38, CONNECTION_POOL_SIZE:39, CONNECTION_POOL_NAME:40, CONNECTION_POOL_DB:41, CONNECTION_POOL_URL:42, CONNECTION_POOL_DBHOST:43, CONNECTION_POOL_DBTYPE:44, CONNECTION_POOL_TYPE:45, CONNECTION_POOL_DBPORTNO:46, CONNECTION_POOL_TOPOLOGY:47, CONNECTION_POOL_AGGREGATION_MECHANISM:48, CONNECTION_POOL_INSTANCENAME:49, AGGREGATION_EXECCOUNT:50, AGGREGATION_EXCEPTIONCOUNT:51, CUSTOMSERVICE_SERVICE_ID:52, 
  CUSTOMSERVICE_SERVICE_NAME:53, CUSTOMSERVICE_SERVICE_METHOD:54, EXTERNALCALL_CALL_TYPE_ID:55, EXTERNALCALL_OPERATION_NAME_ID:56, EXTERNALCALL_HOSTNAME_ID:57, EXTERNALCALL_PORTNO_ID:58, REMOTE_CALL_PROTOCOL_TYPE_ID:59, REMOTE_CALL_PROTOCOL_NAME_ID:60, REMOTE_CALL_SERVICE_METHOD_ID:61, REMOTE_CALL_SERVICE_NAME_ID:62, REMOTE_CALL_SERVICE_ENDPOINT_ID:63, REMOTE_CALL_HOSTNAME_ID:64, REMOTE_CALL_PORTNO_ID:65, REMOTE_CALL_CHANNEL_TYPE_ID:66, REMOTE_CALL_CHANNEL_ENDPOINT_ID:67, MESSAGING_NODE_DESTINATION:68, 
  MESSAGING_NODE_TYPE:69, MESSAGING_NODE_SIZE:70, MESSAGING_NODE_TRANSMISSION_TYPE:71, MESSAGING_NODE_QUEUE_VENDOR:72, MESSAGING_NODE_DESTINATION_TYPE:73, MESSAGING_NODE_HOSTNAME:74, MESSAGING_NODE_PORT:75, MESSAGING_NODE_TOPOLOGY:76, MESSAGING_NODE_IS_TEMPORARY_QUEUE:77, MESSAGING_NODE_VENDOR_MESSAGE_ID:78, MESSAGING_NODE_VENDOR_CORRELATION_ID:79, MESSAGING_NODE_WILL_HAVE_DESTINATION_TYPE:80, MESSAGING_NODE_WILL_HAVE_IPCONTAINER:81, MESSAGING_NODE_WILL_HAVE_TOPOLOGY:82, MESSAGING_NODE_WILL_HAVE_TEMPORARY_QUEUE:83, 
  MESSAGING_NODE_WILL_HAVE_QUEUE_VENDOR_NAME:84, MESSAGING_NODE_WILL_HAVE_MQ_QUEUE_MANAGER_NAME:85, AWS_LAMBDA_SERVICE_FUNCTION_NAME:86, AWS_LAMBDA_SERVICE_INVOKED_FUNCTION_ARN:87, AWS_LAMBDA_SERVICE_REGION:88, AWS_LAMBDA_SERVICE_ACCOUNT_ID:89, SERVICECALLATTRIBUTES_SERVICECALLATTRIBUTES_ATTRIBUTE_ID:90, SERVICECALLATTRIBUTES_SERVICECALLATTRIBUTES_ATTRIBUTE_CREATOR:91, ATTACHMENT_CAPTURED_ARG_INTEGER:92, ATTACHMENT_CAPTURED_ARG_DOUBLE:93, ATTACHMENT_CAPTURED_ARG_STRING:94, AWS_LAMBDA_CLIENT_FUNCTION_NAME:95, 
  AWS_LAMBDA_CLIENT_REGION:96, AWS_LAMBDA_CLIENT_REQUEST_ID:97, AWS_LAMBDA_CLIENT_TRACE_ID:98};
  a.AttachmentIdStub = {ATTACHMENT_AUTOSENSOR_ID:0, ATTACHMENT_EXCEPTION_ID:1, ATTACHMENT_WEBREQUEST_ID:2, ATTACHMENT_CLIENT_WEBREQUEST_ID:3, ATTACHMENT_SQL_ID:4, ATTACHMENT_CONNECTION_POOL_ID:5, ATTACHMENT_SQL_RESULTSET_AGGREGATION_ID:6, ATTACHMENT_CUSTOMSERVICE_ID:7, ATTACHMENT_SERVICECALLATTRIBUTES_ID:8, ATTACHMENT_EXTERNAL_CALL_ID:9, ATTACHMENT_REMOTE_CALL_CLIENT_ID:10, ATTACHMENT_REMOTE_CALL_SERVER_ID:11, ATTACHMENT_MESSAGING_CLIENT_ID:12, ATTACHMENT_MESSAGING_SERVER_ID:13, ATTACHMENT_AWS_LAMBDA_SERVICE_ID:14, 
  ATTACHMENT_AWS_LAMBDA_CLIENT_ID:15};
  a.AttachmentTargetStub = {NextNodeEvent:0, CurrentNode:1, SpecificNode:2};
  a.ChannelTypeStub = {OTHER:0, TCP_IP:1, UNIX_DOMAIN_SOCKET:2, NAMED_PIPE:3, IN_PROCESS:4};
  a.ConnectionPoolTopologyStub = {TOPOLOGY_NOT_SET:0, TOPOLOGY_SINGLE_SERVER:1, TOPOLOGY_EMBEDDED:2, TOPOLOGY_FAILOVER:3, TOPOLOGY_LOAD_BALANCING:4, TOPOLOGY_LOCAL_IPC:5, TOPOLOGY_SERVER_UNSPECIFIED:6};
  a.CreatorStub = {NONE:0, ONEAGENT_SDK:1};
  a.DbAggregationMechanismStub = {DB_AGGREGATION_MECHANISM_UNDEFINED:0, DB_AGGREGATION_MECHANISM_JDBC:1, DB_AGGREGATION_MECHANISM_MONGO_DB:2, DB_AGGREGATION_MECHANISM_ADO_DOTNET:3, DB_AGGREGATION_MECHANISM_MONGO3_DB:4, DB_AGGREGATION_MECHANISM_MONGO_DB_ASYNC:5, DB_AGGREGATION_MECHANISM_CQL:6, DB_AGGREGATION_MECHANISM_ADK_SQL:7, DB_AGGREGATION_MECHANISM_NO_AGGREGATION:8};
  a.DbMethodTypeStub = {DB_METHOD_TYPE_UNKNOWN:0, DB_METHOD_TYPE_CONNECTION_ACQUISITION:1, DB_METHOD_TYPE_MONGO_DB_DISTINCT:2, DB_METHOD_TYPE_MONGO_DB_FIND:3, DB_METHOD_TYPE_MONGO_DB_FIND_AND_MODIFY:4, DB_METHOD_TYPE_MONGO_DB_FIND_ONE:5, DB_METHOD_TYPE_MONGO_DB_GET_COUNT:6, DB_METHOD_TYPE_MONGO_DB_INSERT:7, DB_METHOD_TYPE_MONGO_DB_REMOVE:8, DB_METHOD_TYPE_MONGO_DB_SAVE:9, DB_METHOD_TYPE_MONGO_DB_UPDATE:10, DB_METHOD_TYPE_MONGO_DB_AGGREGATE:11, DB_METHOD_TYPE_MONGO_DB_GROUP:12, DB_METHOD_TYPE_MONGO_DB_MAP_REDUCE:13, 
  DB_METHOD_TYPE_MONGO_DB_NEXT:14, DB_METHOD_TYPE_MONGO_DB_AUTHENTICATE:15, DB_METHOD_TYPE_MONGO_DB_COMMAND:16, DB_METHOD_TYPE_MONGO_DB_DROPDATABASE:17, DB_METHOD_TYPE_MONGO_DB_LISTCOLLECTIONS:18, DB_METHOD_TYPE_MONGO_DB_CREATECOLLECTION:19, DB_METHOD_TYPE_MONGO_DB_FIND_AND_REMOVE:20};
  a.DbServiceTypeStub = {DB_SERVICE_TYPE_UNDEFINED:0, DB_SERVICE_TYPE_CALLABLE:1, DB_SERVICE_TYPE_UPDATE:2, DB_SERVICE_TYPE_QUERY:3, DB_SERVICE_TYPE_PREPARE_ONLY:4, DB_SERVICE_TYPE_CONNECTION_UNDEFINED:5, DB_SERVICE_TYPE_CONNECTION_ACQUISITION:6, DB_SERVICE_TYPE_CONNECTION_COMMIT:7, DB_SERVICE_TYPE_CONNECTION_ROLLBACK:8, DB_SERVICE_TYPE_CONNECTION_AUTHENTICATION:9, DB_SERVICE_TYPE_MONGO_DB_READ:10, DB_SERVICE_TYPE_MONGO_DB_WRITE:11, DB_SERVICE_TYPE_MONGO_DB_AGGREGATION:12, DB_SERVICE_TYPE_MONGO_DB_COMMAND:13, 
  DB_SERVICE_TYPE_COUCHBASE_DB_READ:14, DB_SERVICE_TYPE_COUCHBASE_DB_WRITE:15, DB_SERVICE_TYPE_COUCHBASE_DB_QUERY:16, DB_SERVICE_TYPE_COUCHBASE_DB_VIEW:17};
  a.ExternalCallTypeStub = {UNKNOWN_SERVICE:0, REDIS:1, MEMCACHED:2};
  a.MethodCategoryStub = {None:0, FileSystemAccess:1, Database:2, WebRequest:3, AsyncCall:4};
  a.RemoteCallWireProtocolStub = {REMOTE_CALL_WIRE_PROTOCOL_ADK:0, REMOTE_CALL_WIRE_PROTOCOL_GRPC:1, REMOTE_CALL_WIRE_PROTOCOL_GRPC_BIDI:2, REMOTE_CALL_WIRE_PROTOCOL_GRPC_UNARY:3, REMOTE_CALL_WIRE_PROTOCOL_GRPC_SERVERSTREAM:4, REMOTE_CALL_WIRE_PROTOCOL_GRPC_CLIENTSTREAM:5};
  a.SensorIdStub = {SENSOR_ID_UNKNOWN:0, SENSOR_ID_NODEJS:1, SENSOR_ID_NODEJS_LOST_AND_FOUND:2, SENSOR_ID_NODEJS_ONEAGENTSDK:3};
  a.MessagingTopologyStub = {NOT_SET:0, EXTERNAL:1, EMBEDDED:2};
  a.TransmissionTypeStub = {UNKNOWN:0, RECEIVE:1, PROCESS:2};
  a.MessagingMessagetypeStub = {MQSERIES_MESSAGE:0, AMQP_MESSAGE:1, KAFKA_MESSAGE:2};
  a.TaggingModeStub = {DT_ONLY:0, DT_AND_TC:1, TC_ONLY:2};
  a.MetricTypeStub = {INTEGER_COUNTER:0, INTEGER_GAUGE:1, INTEGER_SUMMARY_STATISTICS:2, FLOATING_POINT_COUNTER:3, FLOATING_POINT_GAUGE:4, FLOATING_POINT_SUMMARY_STATISTICS:5};
});
S("src/lib/agentapi/IncomingMessaging", "require exports assert util src/lib/Agent src/lib/agentapi/AgentApi src/lib/agentapi/Common src/lib/agentapi/MessagingCommon test/testUtil/NiGeneratedStubs".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class c extends n.SdkSensorBase {
    constructor(b, a, f) {
      super(b, a, f);
      e.strictEqual(c.instance, void 0, "Multiple instances of SdkIncomingMessagingSensor created");
      c.instance = this;
    }
  }
  a.SdkIncomingMessagingSensor = c;
  a.getApis = function(a) {
    return {create:function(d) {
      const e = c.instance;
      if (null == e) {
        return a.logWarn(k.isDebug(), "IncomingMessaging", "traceIncomingMessage: no trace created as sensor is disabled"), new r;
      }
      if (!k.isActive()) {
        return a.logWarn(e.isDebugEnabled, "IncomingMessaging", "traceIncomingMessage: no trace created as SDK is inactive"), new r;
      }
      if (!e.active) {
        return a.logWarn(e.isDebugEnabled, "IncomingMessaging", "traceIncomingMessage: no trace created as sensor is not active"), new r;
      }
      const g = m.validateSystemInfo(d);
      if (null != g) {
        return a.logError(e.isDebugEnabled, "IncomingMessaging", `traceIncomingMessage: startData${g}`), new r;
      }
      e.isDebugEnabled && f.Logger.debug(`${"IncomingMessaging"}: create() data: ${h.inspect(d)}`);
      return new b(e, a, d);
    }};
  };
  class r extends n.DummyIncomingTracer {
    setVendorMessageId() {
      return this;
    }
    setCorrelationId() {
      return this;
    }
  }
  a.DummyIncomingMessageTracer = r;
  class b extends n.IncomingTaggableTracer {
    constructor(b, a, c) {
      super(b, a, "IncomingMessaging");
      this.startData = c;
    }
    setVendorMessageId(b) {
      null == this.attachmentCreator || this.state !== n.TracerState.STARTED ? this.sdkContext.logWarn(this.isDebugEnabled, "IncomingMessaging", "traceIncomingMessage: setVendorMessageId() shall be called on a started tracer") : this.attachmentCreator.setVendorMessageId(b, this.sdkContext, "traceIncomingMessage");
      return this;
    }
    setCorrelationId(b) {
      null == this.attachmentCreator || this.state !== n.TracerState.STARTED ? this.sdkContext.logWarn(this.isDebugEnabled, "IncomingMessaging", "traceIncomingMessage: setCorrelationId() shall be called on a started tracer") : this.attachmentCreator.setCorrelationId(b, this.sdkContext, "traceIncomingMessage");
      return this;
    }
    startAsyncPath(b) {
      this.attachmentCreator = new m.MessagingAttachmentCreator(f.Agent.correlation.AttachmentId.ATTACHMENT_MESSAGING_SERVER_ID, this.startData, "IncomingMessaging", this.isDebugEnabled);
      const a = this.getLink(this.startData.dynatraceTag);
      return this.tryStartIncomingAsyncSubPath({functionId:b, link:a, attachmentCreator:this.attachmentCreator, creator:g.CreatorStub.ONEAGENT_SDK});
    }
  }
});
S("src/lib/agentapi/OutgoingMessaging", "require exports assert util src/lib/Agent src/lib/agentapi/AgentApi src/lib/agentapi/Common src/lib/agentapi/MessagingCommon test/testUtil/NiGeneratedStubs".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class c extends n.SdkSensorBase {
    constructor(b, a, f) {
      super(b, a, f);
      e.strictEqual(c.instance, void 0, "Multiple instances of SdkOutgoingMessagingSensor created");
      c.instance = this;
    }
  }
  a.SdkOutgoingMessagingSensor = c;
  a.getApis = function(a) {
    return {create:function(d) {
      const e = c.instance;
      if (null == e) {
        return a.logWarn(k.isDebug(), "OutgoingMessaging", "traceOutgoingMessage: no trace created as sensor is disabled"), new r;
      }
      if (!k.isActive()) {
        return a.logWarn(e.isDebugEnabled, "OutgoingMessaging", "traceOutgoingMessage: no trace created as SDK is inactive"), new r;
      }
      if (!e.active) {
        return a.logWarn(e.isDebugEnabled, "OutgoingMessaging", "traceOutgoingMessage: no trace created as sensor is not active"), new r;
      }
      const g = m.validateSystemInfo(d);
      if (null != g) {
        return a.logError(e.isDebugEnabled, "OutgoingMessaging", `traceOutgoingMessage: startData${g}`), new r;
      }
      e.isDebugEnabled && f.Logger.debug(`${"OutgoingMessaging"}: create() data: ${h.inspect(d)}`);
      return new b(e, a, d);
    }};
  };
  class r extends n.DummyOutgoingTaggableTracer {
    setVendorMessageId() {
      return this;
    }
    setCorrelationId() {
      return this;
    }
  }
  a.DummyOutgoingMessageTracer = r;
  class b extends n.OutgoingTaggableTracer {
    constructor(b, a, c) {
      super(b, a, "OutgoingMessaging", !1);
      this.startData = c;
    }
    setVendorMessageId(b) {
      null == this.attachmentCreator || this.state !== n.TracerState.STARTED ? this.sdkContext.logWarn(this.isDebugEnabled, "OutgoingMessaging", "traceOutgoingMessage: setVendorMessageId() shall be called on a started tracer") : this.attachmentCreator.setVendorMessageId(b, this.sdkContext, "traceOutgoingMessage");
      return this;
    }
    setCorrelationId(b) {
      null == this.attachmentCreator || this.state !== n.TracerState.STARTED ? this.sdkContext.logWarn(this.isDebugEnabled, "OutgoingMessaging", "traceOutgoingMessage: setCorrelationId() shall be called on a started tracer") : this.attachmentCreator.setCorrelationId(b, this.sdkContext, "traceOutgoingMessage");
      return this;
    }
    startAsyncPath(b) {
      this.attachmentCreator = new m.MessagingAttachmentCreator(f.Agent.correlation.AttachmentId.ATTACHMENT_MESSAGING_CLIENT_ID, this.startData, "OutgoingMessaging", this.isDebugEnabled);
      return this.tryStartAsyncActivation({functionId:b, attachmentCreator:this.attachmentCreator, creator:g.CreatorStub.ONEAGENT_SDK});
    }
  }
});
S("src/lib/agentapi/RequestAttributes", "require exports assert src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/Agent src/lib/AttachmentBase src/lib/SubPathContext src/lib/agentapi/AgentApi src/lib/agentapi/Common".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  function r(a, c, e) {
    const l = d.instance;
    if (null == l) {
      a.logWarn(g.isDebug(), "RequestAttributes", "addCustomRequestAttribute: attribute not added as sensor is disabled");
    } else {
      if (g.isActive()) {
        if (l.active) {
          var p = l.isDebugEnabled;
          p && k.Logger.debug(`${"RequestAttributes"}: addCustomRequestAttribute() key: ${c}, value: ${e}`);
          if (h.isString(c)) {
            if (h.isString(e) || h.isNumber(e)) {
              try {
                const d = b(p);
                if (null == d) {
                  a.logWarn(l.isDebugEnabled, "RequestAttributes", `addCustomRequestAttribute: attribute <${c}> not added because no active trace context found`);
                } else {
                  var m = k.Agent.correlation;
                  (new n.AttachmentBase(d, m.AttachmentId.ATTACHMENT_SERVICECALLATTRIBUTES_ID, 0, m.AttachmentTarget.CurrentNode)).setMultipleFields(b => {
                    const a = m.AttachmentFieldId;
                    b.stringCached(a.SERVICECALLATTRIBUTES_SERVICECALLATTRIBUTES_ATTRIBUTE_ID, c);
                    b.integer(a.SERVICECALLATTRIBUTES_SERVICECALLATTRIBUTES_ATTRIBUTE_CREATOR, m.Creator.ONEAGENT_SDK);
                    h.isString(e) ? b.stringCached(a.ATTACHMENT_CAPTURED_ARG_STRING, e) : b.float(a.ATTACHMENT_CAPTURED_ARG_DOUBLE, e);
                  });
                }
              } catch (C) {
                f.logAgentException(C);
              }
            } else {
              a.logError(l.isDebugEnabled, "RequestAttributes", "addCustomRequestAttribute: value is no string nor a number");
            }
          } else {
            a.logError(l.isDebugEnabled, "RequestAttributes", "addCustomRequestAttribute: key is no string");
          }
        } else {
          a.logWarn(l.isDebugEnabled, "RequestAttributes", "addCustomRequestAttribute: attribute not added as sensor is not active");
        }
      } else {
        a.logWarn(l.isDebugEnabled, "RequestAttributes", "addCustomRequestAttribute: attribute not added as SDK is inactive");
      }
    }
  }
  function b(b) {
    const a = m.SubPathContext.getActiveContext();
    if (null == a) {
      b && k.Logger.debug("RequestAttributes: getActivation: no SPC");
    } else {
      var c = a.currentActivation;
      if (null != c) {
        return b && k.Logger.debug(`${"RequestAttributes"}: using activation ${c} from current spc ${a}`), c;
      }
      b && k.Logger.debug(`${"RequestAttributes"}: curr spc ${a} has not activation`);
      var d = a.parentExecutor;
      if (null != d) {
        c = d.currentActivation;
        if (null != c) {
          return b && k.Logger.debug(`${"RequestAttributes"}: using activation ${c} from parent spc ${d}, curSpc: ${a}`), c;
        }
        b && k.Logger.debug(`${"RequestAttributes"}: parent spc ${d} has not activation, curSpc: ${a}`);
      } else {
        b && k.Logger.debug(`${"RequestAttributes"}: no parentExecutor set on spc ${a}`);
      }
    }
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class d extends c.SdkSensorBase {
    constructor(b, a, c) {
      super(b, a, c);
      e.strictEqual(d.instance, void 0, "Multiple instances of SdkScavSensor created");
      d.instance = this;
    }
  }
  a.SdkScavSensor = d;
  a.getApis = function(b) {
    return {addCustomRequestAttribute:function(a, c) {
      return r(b, a, c);
    }};
  };
});
S("src/lib/agentapi/Metrics", "require exports src/lib/util/CoreUtil src/lib/Agent src/lib/RunTimeProperty src/lib/agentapi/AgentApi".split(" "), function(t, a, e, h, f, k) {
  function n(b, a, c, d) {
    const f = m.value;
    if (!k.isActive()) {
      return b.logWarn(f, "Metrics", `${a}: metric not created as SDK is inactive`), !1;
    }
    if (!e.isString(c) || "" === c || 100 < Buffer.byteLength(c)) {
      return b.logError(f, "Metrics", `${a}: metric not created as name is invalid: ${c}`), !1;
    }
    if (null != d) {
      if (!e.isObject(d)) {
        return b.logError(f, "Metrics", `${a}: metric not created as options is no object`), !1;
      }
      if (null != d.unit && !e.isString(d.unit)) {
        return b.logError(f, "Metrics", `${a}: metric not created as options.unit is invalid`), !1;
      }
      if (null != d.dimensionName && (!e.isString(d.dimensionName) || "" === d.dimensionName)) {
        return b.logError(f, "Metrics", `${a}: metric not created as options.dimensionName is invalid`), !1;
      }
      f && h.Logger.debug(`${a}: name: ${c}, unit: ${d.unit}, dimensionName: ${d.dimensionName})`);
    } else {
      f && h.Logger.debug(`${a}: name: ${c}`);
    }
    return !0;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const m = new f.BooleanProperty("SdkMetrics", !1);
  a.getApis = function(b) {
    return {createIntegerCounterMetric:function(a, c) {
      if (n(b, "createIntegerCounterMetric", a, c)) {
        try {
          var e = new d(b, a, h.Agent.metrics.MetricType.INTEGER_COUNTER, c);
        } catch (C) {
          b.logWarn(m.value, "Metrics", `createIntegerCounterMetric: failed to create metric: ${C.message}`), e = new g;
        }
      } else {
        e = new g;
      }
      return e;
    }, createFloatCounterMetric:function(a, c) {
      if (n(b, "createFloatCounterMetric", a, c)) {
        try {
          var e = new d(b, a, h.Agent.metrics.MetricType.FLOATING_POINT_COUNTER, c);
        } catch (C) {
          b.logWarn(m.value, "Metrics", `createFloatCounterMetric: failed to create metric: ${C.message}`), e = new g;
        }
      } else {
        e = new g;
      }
      return e;
    }, createIntegerGaugeMetric:function(a, d) {
      if (n(b, "createIntegerGaugeMetric", a, d)) {
        try {
          var e = new l(b, a, h.Agent.metrics.MetricType.INTEGER_GAUGE, d);
        } catch (C) {
          b.logWarn(m.value, "Metrics", `createIntegerGaugeMetric: failed to create metric: ${C.message}`), e = new c;
        }
      } else {
        e = new c;
      }
      return e;
    }, createFloatGaugeMetric:function(a, d) {
      if (n(b, "createFloatGaugeMetric", a, d)) {
        try {
          var e = new l(b, a, h.Agent.metrics.MetricType.FLOATING_POINT_GAUGE, d);
        } catch (C) {
          b.logWarn(m.value, "Metrics", `createFloatGaugeMetric: failed to create metric: ${C.message}`), e = new c;
        }
      } else {
        e = new c;
      }
      return e;
    }, createIntegerStatisticsMetric:function(a, c) {
      if (n(b, "createIntegerStatisticsMetric", a, c)) {
        try {
          var d = new x(b, a, h.Agent.metrics.MetricType.INTEGER_SUMMARY_STATISTICS, c);
        } catch (C) {
          b.logWarn(m.value, "Metrics", `createIntegerStatisticsMetric: failed to create metric: ${C.message}`), d = new r;
        }
      } else {
        d = new r;
      }
      return d;
    }, createFloatStatisticsMetric:function(a, c) {
      if (n(b, "createFloatStatisticsMetric", a, c)) {
        try {
          var d = new x(b, a, h.Agent.metrics.MetricType.FLOATING_POINT_SUMMARY_STATISTICS, c);
        } catch (C) {
          b.logWarn(m.value, "Metrics", `createFloatStatisticsMetric: failed to create metric: ${C.message}`), d = new r;
        }
      } else {
        d = new r;
      }
      return d;
    }};
  };
  class g {
    increaseBy() {
    }
  }
  class c {
    setValue() {
    }
  }
  class r {
    addValue() {
    }
  }
  class b {
    constructor(b, a, c, d = {}) {
      this.sdkContext = b;
      const {unit:e, dimensionName:f} = d;
      this.metric = new h.Agent.metrics.NiSdkMetric(c, a, e, f);
    }
    addSample(b, a) {
      if (k.isActive()) {
        if (e.isNumber(b)) {
          try {
            this.metric.addSample(b, a);
          } catch (v) {
            this.sdkContext.logWarn(m.value, "Metrics", `failed to record metric sample: ${v.message}`);
          }
        } else {
          this.sdkContext.logError(m.value, "Metrics", "failed to record metric as value is not a number");
        }
      }
    }
  }
  class d extends b {
    increaseBy(b, a) {
      this.addSample(b, a);
    }
  }
  class l extends b {
    setValue(b, a) {
      this.addSample(b, a);
    }
  }
  class x extends b {
    addValue(b, a) {
      this.addSample(b, a);
    }
  }
  a.testExports = {DummyCounterMetric:g, DummyGaugeMetric:c, DummyStatisticsMetric:r, CounterMetric:d, GaugeMetric:l, StatisticsMetric:x};
});
S("src/lib/agentapi/AgentApi", "require exports src/lib/CallbackWrappingHelper src/lib/SubPathContext src/lib/RunTimeProperty src/lib/Logger src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/agentapi/Common src/lib/agentapi/Database src/lib/agentapi/IncomingRemoteCall src/lib/agentapi/OutgoingRemoteCall src/lib/agentapi/IncomingMessaging src/lib/agentapi/OutgoingMessaging src/lib/agentapi/RequestAttributes src/lib/agentapi/Metrics".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, 
x, p) {
  function q() {
    return !B.value;
  }
  function v() {
    return A.value;
  }
  function D(b) {
    if (!n.isFunction(b)) {
      return b;
    }
    let a = b;
    try {
      const c = h.SubPathContext.getActiveContext();
      null != c && (a = e.CallbackWrappingHelper.wrapCallbackContextPassing({spc:c, origCb:b}));
    } catch (K) {
      m.logAgentException(K);
    }
    return a;
  }
  function C() {
    return q() ? 0 : 1;
  }
  function u() {
    const a = new g.SdkContext, e = c.getApis(a), f = r.getApis(a), h = b.getApis(a), k = d.getApis(a), m = l.getApis(a), u = x.getApis(a), q = p.getApis(a);
    return {passContext:D, traceSQLDatabaseRequest:e.createSQL, traceIncomingRemoteCall:f.create, traceOutgoingRemoteCall:h.create, traceIncomingMessage:k.create, traceOutgoingMessage:m.create, addCustomRequestAttribute:u.addCustomRequestAttribute, getCurrentState:C, createIntegerCounterMetric:q.createIntegerCounterMetric, createFloatCounterMetric:q.createFloatCounterMetric, createIntegerGaugeMetric:q.createIntegerGaugeMetric, createFloatGaugeMetric:q.createFloatGaugeMetric, createIntegerStatisticsMetric:q.createIntegerStatisticsMetric, 
    createFloatStatisticsMetric:q.createFloatStatisticsMetric, setLoggingCallbacks(b) {
      n.isObject(b) ? (a.warnCb = n.isFunction(b.warning) ? b.warning : void 0, a.errorCb = n.isFunction(b.error) ? b.error : void 0) : (a.warnCb = void 0, a.errorCb = void 0);
    }};
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  const z = new f.BooleanProperty("SdkDisabled"), B = new f.BooleanProperty("SdkInactive"), A = new f.BooleanProperty("Sdk");
  a.isEnabled = function() {
    return !z.value;
  };
  a.isActive = q;
  a.isDebug = v;
  a.getAgentApi = function(b) {
    let a;
    switch(b) {
      case 1:
        a = {passContext:D};
        break;
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
        a = u();
    }
    v() && k.debug(`getAgentApi(${b}) returns ${a}`);
    return a;
  };
});
S("src/lib/agentapi/Database", "require exports assert util src/lib/Agent src/lib/AttachmentBase src/lib/SubPathContext src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/agentapi/AgentApi src/lib/agentapi/Common".split(" "), function(t, a, e, h, f, k, n, m, g, c, r) {
  function b(b, a, c, d) {
    return m.isObject(c) ? m.isString(c.name) ? m.isString(c.vendor) ? (c = r.validateConnectionInfo(c)) ? (b.logError(a, "Database", `traceSQLDatabaseRequest: databaseInfo${c}`), !1) : m.isObject(d) ? m.isString(d.statement) ? !0 : (b.logError(a, "Database", "traceSQLDatabaseRequest: startData.statement is invalid"), !1) : (b.logError(a, "Database", "traceSQLDatabaseRequest: startData is not an object"), !1) : (b.logError(a, "Database", "traceSQLDatabaseRequest: databaseInfo.vendor is invalid"), 
    !1) : (b.logError(a, "Database", "traceSQLDatabaseRequest: databaseInfo.name is invalid"), !1) : (b.logError(a, "Database", "traceSQLDatabaseRequest: databaseInfo is not an object"), !1);
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class d extends r.DummyOutgoingTracer {
    setResultData() {
      return this;
    }
  }
  a.DummyDatabaseRequestTracer = d;
  class l extends r.SdkSensorBase {
    constructor(b, a, c) {
      super(b, a, c);
      e.strictEqual(l.instance, void 0, "Multiple instances of SdkDatabaseSensor created");
      l.instance = this;
    }
  }
  a.SdkDatabaseSensor = l;
  a.getApis = function(a) {
    return {createSQL:function(e, g) {
      const k = l.instance;
      if (null == k) {
        return a.logWarn(c.isDebug(), "Database", "traceSQLDatabaseRequest: no trace created as sensor is disabled"), new d;
      }
      if (!c.isActive()) {
        return a.logWarn(k.isDebugEnabled, "Database", "traceSQLDatabaseRequest: no trace created as SDK is inactive"), new d;
      }
      if (!k.active) {
        return a.logWarn(k.isDebugEnabled, "Database", "traceSQLDatabaseRequest: no trace created as sensor is not active"), new d;
      }
      if (!b(a, k.isDebugEnabled, e, g)) {
        return new d;
      }
      if (null == n.SubPathContext.getActiveContext()) {
        return a.logWarn(k.isDebugEnabled, "Database", "traceSQLDatabaseRequest: no trace created as no path is active"), new d;
      }
      k.isDebugEnabled && f.Logger.debug(`${"Database"}: createSql() info: ${h.inspect(e)}, data: ${h.inspect(g)}`);
      return new x(k, a, e, g);
    }};
  };
  class x extends r.OutgoingTracer {
    constructor(b, a, c, d) {
      super(b, a, "Database");
      this.databaseInfo = c;
      this.startData = d;
    }
    setResultData(b) {
      null == this.attachmentCreator || this.state !== r.TracerState.STARTED ? this.sdkContext.logWarn(this.isDebugEnabled, "Database", "traceSQLDatabaseRequest: setResultData() shall be called on a started tracer") : this.attachmentCreator.setResultData(b);
      return this;
    }
    startAsyncPath(b) {
      const a = f.Agent.correlation;
      this.attachmentCreator = new v(this.databaseInfo, this.startData, this.sdkContext, this.isDebugEnabled);
      return this.tryStartAsyncActivation({attachmentCreator:this.attachmentCreator, category:a.MethodCategory.Database, creator:a.Creator.ONEAGENT_SDK, functionId:b});
    }
  }
  class p extends k.AttachmentBase {
    constructor(b, a) {
      super(b, f.Agent.correlation.AttachmentId.ATTACHMENT_SQL_ID, 0);
      this.debug = a;
    }
    fillEntryData(b) {
      this.setString(f.Agent.correlation.AttachmentFieldId.SQL_STATEMENT, b.statement, f.Configuration.maxSqlStringLen);
    }
    fillResultData(b, a) {
      if (m.isObject(b)) {
        try {
          this.debug && f.Logger.debug(`${"Database"}: fillResultData(): rowsReturned=${b.rowsReturned}, roundTripCount=${b.roundTripCount}`);
          const c = f.Agent.correlation.AttachmentFieldId;
          this.setPositivNumber(b.rowsReturned, c.SQL_NUM_ROWS_RETURNED, "rowsReturned", a);
          this.setPositivNumber(b.roundTripCount, c.SQL_ROUND_TRIPS, "roundTripCount", a);
        } catch (u) {
          g.logAgentException(u);
        }
      } else {
        a.logWarn(this.debug, "Database", "traceSQLDatabaseRequest: resultData is not an object");
      }
    }
    setPositivNumber(b, a, c, d) {
      null != b && (m.isNumber(b) && 0 <= b ? this.attachment.setFieldInteger(a, b) : d.logWarn(this.debug, "Database", `traceSQLDatabaseRequest: resultData.${c} holds no valid number`));
    }
  }
  class q extends k.AttachmentBase {
    constructor(b) {
      super(b, f.Agent.correlation.AttachmentId.ATTACHMENT_CONNECTION_POOL_ID, 0);
    }
    fillEntryData(b) {
      null != this.attachment && this.setMultipleFields(a => {
        var c = f.Agent.correlation;
        const d = c.AttachmentFieldId;
        a.stringCached(d.CONNECTION_POOL_DB, b.name);
        a.stringCached(d.CONNECTION_POOL_DBTYPE, b.vendor);
        a.integer(d.CONNECTION_POOL_AGGREGATION_MECHANISM, c.DbAggregationMechanism.DB_AGGREGATION_MECHANISM_ADK_SQL);
        c = c.ConnectionPoolTopology;
        let e;
        if (null != b.host) {
          c = c.TOPOLOGY_SINGLE_SERVER, e = b.host, m.isNumber(b.port) && a.integer(d.CONNECTION_POOL_DBPORTNO, b.port);
        } else {
          if (null != b.socketPath) {
            c = c.TOPOLOGY_LOCAL_IPC, e = b.socketPath;
          } else {
            if (null != b.pipeName) {
              c = c.TOPOLOGY_LOCAL_IPC, e = b.pipeName;
            } else {
              switch(b.channelType) {
                case 1:
                  c = c.TOPOLOGY_SINGLE_SERVER;
                  break;
                case 2:
                case 3:
                  c = c.TOPOLOGY_LOCAL_IPC;
                  break;
                case 4:
                  c = c.TOPOLOGY_EMBEDDED;
                  break;
                default:
                  c = c.TOPOLOGY_NOT_SET;
              }
            }
          }
        }
        a.integer(d.CONNECTION_POOL_TOPOLOGY, c);
        a.stringCachedOrUnavailable(d.CONNECTION_POOL_DBHOST, e);
      });
    }
  }
  class v {
    constructor(b, a, c, d) {
      this.databaseInfo = b;
      this.entryData = a;
      this.sdkContext = c;
      this.debug = d;
    }
    createAttachments(b) {
      const a = new q(b);
      if (a.valid) {
        try {
          a.fillEntryData(this.databaseInfo, this.sdkContext);
        } catch (u) {
          g.logAgentException(u);
        }
      }
      b = new p(b, this.debug);
      if (b.valid) {
        try {
          this.sqlAttachment = b, b.fillEntryData(this.entryData);
        } catch (u) {
          g.logAgentException(u);
        }
      }
    }
    setResultData(b) {
      null != this.sqlAttachment ? this.sqlAttachment.fillResultData(b, this.sdkContext) : this.debug && f.Logger.debug("Database: no valid SqlAttachment in setResultData()");
    }
  }
});
S("src/lib/transformer/IORedisTracker", "require exports src/lib/Agent src/lib/AsyncTracker src/lib/AttachmentBase src/lib/CallbackWrappingHelper src/lib/Debug src/lib/Embedder src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/UniqueId src/lib/transformer/PromiseTransformerUtilities".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class d extends h.default {
    constructor(b, a, c) {
      super(b, a);
      this.commandName = c;
      this.errorExtractor = k.errorFromFirstArg;
      this.injectedCallback = this.hasPromiseHandled = !1;
      this.debug = b.controlParams.isDebugEnabled;
      this.id = r.UniqueId.getNext();
      this.isStreamCommand = this.isStream(c);
    }
    static hasTrackerEmbedded(b) {
      b = d.inProcessEmbedder.get(b);
      return null != b && b;
    }
    manipulateArguments(a) {
      var c = this.debug;
      if (0 !== (a ? a.length : 0)) {
        const f = a[0];
        d.inProcessEmbedder.set(f, !0);
        c && (c = this.asyncActivation, n.assert(null != c, "asyncActivation should already be defined!"), this.isStreamCommand ? e.Logger.debug(`${this} | command is stream command! hasCallback=[${this.hasCallback}] coHasCallback=[${null != f.callback}]`) : this.hasCallback ? e.Logger.debug(`${this} | command has callback!`) : b.PromiseTransformerUtilities.isActuallyAPromise(f.promise) && e.Logger.debug(`${this} | command uses promise!`), e.Logger.debug(`${this} | vNode=${c.vNodeActivation.spc} | init=${c.initiatorActivation.spc}`));
      }
      return a;
    }
    createAttachments(b) {
      try {
        const a = new f.AttachmentBase(b, e.Agent.correlation.AttachmentId.ATTACHMENT_EXTERNAL_CALL_ID, 0);
        null != a ? (this.debug && e.Logger.debug(`${this} | creating external call attachment, connectionOptionsSet=${null != this.connectionOptions}`), null == this.connectionOptions && (e.Logger.warning(`${this} | has no connection options set!\ncommandname=${this.commandName}`), n.fail(), this.connectionOptions = {host:"UNKNOWN HOST", port:0}), a.setMultipleFields(b => {
          var a = this.connectionOptions.host, c = this.connectionOptions.port, d = this.commandName;
          const f = e.Agent.correlation.AttachmentFieldId;
          g.isString(a) && b.stringCached(f.EXTERNALCALL_HOSTNAME_ID, a);
          null != c && b.integer(f.EXTERNALCALL_PORTNO_ID, c);
          b.stringCached(f.EXTERNALCALL_OPERATION_NAME_ID, d);
          b.integer(f.EXTERNALCALL_CALL_TYPE_ID, e.Agent.correlation.ExternalCallType.REDIS);
        })) : this.debug && e.Logger.debug(`${this} | failed to create attachment`);
      } catch (q) {
        c.logAgentException(q);
      }
    }
    toString() {
      this.prefix || (this.prefix = `IORedis#${this.id}`);
      return this.prefix;
    }
    static embedTracker(b, a) {
      if (a.debug && this.hasTracker(b)) {
        throw Error(`${a} | tried to replace exisiting tracker!`);
      }
      return this.trackerEmbedder.set(b, a);
    }
    static hasTracker(b) {
      return this.trackerEmbedder.hasData(b);
    }
    static getTracker(b) {
      return this.trackerEmbedder.get(b);
    }
    static removeTracker(b) {
      const a = this.trackerEmbedder.get(b);
      this.trackerEmbedder.unlink(b);
      return a;
    }
    get virtualNodeActivation() {
      return this.vNode;
    }
    get vNode() {
      return null != this.asyncActivation ? this.asyncActivation.vNodeActivation : void 0;
    }
    get hasVnodeSet() {
      return null != this.vNode;
    }
    isStream(b) {
      return "scan sscan hscan zscan scanBuffer sscanBuffer hscanBuffer zscanBuffer".split(" ").includes(b);
    }
  }
  a.IORedisTracker = d;
  d.inProcessEmbedder = m.create("ioredis_inProcess");
  d.trackerEmbedder = m.create("ioredis_tracker");
  class l extends d {
    constructor(b, a, c) {
      super(b, a, c);
    }
    manipulateArguments(b) {
      null != b[0] && (g.isFunction(b[0]) ? null == this.spc && "exec" !== this.commandName ? (this.debug && e.Logger.debug(`${this} | cmd=${this.commandName} has no spc set, but wants to do context passing!`), n.fail()) : (this.origCb = b[0], b[0] = k.CallbackWrappingHelper.wrapCallbackCreateActivation(this), this.debug && e.Logger.debug(`${this} | wrapped cb for cmd=${this.commandName}`)) : this.debug && e.Logger.debug(`${this} | arg[0] is not a function`));
      return b;
    }
    static embedPipelineTracker(b, a) {
      if (a.debug && l.hasPipelineTracker(b)) {
        throw Error(`${a} | tried to overwrite exising tracker`);
      }
      return l.pipelineTrackerEmbedder.set(b, a);
    }
    static getPipelineTracker(b) {
      return l.pipelineTrackerEmbedder.get(b);
    }
    static hasPipelineTracker(b) {
      return l.pipelineTrackerEmbedder.hasData(b);
    }
  }
  a.IORedisPipelineTracker = l;
  l.pipelineTrackerEmbedder = m.create("ioredis_pipelinetracker");
  class x {
    constructor(b, a) {
      this.spc = b;
      this.debug = a;
      this.id = r.UniqueId.getNext();
    }
    static embedTracker(b, a) {
      if (a.debug && this.hasTracker(b)) {
        throw Error(`${a} | tried to replace exisiting tracker!`);
      }
      return this.trackerEmbedder.set(b, a);
    }
    static hasTracker(b) {
      return this.trackerEmbedder.hasData(b);
    }
    static getTracker(b) {
      return this.trackerEmbedder.get(b);
    }
    toString() {
      this.prefix || (this.prefix = `IORedis#${this.id}`);
      return this.prefix;
    }
  }
  a.IORedisEventTracker = x;
  x.trackerEmbedder = m.create("ioredisEventTracker");
});
S("src/lib/transformer/IORedisTransformer", "require exports src/lib/CallbackWrappingHelper src/lib/Debug src/lib/FunctionId src/lib/Logger src/lib/SubPathContext src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/modules/AutoSensorModule src/lib/sensors/IORedisSensor src/lib/transformer/AsyncTransformerBase src/lib/transformer/EventEmitterTransformerBase src/lib/transformer/IORedisTracker src/lib/transformer/PromiseTransformerUtilities src/lib/transformer/TransformerBase".split(" "), 
function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p, q) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class v extends d.AsyncTransformerBase {
    wrapReturnValue(b, a) {
      const c = p.PromiseTransformerUtilities.isActuallyAPromise(a.retVal), d = b.debug;
      if (c && !a.didThrow && !b.hasCallback) {
        const c = this;
        a = a.retVal;
        d && k.debug(`${b} | wrapping returned promise`);
        p.PromiseTransformerUtilities.registerThenWrapper(a, function(a, e, f) {
          return function(a) {
            return c.handleThenCall(this, b, e, a, f, arguments, d);
          };
        });
      }
    }
    wrapCallback(b) {
      return e.CallbackWrappingHelper.wrapCallbackCreateActivation(b);
    }
    getConnectionOptions(b) {
      if (m.hasProperty(b.connector, "options", "host") || m.hasProperty(b.connector, "options", "port")) {
        return {host:b.connector.options.host, port:b.connector.options.port};
      }
      if (m.hasProperty(b, "options", "host") || m.hasProperty(b, "options", "port")) {
        return {host:b.options.host, port:b.options.port};
      }
      this.isDebugEnabled && k.debug(`${this} | could not get connection options!`);
    }
    handleThenCall(b, a, d, e, h, l, m) {
      let p;
      try {
        null != a && null != a.vNode && ((m && k.debug(`${a} | enter handleThenCall, isCatch=${d}`), a.hasPromiseHandled) ? null != a.asyncActivation && (m && k.debug(`${a} | asyncActSPC=${a.asyncActivation.initiatorActivation.spc} activated`), a.asyncActivation.initiatorActivation.spc.activate()) : a.isStreamCommand ? m && k.debug(`${a} | passed through handleThenCall, event has to close vNode=${a.vNode} and spc=${a.vNode.spc}`) : a.vNode.isExited ? (p = q.TransformerBase.createCallbackActivation(a.vNode.spc, 
        new f.FunctionId(h)), null != p && (a.hasPromiseHandled = !0, m && k.debug(`${a} | opening node=${p.activation}, spc=${p.activation.spc}`))) : (a.vNode.exitOrException(d ? e : void 0), a.vNode.spc.end(), m && k.debug(`${a} | closing vNode=${a.vNode} and ending spc=${a.vNode.spc} in handleThenCall`)));
      } catch (E) {
        g.logAgentException(E);
      }
      b = c.safeInvoke(b, h, l);
      try {
        null != p ? (p.done(b.exception), m && k.debug(`${a} | closing node=${p.activation}, spc=${p.activation.spc}`), p.activation.spc.open && (p.activation.spc.end(), m && k.debug(`${a} | exiting spc=${p.activation.spc}`))) : null != a && a.hasPromiseHandled && null != a.asyncActivation && (m && k.debug(`${a} | asyncActSPC=${a.asyncActivation.initiatorActivation.spc} deactivated`), a.asyncActivation.initiatorActivation.spc.deactivate());
      } catch (E) {
        g.logAgentException(E);
      }
      m && k.debug(`${a} | exit handleThenCall, didThrow ${b.didThrow}`);
      return b.rethrow();
    }
  }
  a.IORedisTransformer = v;
  class D extends v {
    constructor(b) {
      super(b);
    }
    generateSubstitute(b) {
      const a = this, d = new f.FunctionId(b);
      return function(e) {
        const f = a.controlParams.isDebugEnabled;
        if (!a.controlParams.active) {
          return f && k.debug("IORedis sensor is inactive."), c.doInvoke(this, b.origFn, arguments);
        }
        var h = arguments;
        let l, p;
        try {
          if (p = a.getTrackerObject(this, e), null != p && !p.hasVnodeSet) {
            const b = a.getConnectionOptions(this);
            p.connectionOptions = b;
            p.injectedCallback = p.isStreamCommand;
            l = a.tryStartAsyncActivation({functionId:d, attachmentCreator:p, vPathOption:1});
            if (null != l && (p.asyncActivation = l, h = p.manipulateArguments(h), f)) {
              const b = l.initiatorActivation.spc, a = h.length, c = p.commandName, d = m.isFunction(e.callback);
              k.debug(`${p} | Redis::sendCommand, argCnt=${a}, cmd=${c}, hasCommandObjectCallback=${d}, hasTrackerCallback=${p.hasCallback}, wrappedCb=${null != p.origCb}`);
              k.debug(`${p} | opened asyncActivation(init)=${l.initiatorActivation} asyncActivation(async)=${l.vNodeActivation} on spc=${b}`);
            }
          }
        } catch (E) {
          g.logAgentException(E);
        }
        h = c.safeInvoke(this, b.origFn, h);
        try {
          null != p && null != l && (r.addSample(d), l.initiatorActivationDone(h.exception), f && k.debug(`${p} | closed asyncActivation(init)=${l.initiatorActivation} on spc=${l.initiatorActivation.spc}`), h.didThrow && (l.vNodeActivation.exitOrException(h.exception), l.vNodeActivation.spc.end(), f && k.debug(`${p} | closed vNode=${l.vNodeActivation} on spc=${l.vNodeActivation.spc}`)), a.wrapReturnValue(p, h));
        } catch (E) {
          g.logAgentException(E);
        }
        return h.rethrow();
      };
    }
    getTrackerObject(b, a) {
      return !x.IORedisPipelineTracker.hasPipelineTracker(b) || "exec" !== a.name && "discard" !== a.name ? x.IORedisTracker.getTracker(a) : (x.IORedisTracker.removeTracker(a), x.IORedisPipelineTracker.getPipelineTracker(b));
    }
  }
  a.IORedisSendCommandTransformer = D;
  class C extends v {
    generateSubstitute(b) {
      const a = this, d = a.isDebugEnabled;
      return function() {
        if (!a.controlParams.active) {
          return d && k.debug("IORedis sensor is inactive."), c.doInvoke(this, b.origFn, arguments);
        }
        try {
          const c = this.callback, f = new x.IORedisTracker(a, b, this.name);
          m.isFunction(c) && !f.isStreamCommand && (d && k.debug(`${f} | embedded tracker in command=${f.commandName}`), f.origCb = c, this.callback = e.CallbackWrappingHelper.wrapCallbackCreateActivation(f));
          x.IORedisTracker.embedTracker(this, f);
        } catch (N) {
          g.logAgentException(N);
        }
        return c.safeInvoke(this, b.origFn, arguments).rethrow();
      };
    }
  }
  a.IORedisCommandTransformer = C;
  class u extends v {
    generateSubstitute(b) {
      const a = this, d = new f.FunctionId(b);
      return function() {
        const e = a.controlParams.isDebugEnabled;
        if (!a.controlParams.active) {
          return e && k.debug("IORedis sensor is inactive."), c.doInvoke(this, b.origFn, arguments);
        }
        var f = arguments;
        let h, l = x.IORedisPipelineTracker.getPipelineTracker(this);
        try {
          0 !== this._transactions || null != l && l.hasVnodeSet || (l = l ? l : new x.IORedisPipelineTracker(a, b, "exec"), l.connectionOptions = a.getConnectionOptions(this), h = a.tryStartAsyncActivation({functionId:d, attachmentCreator:l, vPathOption:1}), x.IORedisPipelineTracker.embedPipelineTracker(this, l), null != h && (l.spc = h.initiatorActivation.spc, l.asyncActivation = h, f = l.manipulateArguments(f), e && k.debug(`${l} | opened asyncActivation=${h.initiatorActivation} on spc=${h.initiatorActivation.spc} in pipeline exec`)));
        } catch (M) {
          g.logAgentException(M);
        }
        f = c.safeInvoke(this, b.origFn, f);
        try {
          null != l && null != h && (r.addSample(d), h.initiatorActivationDone(f.exception), e && k.debug(`${l} | closed asyncActivation=${h.initiatorActivation} on spc=${h.initiatorActivation.spc} in pipeline exec`), a.wrapReturnValue(l, f), f.didThrow && (h.vNodeActivation.exitOrException(f.exception), h.vNodeActivation.spc.end(), e && k.debug(`${l} | closed vNode=${h.vNodeActivation} on spc=${h.vNodeActivation.spc} in pipeline exec`)));
        } catch (M) {
          g.logAgentException(M);
        }
        return f.rethrow();
      };
    }
  }
  a.IORedisPipelineTransformer = u;
  class z extends v {
    constructor(b) {
      super(b);
    }
    generateSubstitute(a) {
      const d = this;
      return function() {
        const e = d.controlParams.isDebugEnabled;
        if (!d.controlParams.active) {
          return e && k.debug("IORedis sensor is inactive."), c.doInvoke(this, a.origFn, arguments);
        }
        const f = c.safeInvoke(this, a.origFn, arguments);
        try {
          if (!f.didThrow) {
            e && k.debug("Transaction support interceped...");
            const a = arguments[0];
            m.hasProperty(a, "multi") ? (!e || d.controlParams instanceof b.IORedisSensor || (k.debug("control params is not an instance of IORedisSensor!"), h.fail()), null == d.controlParams.patchTransactionMultiCommand(a) && e && k.debug(`${this} | could not patch 'Redis'`)) : e && k.debug("Transaction return value does not have property 'multi'!");
            m.hasProperty(a, "exec") ? (!e || d.controlParams instanceof b.IORedisSensor || (k.debug("control params is not an instance of IORedisSensor!"), h.fail()), null == d.controlParams.patchTransactionExecCommand(a, "PipelineMonkeyPatch") && e && k.debug(`${this} | could not patch '${"PipelineMonkeyPatch"}'`)) : e && k.debug("Transaction return value does not have property 'multi'!");
          }
        } catch (U) {
          g.logAgentException(U);
        }
        return f;
      };
    }
  }
  a.IORedisTransactionSupportTransformer = z;
  class B extends v {
    constructor(b) {
      super(b);
    }
    generateSubstitute(a) {
      const d = this;
      return function() {
        const e = d.controlParams.isDebugEnabled;
        e && k.debug("Transaction::multi entered");
        const f = c.safeInvoke(this, a.origFn, arguments);
        try {
          if (!f.didThrow) {
            const a = p.PromiseTransformerUtilities.isActuallyAPromise(f.retVal);
            e && k.debug(`Transaction::multi exited | isPromise=${a}`);
            if (a) {
              e && k.debug("Multi returned a promise");
            } else {
              const a = f.retVal;
              m.hasProperty(a, "exec") ? !e || d.controlParams instanceof b.IORedisSensor ? d.controlParams.patchTransactionExecCommand(a, "multi") : (k.debug("control params is not an instance of IORedisSensor!"), h.fail()) : e && k.debug("Transaction return value does not have property 'multi'!");
            }
          }
        } catch (U) {
          g.logAgentException(U);
        }
        return f.rethrow();
      };
    }
  }
  a.IORedisTransactionMultiTransformer = B;
  class A extends v {
    constructor(b) {
      super(b);
    }
    generateSubstitute(b) {
      const a = this;
      return function(d) {
        const e = a.controlParams.isDebugEnabled;
        if (!a.controlParams.active) {
          return e && k.debug("IORedis sensor is inactive."), c.doInvoke(this, b.origFn, arguments);
        }
        var f = arguments;
        let h = x.IORedisPipelineTracker.getPipelineTracker(this);
        try {
          null == h && (h = new x.IORedisPipelineTracker(a, b, "exec"), f = h.manipulateArguments(f), x.IORedisPipelineTracker.embedPipelineTracker(this, h));
        } catch (T) {
          g.logAgentException(T);
        }
        f = c.safeInvoke(this, b.origFn, f);
        try {
          null != h && (e && m.hasProperty(this, "_queue") && this._queue.forEach(b => {
            b = x.IORedisTracker.getTracker(b);
            null != b && null == b.vNode && k.debug(`${h} | ${b} has no vNode, cmd=${b.commandName}`);
          }), a.wrapReturnValue(h, f));
        } catch (T) {
          g.logAgentException(T);
        }
        return f.rethrow();
      };
    }
  }
  a.IORedisMultiExecTransformer = A;
  class w extends v {
    constructor(b) {
      super(b);
    }
    generateSubstitute(b) {
      const a = this;
      return function(d, e) {
        const f = a.controlParams.isDebugEnabled;
        if (!a.controlParams.active) {
          return c.doInvoke(this, b.origFn, arguments);
        }
        f && k.debug("entered pipeline fill result");
        let h;
        try {
          if (h = x.IORedisTracker.getTracker(this._queue[e]), null != h) {
            if (null == h.vNode || h.vNode.isExited || h.hasCallback) {
              f && !h.hasCallback ? k.debug(`${h} | cmd=${h.commandName}, hasVNode=${null != h.vNode}, hasCallback=${h.hasCallback}}`) : f && k.debug(`${h} | is passed through fill result`);
            } else {
              var l = d[0];
              f && k.debug(`${h} | closed asyncactivation=${h.vNode} on spc=${h.vNode.spc} in fillResult, has error=${null != l}`);
              h.vNode.exitOrException(l);
            }
          }
        } catch (M) {
          g.logAgentException(M);
        }
        l = c.safeInvoke(this, b.origFn, arguments);
        try {
          null != h && null != h.vNode && h.vNode.isExited && h.vNode.spc.open && (h.vNode.spc.end(), f && k.debug(`${h} | ending spc=${h.vNode.spc}`)), f && k.debug(`${h} | exited pipeline fill result`);
        } catch (M) {
          g.logAgentException(M);
        }
        return l.rethrow();
      };
    }
  }
  a.IORedisFillResultTransformer = w;
  class I extends v {
    generateSubstitute(b) {
      const a = this;
      return function(d) {
        const e = a.controlParams.isDebugEnabled;
        if (!a.controlParams.active) {
          return c.doInvoke(this, b.origFn, arguments);
        }
        e && k.debug("entered pipeline discard");
        const f = c.safeInvoke(this, b.origFn, arguments);
        try {
          const b = this._queue;
          if (null != b) {
            for (const a of b) {
              const b = x.IORedisTracker.getTracker(a);
              null != b && (e && k.debug(`"DISCARDED_TRACKER" | discarded command: ${b.commandName}`), null != b.vNode && (b.vNode.exit(), b.vNode.spc.end()));
            }
          }
        } catch (R) {
          g.logAgentException(R);
        }
        e && k.debug("exited pipeline discard");
        return f.rethrow();
      };
    }
  }
  a.IORedisPipelineDiscardTransformer = I;
  class K extends v {
    generateSubstitute(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled, e = c.safeInvoke(this, b.origFn, arguments);
        try {
          const b = n.SubPathContext.getActiveContext();
          if (a.controlParams.active && !e.didThrow) {
            if (null != b) {
              const a = new x.IORedisEventTracker(b, d);
              x.IORedisEventTracker.embedTracker(e.retVal, a);
              d && k.debug(`${a} | embedded into ScanStream`);
            } else {
              d && k.debug("=== | tried to embed EventTracker but SPC was undefined.");
            }
          }
        } catch (U) {
          g.logAgentException(U);
        }
        return e.rethrow();
      };
    }
  }
  a.IORedisStreamTransformer = K;
  class O extends l.EventEmitterTransformerBase {
    getWrappedListener(b, a, d) {
      const e = this.isDebugEnabled, g = x.IORedisEventTracker.getTracker(b);
      if (null == g) {
        return d;
      }
      const h = l.EventEmitterTransformerBase.getUnwrappedListener(d);
      return function(...d) {
        e && (k.debug(`${g} | entered ${a.toString()} event, argCnt=${d.length}`), k.debug(`${g} | has spc=${g.spc}, isOpen=${g.spc.open}`));
        const l = g.asyncActivationResult;
        let p, m;
        null != l && (l.vNodeActivation.isExited || (e && k.debug(`${g} | closing vNode=${l.vNodeActivation} on spc=${l.vNodeActivation.spc}`), l.vNodeActivation.exit()), p = l.vNodeActivation.spc, m = q.TransformerBase.createCallbackActivation(p, new f.FunctionId(h)));
        e && k.debug(`${g} | pushing spc=${p} on top of context stack.`);
        d = c.safeInvoke(b, h, d);
        null != m && m.done();
        e && k.debug(`${g} | popping spc=${p}.`);
        null != p && "end" === a && (e && k.debug(`${g} | ending spc=${p}`), p.end());
        e && k.debug(`${g} | ${a.toString()} event handled.`);
        return d.rethrow();
      };
    }
    shallWrap(b, a) {
      return x.IORedisEventTracker.hasTracker(b) && ["data", "end"].includes(a.toString());
    }
  }
  a.IORedisStreamEventTransformer = O;
  class H extends v {
    generateSubstitute(b) {
      const a = this;
      return function() {
        const d = a.controlParams.isDebugEnabled;
        if (!a.controlParams.active) {
          return c.doInvoke(this, b.origFn, arguments);
        }
        let e;
        try {
          e = x.IORedisEventTracker.getTracker(this), null != e && d && k.debug(`${e} | pushing spc of ${e.spc} on top, isOpen=${e.spc.open}`);
        } catch (R) {
          g.logAgentException(R);
        }
        const f = c.safeInvoke(this, b.origFn, arguments);
        try {
          if (null != e) {
            d && k.debug(`${e} | popping spc=${e.spc} from top`);
            const b = a.getLastIssuedScanCommand(this), c = a.getCommandAsyncResult(b);
            null != c && (e.asyncActivationResult = c);
            d && k.debug(`${e} | got last scan command=[${b}], got asyncResult=${null != c ? c : void 0}`);
          }
        } catch (R) {
          g.logAgentException(R);
        }
        return f.rethrow();
      };
    }
    getCommandAsyncResult(b) {
      let a;
      null != b && (b = x.IORedisTracker.getTracker(b), null != b && (a = b.asyncActivation));
      return a;
    }
    getLastIssuedScanCommand(b) {
      b = b.opt.redis;
      let a = this.findLatestScanCommand(b.offlineQueue);
      null == a && (a = this.findLatestScanCommand(b.commandQueue));
      return a;
    }
    findLatestScanCommand(b) {
      let a;
      if (null != b) {
        let c = Math.min(b.length - 1, 100000);
        for (this.controlParams.isDebugEnabled && 100000 === c && k.debug(` IORedis | Encountered queue with ${b.length} elements.`); 0 <= c; c--) {
          const d = b.peekAt(c);
          if (null != d && "scan" === d.command.name) {
            a = d.command;
            break;
          }
        }
      }
      return a;
    }
  }
  a.IORedisSpcFromTrackerTransformer = H;
  class Q extends v {
    generateSubstitute(b) {
      const a = this;
      return function(d, e) {
        const f = a.controlParams.isDebugEnabled;
        if (!a.controlParams.active) {
          return c.doInvoke(this, b.origFn, arguments);
        }
        try {
          if (f && k.debug(`Entered silent emit for evnt=${d.toString()}`), "error" === d) {
            const [b, c] = a.getQueue(this);
            if (f) {
              var h = a.isLastRetry(this);
              k.debug(`=== | deque name=${c} length=${null == b ? "undefined queue" : b.length},` + `isLastRetry=${h}, error=[${e}]`);
            }
            null != b && a.endAllSubPathsBecauseOfError(b, e);
          }
        } catch (T) {
          g.logAgentException(T);
        }
        h = c.safeInvoke(this, b.origFn, arguments);
        f && k.debug(`Exited silent emit for evnt=${d.toString()}`);
        return h.rethrow();
      };
    }
    endAllSubPathsBecauseOfError(b, a) {
      for (let d = 0; d < b.length; d++) {
        var c = b.peekAt(d);
        null != c && (c = x.IORedisTracker.getTracker(c.command), null == c || null == c.vNode || c.vNode.isExited || (this.controlParams.isDebugEnabled && k.debug(`${c} | cmd=[${c.commandName}] ended vNode=[${c.vNode}]` + ` @SPC=[${c.vNode.spc}] with exception=[${a}]`), c.vNode.exitOrException(a), c.vNode.spc.end()));
      }
    }
    getQueue(b) {
      return m.hasProperty(b, "commandQueue") ? [b.commandQueue, "commandQueue"] : m.hasProperty(b, "offlineQueue") ? [b.offlineQueue, "offlineQueue"] : [void 0, "undefined"];
    }
    isLastRetry(b) {
      return m.hasProperty(b, "options", "maxRetriesPerRequest") ? b.options.maxRetriesPerRequest === b.retryAttempts : m.hasProperty(b, "redisOptions", "maxRetriesPerRequest") ? b.redisOptions.maxRetriesPerRequest === b.retryAttempts : !1;
    }
  }
  a.IORedisSilentEmitErrorsTransformer = Q;
});
S("src/lib/sensors/IORedisSensor", "require exports semver src/lib/Debug src/lib/Logger src/lib/Patch src/lib/sensors/SensorBase src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/transformer/IORedisTransformer".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class r extends n.SensorBase {
    applyInstrumentation(b) {
      const a = this.isDebugEnabled;
      var g = b.moduleInfo.version;
      null == this.isSupportedVersion && (this.isSupportedVersion = e.satisfies(g, ">=4.0.0"), this.isPreTypeScript = e.satisfies(g, "<=4.2.1"), this.isSupportedVersion || f.info(`Found unsupported version of ${this.name}. Support starts with version ${"4.0.0"}, but is ${g}!`), a && f.debug(`Found version ${"ioredis"} module: ${g}, sensor is ${this.active ? "en" : "dis"}abled`));
      if (this.isSupportedVersion) {
        if (b.matchRequest("ioredis")) {
          a && f.debug(`IORedis (${b.request}) requested.`);
          var h = new c.IORedisSendCommandTransformer(this), p = new k.FunctionSpec("sendCommand", "IORedis", b.moduleExports.prototype, k.AsyncTrackingMode.CallbackLastOrPromise, "ioredis");
          h = k.applyToSingle(p, h);
          this.printPatchState(g, h);
          h = new c.IORedisStreamTransformer(this);
          p = new k.FunctionSpec("scanStream", "IORedis", b.moduleExports.prototype);
          h = k.applyToSingle(p, h);
          this.printPatchState(g, h);
          h = new c.IORedisSilentEmitErrorsTransformer(this);
          p = new k.FunctionSpec("silentEmit", "IORedis", b.moduleExports.prototype, k.AsyncTrackingMode.None);
          h = k.applyToSingle(p, h);
          this.printPatchState(g, h);
        }
        b.matchRequestPattern("command") && (a && f.debug(`IORedis (${b.request}) requested.`), h = new c.IORedisCommandTransformer(this), p = new k.FunctionSpec("initPromise", "Command", this.isPreTypeScript ? b.moduleExports.prototype : b.moduleExports.default.prototype, void 0, "ioredis"), h = k.applyToSingle(p, h), this.printPatchState(g, h));
        if (b.matchRequestPattern("pipeline")) {
          a && f.debug(`IORedis (${b.request}) requested.`);
          h = e.satisfies(g, "<4.7.0") ? b.moduleExports.prototype : b.moduleExports.default.prototype;
          p = new c.IORedisPipelineTransformer(this);
          var m = new k.FunctionSpec("exec", "Pipeline", h, k.AsyncTrackingMode.CallbackLast, "ioredis");
          p = k.applyToSingle(m, p);
          this.printPatchState(g, p);
          p = new c.IORedisPipelineDiscardTransformer(this);
          m = new k.FunctionSpec("discard", "Pipeline", h, k.AsyncTrackingMode.CallbackLast, "ioredis");
          p = k.applyToSingle(m, p);
          this.printPatchState(g, p);
          p = new c.IORedisFillResultTransformer(this);
          m = new k.FunctionSpec("fillResult", "Pipeline", h, k.AsyncTrackingMode.CallbackLast, "ioredis");
          p = k.applyToSingle(m, p);
          this.printPatchState(g, p);
          p = new c.IORedisSendCommandTransformer(this);
          h = new k.FunctionSpec("sendCommand", "Pipeline", h, k.AsyncTrackingMode.CallbackLastOrPromise, "ioredis");
          h = k.applyToSingle(h, p);
          this.printPatchState(g, h);
        }
        b.matchRequestPattern("transaction") && (a && f.debug(`IORedis (${b.request}) requested.`), h = new c.IORedisTransactionSupportTransformer(this), p = new k.FunctionSpec("addTransactionSupport", "transaction", b.moduleExports, void 0, "ioredis"), h = k.applyToSingle(p, h), this.printPatchState(g, h));
        b.matchRequestPattern("ScanStream") && (h = new c.IORedisSpcFromTrackerTransformer(this), p = new k.FunctionSpec("_read", "ScanStream", b.moduleExports.default.prototype, k.AsyncTrackingMode.None, "ioredis"), h = k.applyToSingle(p, h), this.printPatchState(g, h), g = new c.IORedisStreamEventTransformer(this, ["data", "end"]), b = new k.FunctionSpec("Readable", "ScanStream", b.moduleExports.default.prototype, k.AsyncTrackingMode.None, "ioredis"), g.applyTransformation(b), a && f.debug("      event emitter"));
      }
    }
    patchTransactionMultiCommand(b) {
      if (m.hasProperty(b, "multi")) {
        var a = new c.IORedisTransactionMultiTransformer(this);
        b = new k.FunctionSpec("multi", "Redis", b, void 0, "ioredis");
        a = k.applyToSingle(b, a);
        this.printPatchState(void 0, a);
        return a;
      }
      f.warning("IORedisSensor | could not find property multi");
      g.reportInstrumentationError(this, "can not find property 'multi' on transaction script return value!");
    }
    patchTransactionExecCommand(b, a) {
      if (m.hasProperty(b, "exec")) {
        var d = new c.IORedisMultiExecTransformer(this);
        b = new k.FunctionSpec("exec", a, b, k.AsyncTrackingMode.CallbackLastOrPromise, "ioredis");
        d = k.applyToSingle(b, d);
        this.printPatchState(void 0, d);
        return d;
      }
      f.warning("IORedisSensor | could not find property exec");
      g.reportInstrumentationError(this, "can not find property 'exec' on transaction script return value!");
    }
    printPatchState(b, a) {
      null == a ? (f.warning(`Failed to patch IORedis version: ${b}`), g.reportInstrumentationError(this, `failed to patch ioredis version ${b}`), h.fail(`failing for ${b}`)) : this.isDebugEnabled && f.debug(`      patched ${a.qualifiedName}`);
    }
  }
  a.IORedisSensor = r;
});
S("src/lib/transformer/MSSqlTracker", "require exports src/lib/Agent src/lib/AttachmentBase src/lib/CallbackWrappingHelper src/lib/Embedder src/lib/util/CoreUtil src/lib/util/UniqueId".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.DATABASE_TYPE = "SQL Server";
  a.DEFAULT_POOL_NAME = "default-pool";
  class g {
    constructor(b, a) {
      this.transformer = b;
      this.request = a;
      this.hasPromiseHandled = this.usesPromise = this.injectedCallback = !1;
      this.errorExtractor = f.errorFromFirstArg;
      this.debug = b.controlParams.isDebugEnabled;
      this.id = m.UniqueId.getNext();
    }
    manipulateArguments(b) {
      n.isFunction(b[b.length - 1]) ? (this.origCb = b[b.length - 1], b[b.length - 1] = this.transformer.wrapCallback(this), this.debug && e.Logger.debug(`${this} | manipulating arguments`)) : this.usesPromise = !0;
      return b;
    }
    createAttachments(b) {
      this.connectionPoolAttachment = new c(b);
      this.sqlAttachment = new r(b);
      this.fillEntryData();
    }
    fillExitData(b) {
      if (null != this.sqlAttachment) {
        this.debug && e.Logger.debug(`${this} | filling exit attachments`);
        let a;
        if (null != b) {
          if (null != b.rowsAffected && 0 < b.rowsAffected.length) {
            a = 0;
            for (const c of b.rowsAffected) {
              a += c;
            }
          } else {
            n.isNumber(b.rowsAffected) && (a = b.rowsAffected);
          }
        }
        null != this.request._currentRequest && (b = this.request._currentRequest.parametersByName, n.isString(b) ? this.sqlAttachment.fillExitData(b, a) : n.hasProperty(b, "statement") ? this.sqlAttachment.fillExitData(b.statement.value, a) : n.isString(this.request._currentRequest.sqlTextOrProcedure) && this.sqlAttachment.fillExitData(this.request._currentRequest.sqlTextOrProcedure));
      }
    }
    embed(b) {
      const a = g.embedder.get(b);
      g.embedder.set(b, this);
      return a;
    }
    toString() {
      this.prefix || (this.prefix = `MSSql#${this.id}`);
      return this.prefix;
    }
    static getOrCreate(b, a) {
      return this.embedder.createOrGet(a, () => new g(b, a));
    }
    static get(b) {
      return this.embedder.get(b);
    }
    static hasTrackerEmbedded(b) {
      return this.embedder.hasData(b);
    }
    fillEntryData() {
      null != this.connectionPoolAttachment && (this.debug && e.Logger.debug(`${this} | filling entry attachments`), this.connectionPoolAttachment.fillConn(this.getMSSqlData()));
    }
    hasInstanceNameSet() {
      return null != this.getMSSqlData().instanceName;
    }
    getMSSqlData() {
      return n.hasProperty(this.request.parent, "config") ? this.request.parent.config : n.hasProperty(this.request.parent, "parent", "config") ? this.request.parent.parent.config : {};
    }
  }
  a.MSSqlTracker = g;
  g.embedder = k.create("mssqlTracker");
  class c extends h.AttachmentBase {
    constructor(b) {
      super(b, e.Agent.correlation.AttachmentId.ATTACHMENT_CONNECTION_POOL_ID, 1);
    }
    fillConn(b) {
      const c = e.Agent.correlation.AttachmentFieldId;
      this.setMultipleFields(d => {
        d.stringCachedOrUnavailable(c.CONNECTION_POOL_DB, b.database);
        d.stringCached(c.CONNECTION_POOL_NAME, a.DEFAULT_POOL_NAME);
        d.stringCachedOrUnavailable(c.CONNECTION_POOL_DBHOST, b.server);
        d.stringCached(c.CONNECTION_POOL_DBTYPE, a.DATABASE_TYPE);
        d.stringCachedOrUnavailable(c.CONNECTION_POOL_INSTANCENAME, b.instanceName);
        null != b.port && d.integer(c.CONNECTION_POOL_DBPORTNO, b.port);
        d.integer(c.CONNECTION_POOL_AGGREGATION_MECHANISM, e.Agent.correlation.DbAggregationMechanism.DB_AGGREGATION_MECHANISM_UNDEFINED);
      });
    }
  }
  a.MSSqlConnectionPoolAttachment = c;
  class r extends h.AttachmentBase {
    constructor(b) {
      super(b, e.Agent.correlation.AttachmentId.ATTACHMENT_SQL_ID, 0);
    }
    fillExitData(b, a) {
      null != a && this.attachment.setFieldInteger(e.Agent.correlation.AttachmentFieldId.SQL_NUM_ROWS_RETURNED, a);
      this.setString(e.Agent.correlation.AttachmentFieldId.SQL_STATEMENT, b);
    }
  }
  a.MSSqlSqlAttachment = r;
});
S("src/lib/transformer/TediousTransformer", "require exports src/lib/Agent src/lib/FunctionId src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/modules/AutoSensorModule src/lib/transformer/TransformerBase src/lib/transformer/TediousTracker".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class c extends m.TransformerBase {
    constructor(a, b) {
      super(a);
      this.callbackProperty = b;
    }
    generateSubstitute(a) {
      const b = this, c = new h.FunctionId(a);
      return function() {
        if (!b.controlParams.active) {
          return k.doInvoke(this, a.origFn, arguments);
        }
        const d = b.isDebugEnabled;
        let h, p;
        try {
          var m = arguments[0];
          g.TediousTracker.isTagged(this) ? d && e.Logger.debug(` === | fnName='${a.functionName}' skips tedious handling`) : (h = new g.TediousTracker(b, this, b.callbackProperty), p = b.tryStartAsyncActivation({functionId:c, attachmentCreator:h}), null != p && (h.vNode = p.vNodeActivation, h.manipulateArguments(m), h.fillEntryData(this.config, m), d && e.Logger.debug(`${h} | opened init=${p.initiatorActivation}, vNode=${h.vNode}`)));
        } catch (v) {
          f.logAgentException(v);
        }
        m = k.safeInvoke(this, a.origFn, arguments);
        try {
          null != p && (d && e.Logger.debug(`${h} | closing init=${p.initiatorActivation} on spc=${p.initiatorActivation.spc}, didThrow=${m.didThrow}`), p.initiatorActivationDone(m.exception), m.didThrow && (p.vNodeActivation.exitOrException(m.exception), p.vNodeActivation.spc.end(), d && e.Logger.debug(`${h} | ending spc=${p.vNodeActivation.spc} because of error.`)));
        } catch (v) {
          f.logAgentException(v);
        }
        return m.rethrow();
      };
    }
    wrapCallback(a) {
      return function(b, c) {
        a.debug && e.Logger.debug(`${a} | entered tedious wrapped callback\nerror: ${b}\nval: ${c}`);
        let d, g;
        try {
          if (null != a.vNode) {
            var p = a.errorExtractor(b, c);
            a.vNode.exitOrException(p);
            a.fillExitData(c);
            g = new h.FunctionId(a.origCb);
            d = m.TransformerBase.createCallbackActivation(a.vNode.spc, g);
            null == d && a.debug && e.Logger.debug(`${a} | could not create callback method activation`);
          }
        } catch (q) {
          f.logAgentException(q);
        }
        p = k.safeInvoke(this, a.origCb, arguments);
        try {
          null != a.vNode && (null != d && (n.addSample(g), d.done(p.exception)), a.vNode.spc.end());
        } catch (q) {
          f.logAgentException(q);
        }
      };
    }
  }
  a.TediousTransformer = c;
});
S("src/lib/transformer/TediousTracker", "require exports util src/lib/Agent src/lib/Embedder src/lib/util/CoreUtil src/lib/util/UniqueId src/lib/AttachmentBase src/lib/CallbackWrappingHelper src/lib/transformer/MSSqlTracker".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class r {
    constructor(b, a, c) {
      this.transformer = b;
      this.connection = a;
      this.callbackProperty = c;
      this.errorExtractor = g.errorFromFirstArg;
      this.ID = n.UniqueId.getNext();
      this.debug = b.controlParams.isDebugEnabled;
    }
    createAttachments(a) {
      this.debug && h.Logger.debug(`${this} | created attachments activation=${a}`);
      this.sqlAttachment = new b(a);
      this.connPoolAttachment = new c.MSSqlConnectionPoolAttachment(a);
    }
    fillEntryData(b, a) {
      null != this.connPoolAttachment && this.connPoolAttachment.valid && (this.debug && h.Logger.debug(`${this} | fill tedious connection pool attachment`), b.options = b.options, this.connPoolAttachment.fillConn({port:b.options.port, server:b.server, database:b.options.database, instanceName:b.options.instanceName}));
      if (null != this.sqlAttachment && this.sqlAttachment.valid) {
        this.debug && h.Logger.debug(`${this} | fill tedious sql entry attachment`);
        let b;
        k.hasProperty(a, "sqlTextOrProcedure") ? b = a.sqlTextOrProcedure : k.hasProperty(a, "getTableCreationSql") ? b = a.getTableCreationSql() : this.debug && h.Logger.debug(`${this} | can not get sql from request=${typeof a}`);
        this.sqlAttachment.fillEntryData(b);
      }
    }
    fillExitData(b) {
      null != this.sqlAttachment && this.sqlAttachment.valid && k.isNumber(b) && (this.debug && h.Logger.debug(`${this} | fill tedious sql exit attachment`), this.sqlAttachment.fillExitData(b));
    }
    manipulateArguments(b) {
      const a = this.debug;
      k.hasProperty(b, this.callbackProperty) ? (this.origCb = b[this.callbackProperty], b[this.callbackProperty] = this.transformer.wrapCallback(this), a && h.Logger.debug(`${this} | wrapped callback of ${e.inspect(this.origCb)}`)) : a && h.Logger.debug(`${this} | could not find callback property=${this.callbackProperty}`);
    }
    toString() {
      null == this.prefix && (this.prefix = `MSSqlTediousTracker(${this.ID})`);
      return this.prefix;
    }
    static isTagged(b) {
      return !0 === r.embedder.get(b);
    }
    static tag(b) {
      r.embedder.set(b, !0);
    }
  }
  a.TediousTracker = r;
  r.embedder = f.create("isHandledByMSSql");
  class b extends m.AttachmentBase {
    constructor(b) {
      super(b, h.Agent.correlation.AttachmentId.ATTACHMENT_SQL_ID, 0);
    }
    fillEntryData(b) {
      this.setStringOrUnavailable(h.Agent.correlation.AttachmentFieldId.SQL_STATEMENT, b);
    }
    fillExitData(b) {
      this.attachment.setFieldInteger(h.Agent.correlation.AttachmentFieldId.SQL_NUM_ROWS_RETURNED, b);
    }
  }
  a.TediousSqlAttachment = b;
});
S("src/lib/transformer/MSSqlTransformer", "require exports src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/InvocationUtil src/lib/Agent src/lib/Debug src/lib/FunctionId src/lib/transformer/MSSqlTracker src/lib/transformer/TransformerBase src/lib/transformer/PromiseTransformerUtilities src/lib/transformer/TediousTracker".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class d extends c.TransformerBase {
    wrapReturnValue(b, a) {
      const c = r.PromiseTransformerUtilities.isActuallyAPromise(a.retVal), d = b.debug;
      if (c && !a.didThrow && b.usesPromise) {
        const c = this;
        a = a.retVal;
        d && k.Logger.debug(`${b} | wrapping returned promise`);
        r.PromiseTransformerUtilities.registerThenWrapper(a, function(a, d, e) {
          return function(a) {
            return c.handleThenCall(this, b, d, a, e, arguments);
          };
        });
      }
    }
    generateSubstitute(b) {
      const a = this, c = new m.FunctionId(b);
      return function() {
        if (!a.controlParams.active) {
          return f.doInvoke(this, b.origFn, arguments);
        }
        const d = a.isDebugEnabled;
        let e, l;
        var m = arguments;
        try {
          if (e = new g.MSSqlTracker(a, this), l = a.tryStartAsyncActivation({functionId:c, attachmentCreator:e, vPathOption:1}), null != l) {
            e.virtualNodeActivation = l.vNodeActivation;
            const b = e.embed(this);
            d && null != b && k.Logger.debug(`${b} | to be replaced with ${e}, valid in consecutive commands case`);
            m = e.manipulateArguments(m);
          }
        } catch (B) {
          h.logAgentException(B);
        }
        m = f.safeInvoke(this, b.origFn, m);
        try {
          null != e && null != l && (d && k.Logger.debug(`${e} | closing initActivation=${l.initiatorActivation} on spc=${l.initiatorActivation.spc}` + `(virtActivation=${l.vNodeActivation})`), l.initiatorActivationDone(m.exception), m.didThrow ? (l.vNodeActivation.exitOrException(m.exception), l.vNodeActivation.spc.end()) : e.usesPromise && a.wrapReturnValue(e, m));
        } catch (B) {
          h.logAgentException(B);
        }
        return m.rethrow();
      };
    }
    handleThenCall(b, a, d, e, g, l) {
      let p;
      const r = null != a && a.debug;
      try {
        null != a && null != a.virtualNodeActivation && ((r && k.Logger.debug(`${a} | enter handleThenCall, isCatch=${d}`), a.hasPromiseHandled) ? r && (k.Logger.debug(`${a} | Promise handle then call.`), n.fail("Promise handle then call.")) : a.virtualNodeActivation.isExited ? (p = c.TransformerBase.createCallbackActivation(a.virtualNodeActivation.spc, new m.FunctionId(g)), null != p && (a.hasPromiseHandled = !0, r && k.Logger.debug(`${a} | opening node=${p.activation}, spc=${p.activation.spc}`))) : 
        (a.fillExitData(e), a.virtualNodeActivation.exitOrException(d ? e : void 0), a.virtualNodeActivation.spc.end(), r && k.Logger.debug(`${a} | closing vNode=${a.virtualNodeActivation} and ending spc=${a.virtualNodeActivation.spc} in handleThenCall`)));
      } catch (A) {
        h.logAgentException(A);
      }
      b = f.safeInvoke(b, g, l);
      try {
        null != p && (p.done(b.exception), r && k.Logger.debug(`${a} | closing node=${p.activation}, spc=${p.activation.spc}`), p.activation.spc.open && (p.activation.spc.end(), r && k.Logger.debug(`${a} | exiting spc=${p.activation.spc}`)));
      } catch (A) {
        h.logAgentException(A);
      }
      r && k.Logger.debug(`${a} | exit handleThenCall, didThrow ${b.didThrow}`);
      return b.rethrow();
    }
  }
  a.MSSqlBaseTransformer = d;
  class l extends d {
    wrapCallback(b) {
      return function(a, d) {
        let e;
        try {
          if (b.debug && k.Logger.debug(`${b} | entered wrapped callback, hasCallback=${null != b.origCb}`), null != b.virtualNodeActivation) {
            var g = f.doInvoke(b, b.errorExtractor, arguments);
            null != b.request ? b.fillExitData(d) : (b.debug && k.Logger.debug(`${b} | tracker has request not set!`), k.Logger.warning(`${b} | tracker has no request been set!`));
            b.debug && k.Logger.debug(`${b} | exiting virtual node=${b.virtualNodeActivation} didThrow=${void 0 !== g}`);
            b.virtualNodeActivation.exitOrException(g);
            const a = new m.FunctionId(b.origCb);
            e = c.TransformerBase.createCallbackActivation(b.virtualNodeActivation.spc, a);
            null == e && b.debug ? k.Logger.debug(`${b} | could not create callback method activation`) : null != e && b.debug && k.Logger.debug(`${b} | started cbActivation=${e}`);
          }
        } catch (u) {
          h.logAgentException(u);
        }
        g = f.safeInvoke(this, b.origCb, arguments);
        try {
          null != b.virtualNodeActivation && (null != e && (b.debug && k.Logger.debug(`${b} | closing cbActivation=${e}, didThrow=${null != g.didThrow}`), e.done(g.exception)), b.debug && k.Logger.debug(`${b} | ending virtual node spc=${b.virtualNodeActivation.spc}`), b.virtualNodeActivation.spc.end()), b.debug && k.Logger.debug(`${b} | exited wrapped callback`);
        } catch (u) {
          h.logAgentException(u);
        }
        return g.rethrow();
      };
    }
  }
  a.MSSqlQueryTransformer = l;
  class x {
    constructor(b) {
      this.controlParams = b;
    }
    generateSubstitute(b) {
      const a = this;
      return function() {
        if (!a.controlParams.active) {
          return f.doInvoke(this, b.origFn, arguments);
        }
        const c = arguments;
        try {
          const b = a.controlParams.isDebugEnabled, d = c[1];
          if (e.isFunction(d)) {
            if (c[1] = a.getCallbackSubstitute(d), b) {
              const b = g.MSSqlTracker.get(this);
              k.Logger.debug(`${b} | tagged connection.`);
            }
          } else {
            b && k.Logger.debug(`argument is not a function? | type=${typeof d}`);
          }
        } catch (D) {
          h.logAgentException(D);
        }
        return f.doInvoke(this, b.origFn, c);
      };
    }
    getCallbackSubstitute(a) {
      return function() {
        try {
          const a = arguments[1];
          null != a && b.TediousTracker.tag(a);
        } catch (q) {
          h.logAgentException(q);
        }
        return f.doInvoke(this, a, arguments);
      };
    }
  }
  a.MSSqlTaggingTransformer = x;
});
S("src/lib/sensors/MSSqlSensor", "require exports semver src/lib/Agent src/lib/Debug src/lib/Patch src/lib/transformer/MSSqlTransformer src/lib/sensors/SensorBase".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.cApiRealm = "mssql/tedious";
  class g extends m.SensorBase {
    applyInstrumentation(a) {
      const c = this.isDebugEnabled, b = a.moduleInfo.version, d = e.satisfies(b, ">=5.0.0"), f = e.satisfies(b, ">=6.0.1");
      c && h.Logger.debug(`Found version mssql module: ${b}, sensor is ${this.active ? "en" : "dis"}abled`);
      d ? a.matchRequestPattern("base") ? (this.patchQueryFunction(a.moduleExports.Request.prototype, c), this.patchAquire(a.moduleExports.ConnectionPool.prototype, c)) : f && (a.matchRequestPattern("request") ? this.patchQueryFunction(a.moduleExports.prototype, c) : a.matchRequestPattern("connection-pool") && this.patchAquire(a.moduleExports.prototype, c)) : h.Logger.info(`Found unsupported version of ${this.name}. Support starts with version ${"5.0.0"}, but is ${b}!`);
    }
    patchQueryFunction(a, e) {
      const b = new n.MSSqlQueryTransformer(this);
      let c;
      for (const d of ["query", "execute", "batch", "bulk"]) {
        c = this.patchFunction(d, b, a), this._debugOutput(e, c, d);
      }
    }
    patchAquire(c, e) {
      var b = new n.MSSqlTaggingTransformer(this);
      c = new k.FunctionSpec("acquire", "", c, a.cApiRealm);
      b = void 0 !== k.applyToSingle(c, b);
      this._debugOutput(e, b, "acquire");
    }
    patchFunction(c, e, b) {
      c = new k.FunctionSpec(c, "", b, k.AsyncTrackingMode.CallbackLast, a.cApiRealm);
      return void 0 !== k.applyToSingle(c, e);
    }
    _debugOutput(a, e, b) {
      a && e ? h.Logger.debug(`        patched ${b}`) : e || (h.Logger.warning(`could not patch ${b}`), f.fail(`could not patch ${b}`));
    }
  }
  a.MSSqlSensor = g;
});
S("src/lib/sensors/TediousSensor", "require exports semver src/lib/Agent src/lib/Debug src/lib/Patch src/lib/transformer/TediousTransformer src/lib/sensors/SensorBase src/lib/sensors/MSSqlSensor".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class c extends m.SensorBase {
    applyInstrumentation(a) {
      const b = this.isDebugEnabled;
      var c = a.moduleInfo.version, f = e.satisfies(c, ">=4.2.0");
      b && h.Logger.debug(`Found version tedious module: ${c}, sensor is ${this.active ? "en" : "dis"}abled`);
      if (!f) {
        h.Logger.info(`Found unsupported version of ${this.name}. Support starts with version ${"4.2.0"}, but is ${c}!`);
      } else {
        if (a.matchRequestPattern("connection")) {
          b && h.Logger.debug(`Hit request: ${a.request}`);
          f = new n.TediousTransformer(this, "userCallback");
          for (const d of ["execSql", "execute", "callProcedure", "execSqlBatch"]) {
            c = this.patchFunction(d, f, a.moduleExports.prototype), this._debugOutput(b, c, d);
          }
          f = new n.TediousTransformer(this, "callback");
          for (const d of ["execBulkLoad"]) {
            c = this.patchFunction(d, f, a.moduleExports.prototype), this._debugOutput(b, c, d);
          }
        }
      }
    }
    patchFunction(a, b, c) {
      a = new k.FunctionSpec(a, "", c, k.AsyncTrackingMode.CallbackLast, g.cApiRealm);
      return void 0 !== k.applyToSingle(a, b);
    }
    _debugOutput(a, b, c) {
      a && b ? h.Logger.debug(`        patched ${c}`) : b || (h.Logger.warning(`could not patch ${c}`), f.fail(`could not patch ${c}`));
    }
  }
  a.TediousSensor = c;
});
S("src/lib/sensors/SensorFactory", "require exports src/lib/Logger src/lib/sensors/GenericSensors src/lib/sensors/DisabledModulesSensor src/lib/sensors/ModuleSubstitutionSensor src/lib/sensors/WebRequestSensor src/lib/sensors/ClientWebRequestSensor src/lib/sensors/EventEmitterContextPassingSensor src/lib/sensors/MongoDbSensor src/lib/sensors/RedisSensor src/lib/sensors/MemcachedSensor src/lib/sensors/ExpressSensor src/lib/sensors/FinalHandlerSensor src/lib/sensors/RestifySensor src/lib/sensors/PromiseSensor src/lib/sensors/TimerSensor src/lib/sensors/CryptoSensor src/lib/sensors/MySqlSensor src/lib/sensors/MySql2Sensor src/lib/sensors/PostgresSensor src/lib/sensors/CouchbaseDbSensor src/lib/sensors/AwsLambdaSensor src/lib/sensors/RabbitMqSensor src/lib/sensors/AwsSdkSensor src/lib/sensors/GrpcSensor src/lib/sensors/GrpcJsSensor src/lib/agentapi/Database src/lib/agentapi/IncomingRemoteCall src/lib/agentapi/OutgoingRemoteCall src/lib/agentapi/IncomingMessaging src/lib/agentapi/OutgoingMessaging src/lib/agentapi/RequestAttributes src/lib/sensors/IORedisSensor src/lib/sensors/MSSqlSensor src/lib/sensors/TediousSensor".split(" "), 
function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p, q, v, D, C, u, z, B, A, w, I, K, O, H, Q, L, G, J, N, U, R) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.createSensor = function(a, t, E) {
    let F;
    switch(E.type) {
      case "ContextPassing":
        F = new h.ContextPassingSensor(a, t, E);
        break;
      case "AsyncTiming":
        F = new h.AsyncTimingSensor(a, t, E);
        break;
      case "SyncTiming":
        F = new h.SyncTimingSensor(a, t, E);
        break;
      case "DisabledModules":
        F = new f.DisabledModulesSensor(a, t, E);
        break;
      case "ModuleSubstitution":
        F = new k.ModuleSubstitutionSensor(a, t, E);
        break;
      case "EventEmitterContextPassing":
        F = new g.EventEmitterContextPassingSensor(a, t, E);
        break;
      case "WebRequest":
        F = new n.WebRequestSensor(a, t, E);
        break;
      case "ClientWebRequest":
        F = new m.ClientWebRequestSensor(a, t, E);
        break;
      case "MongoDb":
        F = new c.MongoDbSensor(a, t, E);
        break;
      case "Redis":
        F = new r.RedisSensor(a, t, E);
        break;
      case "Memcached":
        F = new b.MemcachedSensor(a, t, E);
        break;
      case "Express":
        F = new d.ExpressSensor(a, t, E);
        break;
      case "FinalHandler":
        F = new l.FinalHandlerSensor(a, t, E);
        break;
      case "Restify":
        F = new x.RestifySensor(a, t, E);
        break;
      case "Promise":
        F = new p.PromiseSensor(a, t, E);
        break;
      case "TimerSensor":
        F = new q.TimerSensor(a, t, E);
        break;
      case "CryptoSensor":
        F = new v.CryptoSensor(a, t, E);
        break;
      case "MySql":
        F = new D.MySqlSensor(a, t, E);
        break;
      case "MySql2":
        F = new C.MySql2Sensor(a, t, E);
        break;
      case "Postgres":
        F = new u.PostgresSensor(a, t, E);
        break;
      case "CouchbaseDb":
        F = new z.CouchbaseDbSensor(a, t, E);
        break;
      case "AwsLambda":
        F = new B.AwsLambdaSensor(a, t, E);
        break;
      case "AwsSdk":
        F = new w.AwsSdkSensor(a, t, E);
        break;
      case "RabbitMq":
        F = new A.RabbitMqSensor(a, t, E);
        break;
      case "gRPC":
        F = new I.GrpcSensor(a, t, E);
        break;
      case "GrpcJs":
        F = new K.GrpcJsSensor(a, t, E);
        break;
      case "SdkDatabase":
        F = new O.SdkDatabaseSensor(a, t, E);
        break;
      case "SdkIncomingRemoteCall":
        F = new H.SdkIncomingRemoteCallSensor(a, t, E);
        break;
      case "SdkOutgoingRemoteCall":
        F = new Q.SdkOutgoingRemoteCallSensor(a, t, E);
        break;
      case "SdkIncomingMessaging":
        F = new L.SdkIncomingMessagingSensor(a, t, E);
        break;
      case "SdkOutgoingMessaging":
        F = new G.SdkOutgoingMessagingSensor(a, t, E);
        break;
      case "SdkScav":
        F = new J.SdkScavSensor(a, t, E);
        break;
      case "IORedis":
        F = new N.IORedisSensor(a, t, E);
        break;
      case "MSSql":
        F = new U.MSSqlSensor(a, t, E);
        break;
      case "Tedious":
        F = new R.TediousSensor(a, t, E);
        break;
      default:
        e.warning(`${a} requests unknown sensor type ${E.type}`);
    }
    return F;
  };
});
S("src/lib/sensors/PredefinedSensors", ["require", "exports"], function(t, a) {
  Object.defineProperty(a, "__esModule", {value:!0});
  t = {capture:!0, enabled:!0, entrypoint:!1};
  const e = {capture:!0, enabled:!0, entrypoint:!0}, h = {capture:!1, enabled:!1, entrypoint:!1}, f = {capture:!1, enabled:!0, entrypoint:!1};
  t = Object.assign(Object.create(null), {"Node.Core.FileSystem":t, "Node.Core.Process":t, "Node.Core.DNS":t, "Node.Core.Timers":t, "Node.Core.Events":t, "Node.Core.Promise":t, "Node.Core.Crypto":t, "Node.ModuleSubstitutions":t, "Node.DisabledModules":t, "Node.WebRequest":e, "Node.ClientWebRequest":t, "Node.MongoDb.ContextPassing":t, "Node.MongoDb":t, "Node.Redis":t, "Node.Memcached":t, "Node.Express":t, "Node.FinalHandler":t, "Node.Restify":t, "Node.SQLite3":t, "Node.MySql":t, "Node.MySql2":h, "Node.Postgres":t, 
  "Node.CouchbaseDb":h, "Node.AwsLambda":e, "Node.AwsSdk":t, "Node.RabbitMq":t, "Node.gRPC":h, "Node.GrpcJs":h, "sdk.outgoing.remotecall":f, "sdk.incoming.remotecall":f, "sdk.outgoing.messaging":f, "sdk.incoming.messaging":f, "sdk.database":f, "sdk.scav":f, "Node.IORedis":h, "Node.MSSql":h, "Node.Tedious":h});
  a.default = t;
});
S("src/lib/modules/SensorManager", "require exports module path src/lib/Agent src/lib/Debug src/lib/DebugLoggingEntity src/lib/ModuleLoadContext src/lib/PackageRegistry src/lib/Patch src/lib/sensors/SensorConfig src/lib/sensors/SensorFactory src/lib/sensors/PredefinedInstrumentationRules src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/RuntimeUtil src/lib/SupportAlertBuilder src/lib/sensors/PredefinedSensors".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p, q, v) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class D {
    constructor(b, a) {
      this.sensor = b;
      this.ruleKey = a;
    }
  }
  a.SensorAssociation = D;
  class C extends n.default {
    constructor(b, a) {
      super("SensorManager");
      this.thePredefinedSensors = b;
      this.thePredefinedInstrumentationRules = a;
      this.name = "SensorManager";
      this.sensorMapIsBuilt = !1;
      this.sensorMap = Object.create(null);
      this.moduleMap = Object.create(null);
      this.pathPatternAssociations = [];
      this.agentModuleRegistry = Object.create(null);
      k.assertStrictEqual(C.theInstance, void 0);
      C.theInstance = this;
      this.addToDebugLogDomain("Transformers");
    }
    static getInstance() {
      return C.theInstance;
    }
    startModuleLoadIntercept() {
      f.Logger.info("Module._load intercept kicked in");
      this.sensorMapIsBuilt || (f.Logger.info("build sensor map lazy"), this.buildSensorMap());
      var b = new c.FunctionSpec("_load", "module", e.Module);
      c.substitute(b, C.moduleLoadSubstitute);
      b = {};
      for (const a in e.Module._cache) {
        const c = e.Module._cache[a];
        if (p.isAgentFile(a)) {
          this.agentModuleRegistry[a] = e.Module._cache[a].exports;
        } else {
          if (!this.isRequiredByAgent(c)) {
            const d = g.PackageRegistry.lookup(a);
            null != d && null != d.packageRoot ? b.hasOwnProperty(d.packageRoot) || (b[d.packageRoot] = 1, f.Logger.info(`unmonitored load of package ${d} (required by ${C.getParentModuleId(c)})`)) : b.hasOwnProperty(a) || (b[a] = 1, f.Logger.info(`unmonitored load of ${a} (required by ${C.getParentModuleId(c)})`));
          }
        }
      }
      this.preLoadModules();
    }
    onConfigUpdate(b) {
      if (l.hasProperty(b, "rtc", "knowledgeSensorConfigurations")) {
        if (b = b.rtc, this.sensorMapIsBuilt) {
          for (const a of b.knowledgeSensorConfigurations.entries) {
            if (this.isApplicableSensorConfig(a) && (b = this.getSensor(a.sensorKey), null != b)) {
              const c = this.convertSensorConfig(a);
              null != c && b.updateState(c);
            }
          }
        } else {
          this.buildSensorMap(b.knowledgeSensorConfigurations.entries);
        }
      }
    }
    getSensor(b) {
      return this.sensorMap[b];
    }
    registerForRequest(b, a, c) {
      this.addAssociation(a, b, c);
    }
    onLoad(b) {
      if (p.isAgentFile(b.resolvedModulePath)) {
        this.onAgentFileLoad(b);
      } else {
        var a = this.getAssociatedSensors(b);
        if (null != a && (!b.moduleInfo.isInstrumented || !this.isInNodeModuleCache(b.resolvedModulePath) && !p.isNodeCoreModule(b.request))) {
          b.moduleInfo.isInstrumented = !0;
          try {
            for (const c of a) {
              const a = c.sensor;
              if (a.enabled && a.isApplicable(b)) {
                try {
                  a.isDebugEnabled && f.Logger.debug(`${a.name}: instrumenting module ${b.toString(!0)}`), a.applyInstrumentation(b, c.ruleKey);
                } catch (w) {
                  f.Logger.severe(`exception during instrumentation of ${b.request}: ${x.verboseExceptionObject(w)}`), q.SupportAlertBuilder.handleInstrumentationError(w);
                }
              } else {
                a.isDebugEnabled && f.Logger.debug(`${a.name}: skipping instrumentation of module ${b.toString(!0)} - sensor disabled or restrictions not met`);
              }
            }
          } finally {
            !b.isModuleAcquired && this.isDebugEnabled && f.Logger.debug(`instrumentation of ${b.toString()} did not acquire module`);
          }
        }
      }
    }
    getAssociatedSensors(b) {
      let a = this.moduleMap[b.request];
      null == a && (a = this.moduleMap[b.resolvedModulePath]);
      null == a && this.pathPatternAssociations.forEach(c => {
        c.pathPattern.test(b.resolvedModulePath) && (null == a ? a = [c.associatedSensor] : a.push(c.associatedSensor));
      });
      return a;
    }
    loadModule(b, a, d, e) {
      this.isDebugEnabled && f.Logger.debug(`SensorManager: loading ${a} requested by ${d ? d.id : "<undefined>"}`);
      return c.PatchedFnDescriptor.getOrigFn(C.moduleLoadSubstitute).call(b, a, d, e);
    }
    get predefinedSensors() {
      null == this.thePredefinedSensors && (this.thePredefinedSensors = v.default);
      return this.thePredefinedSensors;
    }
    get predefinedInstrumentationRules() {
      null == this.thePredefinedInstrumentationRules && (this.thePredefinedInstrumentationRules = d.getPredefinedInstrumentationRules());
      return this.thePredefinedInstrumentationRules;
    }
    onAgentFileLoad(b) {
      null != this.agentModuleRegistry[b.resolvedModulePath] ? (b.moduleExports = this.agentModuleRegistry[b.resolvedModulePath], this.isDebugEnabled && f.Logger.debug(`repeated load of agent file ${b}: using cached exports.`)) : (this.agentModuleRegistry[b.resolvedModulePath] = b.moduleExports, this.isDebugEnabled && f.Logger.debug(`agent file ${b}: caching exports on initial load.`));
    }
    isRequiredByAgent(b) {
      for (b = b.parent;; b = b.parent) {
        if (null == b) {
          return !1;
        }
        if (null != b.filename && p.isAgentFile(b.filename)) {
          return !0;
        }
      }
    }
    isInNodeModuleCache(b) {
      return null != e.Module._cache[b];
    }
    buildSensorMap(b) {
      if (this.sensorMapIsBuilt) {
        k.fail();
      } else {
        this.sensorMapIsBuilt = !0;
        var a = {};
        if (Array.isArray(b)) {
          for (var c of b) {
            this.isApplicableSensorConfig(c) && (b = this.convertSensorConfig(c)) && (a[c.sensorKey] = b);
          }
        }
        for (const b of Object.getOwnPropertyNames(this.predefinedInstrumentationRules)) {
          (c = a[b] || this.predefinedSensors[b]) && c.enabled ? this.createSensorInstance(b, c, this.predefinedInstrumentationRules[b]) : f.Logger.info(`skip creation of sensor ${b} as sensor is ${c ? "disabled" : "unknown"}`);
        }
      }
    }
    createSensorInstance(a, c, d) {
      c = b.createSensor(a, c, d);
      null != c && (this.sensorMap[a] = c, this.addAssociatesToModuleMap(c, d.associatedModules), this.logDebug(`created sensor ${a} of type ${d.type}`));
    }
    addAssociatesToModuleMap(b, a) {
      for (const c of Object.getOwnPropertyNames(a)) {
        this.addAssociation(b, c, a[c].ruleKey);
      }
    }
    makePathPattern(b) {
      b = "[/\\\\]node_modules[/\\\\]" + b.replace(/[/]/g, "[/\\\\]");
      return new RegExp(b, p.hasCaseInsensitiveFilePaths ? "i" : void 0);
    }
    addAssociation(b, a, c) {
      c = new D(b, c);
      a.startsWith("pattern:") ? this.pathPatternAssociations.push({pathPattern:this.makePathPattern(a.slice(8)), associatedSensor:c}) : null == this.moduleMap[a] ? this.moduleMap[a] = [c] : this.moduleMap[a].some(a => a.sensor === b) ? f.Logger.warning(`SensorManager: sensor ${b} associated twice for module ${a}`) : this.moduleMap[a].push(c);
    }
    isApplicableSensorConfig(b) {
      return l.isString(b.sensorKey) && (0 === b.sensorKey.indexOf(r.cConfigKeyPrefix) || 0 === b.sensorKey.indexOf(r.cSdkConfigKeyPrefix));
    }
    convertSensorConfig(b) {
      if (l.isBoolean(b.capture) && l.isBoolean(b.enabled) && l.isBoolean(b.entrypoint) && Array.isArray(b.sensorProperties)) {
        var a = {capture:b.capture, enabled:b.enabled, entrypoint:b.entrypoint};
        0 < b.sensorProperties.length && (a.sensorProperties = b.sensorProperties[0]);
        return a;
      }
      f.Logger.warning("Illegal sensor config received");
    }
    preLoadModules() {
      for (const b in this.moduleMap) {
        if (this.moduleMap[b].some(a => 1 === a.sensor.instrumentationRule.associatedModules[b].instrumentationStrategy)) {
          this.isDebugEnabled && f.Logger.debug(`pre-loading module ${b}`);
          try {
            t(b);
          } catch (z) {
            f.Logger.severe(`SensorManager: failed to pre-load module ${b} with ${x.verboseExceptionObject(z)}`);
          }
        }
      }
      this.logDebug("done with module pre-load");
    }
    static getParentModuleId(b) {
      return null != b.parent && null != b.parent.id ? b.parent.id : "<unknown>";
    }
    static moduleLoadSubstitute(b, a, c) {
      const d = C.theInstance;
      var e = h.extname(b);
      if (0 === e.length || ".js" === e || ".node" === e) {
        if (null == c && (c = !1), e = m.ModuleLoadContext.create(b, a, c, this), null != e) {
          if (!f.Agent.isCim) {
            d.onLoad(e);
          }
          b = e.moduleExports;
        } else {
          d.isDebugEnabled && f.Logger.debug(`module ${b} could not be resolved.`), b = d.loadModule(this, b, a, c);
        }
      } else {
        b = d.loadModule(this, b, a, c);
      }
      return b;
    }
  }
  a.default = C;
});
S("src/lib/ModuleRegistry", "require exports src/lib/DebugLoggingEntity src/lib/PackageRegistry src/lib/Agent src/lib/modules/SensorManager src/lib/util/CoreUtil".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  let m;
  class g {
    constructor(a, b, c) {
      this.request = a;
      this.parent = b;
      this.packageMetaInfo = c;
      this.isLoaded = this.isInstrumented = !1;
    }
    get version() {
      return null != this.packageMetaInfo ? this.packageMetaInfo.version : h.cInvalidVersionString;
    }
    get packageJsonPath() {
      return null != this.packageMetaInfo ? this.packageMetaInfo.packageRoot : void 0;
    }
    get packageName() {
      return null != this.packageMetaInfo ? this.packageMetaInfo.name : void 0;
    }
    get parentFilePath() {
      return n.hasProperty(this.parent, "id") ? this.parent.id : void 0;
    }
  }
  a.ModuleRegistryEntry = g;
  class c {
    constructor() {
      this.loadedModuleCount = 0;
      this.loadedModuleMap = Object.create(null);
    }
    lookup(a) {
      let b = this.loadedModuleMap[a.resolvedModulePath];
      if (null == b) {
        const c = this.determinePackageMetaInfo(a);
        b = new g(a.request, a.parent, c);
        this.loadedModuleMap[a.resolvedModulePath] = b;
        null == m && (m = new e.default("ModuleRegistry"), m.addToDebugLogDomain("ModuleLoad"));
        m.isDebugEnabled && f.Logger.debug(`ModuleRegistry: added #${this.loadedModuleCount} ${a.request}: pmi=${c}, resolved=${a.resolvedModulePath}`);
        ++this.loadedModuleCount;
      }
      return b;
    }
    determinePackageMetaInfo(a) {
      const b = k.default.getInstance().getAssociatedSensors(a);
      let c;
      null != b && b.some(b => {
        c = b.sensor.determinePackageMetaInfo(a);
        return null != c;
      });
      null == c && (c = h.PackageRegistry.determinePackageMetaInfo(a));
      return c;
    }
  }
  a.ModuleRegistry = new c;
});
S("src/lib/ModuleLoadContext", "require exports module src/lib/DebugLoggingEntity src/lib/ModuleRegistry src/lib/modules/SensorManager src/lib/Agent src/lib/Debug src/lib/util/RuntimeUtil".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.ModuleRegistryEntry = f.ModuleRegistryEntry;
  let c;
  const r = {"implicit:process":process, "implicit:global":global, "implicit:Promise":null != global.Promise ? global : void 0};
  class b {
    constructor(a, c, e, g, h, k) {
      this.request = a;
      this.parent = c;
      this.isMain = e;
      this.moduleType = g;
      this.resolvedModulePath = h;
      this.thisContext = k;
      this.theModuleExports = b.cNoExports;
      1 === this.moduleType && (this.theModuleExports = r[a]);
      this.moduleInfo = f.ModuleRegistry.lookup(this);
      h.endsWith(".node") && n.Logger.info(`Native extension loaded: ${h} module: ${this.moduleInfo.packageName || "<unknown>"}@${this.moduleInfo.version}`);
    }
    static create(a, f, k, m) {
      let d, l = a;
      if (g.isNodeCoreModule(a)) {
        d = 0;
      } else {
        if (r.hasOwnProperty(a)) {
          d = 1;
        } else {
          try {
            l = e.Module._resolveFilename(a, f), d = b.isInternalModuleRequestString(a) ? 2 : 3;
          } catch (D) {
          }
        }
      }
      if (null == d) {
        null == c && (c = new h.default("ModuleLoadContext"), c.addToDebugLogDomain("ModuleLoad")), c.isDebugEnabled && n.Logger.debug(`unable to resolve module ${a}`);
      } else {
        return new b(a, f, k, d, l, m);
      }
    }
    get isImplicitModule() {
      return 1 === this.moduleType;
    }
    get isNodeCoreModule() {
      return 0 === this.moduleType;
    }
    get isExternalModule() {
      return 3 === this.moduleType;
    }
    get isInternalModule() {
      return 2 === this.moduleType;
    }
    get isModuleAcquired() {
      return this.theModuleExports !== b.cNoExports;
    }
    get moduleExports() {
      this.load();
      return this.theModuleExports;
    }
    set moduleExports(b) {
      this.theModuleExports = b;
      const a = this.moduleCacheEntry;
      null != a && (a.exports = b);
    }
    get moduleCacheEntry() {
      return e.Module._cache[this.resolvedModulePath];
    }
    load() {
      this.theModuleExports === b.cNoExports && (this.theModuleExports = k.default.getInstance().loadModule(this.thisContext, this.request, this.parent, this.isMain), this.moduleInfo.isLoaded = !0);
    }
    matchRequest(a) {
      return b.compareRequestString(this.request, a);
    }
    matchRequestPattern(b) {
      return (new RegExp(`${b}(.js)?$`, "i")).test(this.resolvedModulePath);
    }
    toString(b = !1) {
      return b ? `${this.request}(${this.resolvedModulePath})` : this.request;
    }
    static isInternalModuleRequestString(b) {
      return /^[\/\\.]|([a-zA-Z]:)/.test(b);
    }
    static getRequestStringComparer() {
      var b = (b, a) => b.toLowerCase() === a.toLowerCase();
      const a = (b, a) => b === a;
      switch(process.platform) {
        case "win32":
          break;
        case "linux":
          b = a;
          break;
        default:
          m.fail("missing operating system specific adaptation for request string normalization"), b = a;
      }
      return b;
    }
  }
  a.ModuleLoadContext = b;
  b.cNoExports = {cNoExports:!0};
  b.compareRequestString = b.getRequestStringComparer();
});
S("src/lib/PackageRegistry", "require exports path fs semver src/lib/Agent src/lib/DebugLoggingEntity src/lib/util/CoreUtil src/lib/util/RuntimeUtil".split(" "), function(t, a, e, h, f, k, n, m, g) {
  function c() {
    null == b && (b = new n.default("PackageRegistry"), b.addToDebugLogDomain("ModuleLoad"));
    return b.isDebugEnabled;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.cInvalidVersionString = "0.0.0";
  class r {
    constructor(b, a, c) {
      this.name = b;
      this.version = a;
      this.packageRoot = c;
    }
    toString() {
      return `${this.name}@${this.version}`;
    }
  }
  a.PackageMetaInfo = r;
  let b;
  class d {
    constructor() {
      this.cNodeModulePathFragment = `${e.sep}node_modules${e.sep}`;
      this.packageRootCache = Object.create(null);
      this.builtinPackageCache = Object.create(null);
      this.packageMetaInfoList = [];
    }
    determinePackageMetaInfo(b) {
      let a;
      if (2 === b.moduleType || 3 === b.moduleType) {
        a = this.lookup(b.resolvedModulePath);
      } else {
        if (0 === b.moduleType || 1 === b.moduleType) {
          a = this.getBuiltinPackage(b.request);
        }
      }
      return a;
    }
    lookup(b) {
      b = e.dirname(b);
      g.hasCaseInsensitiveFilePaths() && (b = b.toLowerCase());
      var c = b.lastIndexOf(this.cNodeModulePathFragment);
      c = 0 <= c ? c + this.cNodeModulePathFragment.length : 1;
      var d = !1;
      const h = [];
      for (var l; !(b.length <= c || l === b);) {
        if (null == this.packageRootCache[b]) {
          h.push(b);
          l = e.join(b, "package.json");
          const g = this.tryReadPackageJson(l);
          if (null != g.pkg) {
            c = g.pkg;
            d = null != c.name ? c.name : e.basename(b);
            let h = a.cInvalidVersionString;
            null != c.version && (null != f.valid(c.version) ? h = c.version : "kibana" !== c.version && k.Logger.info(`PackageRegistry: invalid package.json version field in ${l}: ${g.json}`));
            d = new r(d, h, b);
            this.addNewPackage(d);
            break;
          }
        } else {
          d = this.packageRootCache[b];
          break;
        }
        l = b;
        b = e.dirname(b);
      }
      this.associateLocationsWithPackage(d, h);
      return d || void 0;
    }
    get packageList() {
      return this.packageMetaInfoList;
    }
    tryReadPackageJson(b) {
      const a = {pkg:void 0, json:void 0};
      try {
        const d = h.readFileSync(b);
        a.json = m.stripByteOrderMark(d.toString("utf-8"));
        a.pkg = JSON.parse(a.json);
        c() && k.Logger.debug(`tryReadPackageJson: read "${b} -> ${a.json}"`);
      } catch (p) {
        c() && k.Logger.debug(`tryReadPackageJson: failed to read "${b}"`);
      }
      return a;
    }
    addNewPackage(b) {
      this.packageMetaInfoList.push(b);
      c() && k.Logger.debug(`Adding package #${this.packageMetaInfoList.length} "${b}" -> ${b.packageRoot}`);
    }
    associateLocationsWithPackage(b, a) {
      a.forEach(a => this.packageRootCache[a] = b);
      c() && 0 < a.length && k.Logger.debug(`PackageRegistry.packageFileCache.length=${Object.keys(this.packageRootCache).length}`);
    }
    getBuiltinPackage(b) {
      let a = this.builtinPackageCache[b];
      null == a && (a = new r(b, process.version), this.builtinPackageCache[b] = a);
      return a;
    }
  }
  a.PackageRegistry = new d;
});
S("src/lib/SupportAlertBuilder", "require exports module path src/lib/Agent src/lib/Configuration src/lib/PackageRegistry src/lib/RunTimeProperty src/lib/util/CoreUtil src/lib/util/RuntimeUtil src/lib/util/InvocationUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c, r) {
  Object.defineProperty(a, "__esModule", {value:!0});
  const b = ".*listen EADDRINUSE.*;.*ENOENT: no such file or directory.*;.*EFAULT: bad address in system call argument.*;.*ENOMEM.*;.*Unexpected token \\S+ in JSON at position.*;.*duplicate key error.*;.*Cannot find module.*;.*Login failed for user.*;.*Connection lost: The server closed the connection.*;.*Connection terminated unexpectedly.*;.*Unexpected end of JSON input.*".split(";");
  class d {
    constructor() {
      this.debugSuppressAllAlertsProperty = new m.BooleanProperty("SuppressSupportAlerts", !1);
      this.agentMaxPosOnStack = (new m.NumberOption("AgentMaxPosOnStack", 3)).value;
      this.ignoreErrorsFilter = [];
      for (var a of b) {
        this.ignoreErrorsFilter.push(new RegExp(a));
      }
      a = (new m.StringOption("NonRelevantErrors", "")).value;
      if (0 < a.length) {
        for (const b of a.split("|")) {
          0 < b.length ? this.ignoreErrorsFilter.push(new RegExp(b)) : f.Logger.info("Found empty RegExp in non relevant errors. Ignoring it. " + `Use '${this.debugSuppressAllAlertsProperty.name}' to suppress all support alerts.`);
        }
      }
    }
    static handleUncaughtException(b, a) {
      const c = new d;
      d.generateSupportAlert(f.Agent.nativeAgent.SupportAlertType.Crash, b.stack ? b.stack : "", c.isAgentRelevant(b), a);
    }
    static handleInstrumentationError(b) {
      const a = new d;
      d.generateSupportAlert(f.Agent.nativeAgent.SupportAlertType.InstrumentationProblem, b.stack ? b.stack : "", a.isAgentRelevant(b), !1);
    }
    static _testonly_createInstance() {
      return new d;
    }
    static generateSupportAlert(b, a, c, e) {
      f.Agent.nativeAgent.generateSupportAlert(b, a, process.execPath, c, e, d.getModuleCacheFileList());
    }
    isAgentRelevant(b) {
      return !this.debugSuppressAllAlerts && this.isErrorMessageRelevant(b.message) && this.isAgentOnTopOfStack(b.stack ? b.stack : "");
    }
    static getModuleCacheFileList() {
      const b = {};
      for (let a in e.Module._cache) {
        c.hasCaseInsensitiveFilePaths() && (a = a.toLowerCase());
        const d = n.PackageRegistry.lookup(a);
        b[a] = !0;
        d && d.packageRoot && (b[`${h.join(d.packageRoot, "/package.json")} (${d.version ? d.version : "?"})`] = !0);
      }
      return Object.keys(b);
    }
    isErrorMessageRelevant(b) {
      return b ? null == g.match(this.ignoreErrorsFilter, b) : !0;
    }
    isAgentOnTopOfStack(b) {
      b = b.split("\n");
      for (let a = 1; a < b.length && a <= this.agentMaxPosOnStack; a++) {
        if (-1 !== b[a].indexOf(k.Configuration.rootFolder) && !this.isSafeInvoke(b[a]) && !this.isServiceDetectionMethod(b[a])) {
          return a <= this.agentMaxPosOnStack;
        }
      }
      return !1;
    }
    get debugSuppressAllAlerts() {
      return this.debugSuppressAllAlertsProperty.value;
    }
    isSafeInvoke(b) {
      return -1 !== b.indexOf("safeInvoke");
    }
    isServiceDetectionMethod(b) {
      return -1 !== b.indexOf(r.doInvoke.name) || -1 !== b.indexOf("dynatraceOnServiceExecutionIndicator");
    }
  }
  a.SupportAlertBuilder = d;
});
S("src/lib/util/ErrorUtil", ["require", "exports", "src/lib/Agent", "src/lib/SupportAlertBuilder", "src/lib/Logger"], function(t, a, e, h, f) {
  function k(a) {
    return a instanceof Error ? a.stack : a;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.verboseExceptionObject = k;
  a.logAgentException = function(a) {
    a = k(a);
    f.warning(`agent exception: ${a}`);
    if (null != e.Agent.nativeAgent) {
      {
        var g = e.Agent.nativeAgent.SupportAlertType.InstrumentationProblem;
        const c = Date.now();
        if (!(864E5 > c - n)) {
          try {
            h.SupportAlertBuilder.generateSupportAlert(g, a, !0, !1), n = c;
          } catch (r) {
          }
        }
      }
    }
  };
  a.reportInstrumentationError = function(a, f) {
    f = Array.isArray(f) ? f : [f];
    a = a.name;
    try {
      h.SupportAlertBuilder.generateSupportAlert(e.Agent.nativeAgent.SupportAlertType.InstrumentationProblem, `${a}=[${f}]`, !0, !1);
    } catch (c) {
    }
  };
  let n = 0;
});
S("src/lib/modules/AmbientSampling", "require exports timers semver src/lib/Agent src/lib/RunTimeProperty src/lib/RuntimeSetting src/lib/util/RuntimeUtil".split(" "), function(t, a, e, h, f, k, n, m) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class g {
    constructor() {
      this.name = "AmbientSampling";
      this.onPeriodicSamplingSessionStart = () => {
        try {
          this.isDebugEnabled && f.Logger.debug("AmbientSampling: onSporadicSamplingSessionStart"), e.setTimeout(this.onPeriodicSamplingSessionEnd, this.samplingSessionDurationOption.value).unref(), this.startNativeSamplingSession();
        } catch (c) {
          f.Logger.info(`AmbientSampling: onPeriodicSamplingSessionStart failed ${c}`);
        }
      };
      this.onPeriodicSamplingSessionEnd = () => {
        try {
          this.isDebugEnabled && f.Logger.debug("AmbientSampling: onSporadicSamplingSessionEnd"), this.stopNativeSamplingSession();
        } catch (c) {
          f.Logger.info(`AmbientSampling: onPeriodicSamplingSessionEnd failed ${c}`);
        }
      };
      this.onContinousSamplingSessionEnd = () => {
        try {
          this.isDebugEnabled && f.Logger.debug("AmbientSampling: onContinousSamplingSessionEnd"), this.stopNativeSamplingSession(!0);
        } catch (c) {
          f.Logger.info(`AmbientSampling: onContinousSamplingSessionEnd failed ${c}`);
        }
      };
      this.isNativeSamplingSessionActive = this.isPlatformSupported = !1;
      this.currentV8SamplingInterval = this.currentSessionDuration = this.currentSessionFrequency = 0;
      this.isInitialized = !1;
      this.inStartupGracePeriod = !0;
      this.featureEnableSetting = new n.RuntimeSetting("ambientSampling.enabled");
      this.featureForceEnableSetting = new n.RuntimeSetting("ambientSampling.forceEnable");
      this.featureDisabledFlag = new k.BooleanProperty("AmbientSamplingFeatureDisable", !1);
      this.debugLoggingFlag = new k.BooleanProperty("AmbientSamplingLoggingEnable", !1);
      this.samplingSessionDurationOption = new k.NumberOption("AmbientSamplingSessionDuration", 60000);
      this.samplingSessionFrequencyOption = new k.NumberOption("AmbientSamplingSessionFrequency", 0);
      this.v8SamplingIntervalOption = new k.NumberOption("AmbientSamplingV8SamplingInterval", 5000);
    }
    get isDebugEnabled() {
      return this.debugLoggingFlag.value;
    }
    get startable() {
      return !f.Agent.active || this.featureDisabledFlag.value ? !1 : this.featureEnableSetting.value && this.isPlatformSupported;
    }
    get isStarted() {
      return null != this.intervalTimer;
    }
    onInit() {
      this.isDebugEnabled && f.Logger.debug("AmbientSampling: initializing module");
      this.updateRuntimeRestrictions();
      this.isInitialized = !0;
      setTimeout(() => {
        this.isDebugEnabled && f.Logger.debug(`AmbientSampling: end of startup grace period - trigger sampling start with ${this.verboseOptions()}`);
        this.inStartupGracePeriod = !1;
        this.start();
      }, this.samplingSessionDurationOption.value).unref();
      this.isDebugEnabled && f.Logger.debug(`AmbientSampling: started startup grace period timer with ${this.samplingSessionDurationOption.value / 1000} seconds with ${this.verboseOptions()}`);
    }
    onConfigUpdate() {
      this.isInitialized && (this.isDebugEnabled && f.Logger.debug(`AmbientSampling: config update ${this.verboseOptions()}`), this.updateRuntimeRestrictions(), this.isStarted === this.startable && this.currentSessionFrequency === this.samplingSessionFrequencyOption.value && this.currentSessionDuration === this.samplingSessionDurationOption.value && this.currentV8SamplingInterval === this.v8SamplingIntervalOption.value || this.start());
    }
    onLifeCycleStateChanged() {
      f.Agent.lifeCycleState === f.LifeCycleState.ShuttingDown && this.stop();
    }
    updateRuntimeRestrictions() {
      if (this.isPlatformSupported = !m.isWindows()) {
        this.isPlatformSupported = h.satisfies(process.version, "^8.9.4 || >=9.3.0", {includePrerelease:!0});
      }
      this.isPlatformSupported || (this.featureForceEnableSetting.value ? (this.isPlatformSupported = !0, f.Logger.info("AmbientSampling: force enable overrides platform restriction")) : f.Logger.info("AmbientSampling: unsupported platform / node version"));
    }
    start() {
      try {
        this.inStartupGracePeriod ? this.isDebugEnabled && f.Logger.debug("AmbientSampling: rejecting startup request as still in startup grace period") : (this.isStarted && this.stop(), this.startable && (f.Logger.info(`AmbientSampling: starting up ${this.verboseOptions()}`), 0 === this.samplingSessionFrequencyOption.value ? (this.intervalTimer = e.setInterval(this.onContinousSamplingSessionEnd, this.samplingSessionDurationOption.value), this.startNativeSamplingSession()) : (this.intervalTimer = 
        e.setInterval(this.onPeriodicSamplingSessionStart, this.samplingSessionFrequencyOption.value), this.onPeriodicSamplingSessionStart()), this.intervalTimer.unref(), this.currentSessionFrequency = this.samplingSessionFrequencyOption.value, this.currentSessionDuration = this.samplingSessionDurationOption.value, this.currentV8SamplingInterval = this.v8SamplingIntervalOption.value));
      } catch (c) {
        f.Logger.info(`AmbientSampling: start failed ${c}`);
      }
    }
    stop() {
      try {
        this.isStarted && (f.Logger.info("AmbientSampling: stop"), null != this.intervalTimer && (e.clearInterval(this.intervalTimer), this.intervalTimer = void 0), null != this.sessionEndTimer && (e.clearTimeout(this.sessionEndTimer), this.sessionEndTimer = void 0), this.stopNativeSamplingSession());
      } catch (c) {
        f.Logger.info(`AmbientSampling: stop failed ${c}`);
      }
    }
    startNativeSamplingSession() {
      this.isNativeSamplingSessionActive || (f.Agent.nativeAgent.startAmbientSampling(this.v8SamplingIntervalOption.value), this.isNativeSamplingSessionActive = !0);
    }
    stopNativeSamplingSession(a = !1) {
      this.isNativeSamplingSessionActive && (f.Agent.nativeAgent.stopAmbientSampling(!1, this.v8SamplingIntervalOption.value), a && f.Agent.nativeAgent.startAmbientSampling(this.v8SamplingIntervalOption.value), this.isNativeSamplingSessionActive = a);
    }
    verboseOptions() {
      return `SessionFrequency=${this.samplingSessionFrequencyOption.value}ms, ` + `SessionDuration=${this.samplingSessionDurationOption.value}ms, ` + `V8SamplingInterval=${this.v8SamplingIntervalOption.value}us, ` + `ambientSampling.enabled=${this.featureEnableSetting.value}, ` + `ambientSampling.forceEnabled=${this.featureForceEnableSetting.value}`;
    }
  }
  a.AmbientSampling = g;
});
S("src/lib/modules/IrqBasedCpuSampling", "require exports src/lib/Agent src/lib/RunTimeProperty src/lib/SubPathContext src/lib/RuntimeSetting".split(" "), function(t, a, e, h, f, k) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class n {
    onFirstContextActivation() {
      this.theSharedIsOnService[0] = e.Agent.nativeAgent.AmbientSamplingServiceIndication.ON_SERVICE;
    }
    onLastContextDeactivation() {
      this.theSharedIsOnService[0] = e.Agent.nativeAgent.AmbientSamplingServiceIndication.OFF_SERVICE;
    }
    set sharedIsOnServiceIndicator(a) {
      this.theSharedIsOnService = a;
    }
  }
  class m {
    constructor() {
      this.name = "IrqBasedCpuSampling";
      this.autoSensorCurrentlyEnabled = this.ambientSamplingCurrentlyEnabled = this.isInitialized = this.isStarted = !1;
      this.samplingOnServiceIndicator = new n;
      this.debugLoggingFlag = new h.BooleanProperty("IrqBasedCpuSampling", !1);
      this.featureDisabled = new h.BooleanOption("IrqBasedCpuSamplingDisabled", !1);
      this.ambientSamplingEnabled = new k.RuntimeSetting("ambientSampling.enabled");
      this.autoSensorEnabled = new k.RuntimeSetting("autoSensor.enabled");
    }
    get isDebugEnabled() {
      return this.debugLoggingFlag.value;
    }
    onInit() {
      e.Logger.info(`IrqBasedCpuSampling: initializing module ${this.verboseOptions()})`);
      this.samplingOnServiceIndicator.sharedIsOnServiceIndicator = e.Agent.nativeAgent.initSampling();
      this.start();
      this.isInitialized = !0;
    }
    onConfigUpdate() {
      this.isInitialized && (this.isDebugEnabled && e.Logger.debug(`IrqBasedCpuSampling: config update ${this.verboseOptions()}`), this.isStarted !== this.startable || this.ambientSamplingCurrentlyEnabled !== this.ambientSamplingEnabled.value || this.autoSensorCurrentlyEnabled !== this.autoSensorEnabled.value) && (this.isDebugEnabled && e.Logger.debug("IrqBasedCpuSampling: restarting..."), this.start());
    }
    onLifeCycleStateChanged() {
      e.Agent.lifeCycleState === e.LifeCycleState.ShuttingDown && this.stop();
    }
    verboseOptions() {
      return `IrqBasedCpuSamplingDisabled=${this.featureDisabled.value}, ` + `autoSensor.enabled=${this.autoSensorEnabled.value}, ` + `ambientSampling.enabled=${this.ambientSamplingEnabled.value}`;
    }
    start() {
      try {
        this.isStarted && this.stop(), this.startable && (this.isStarted = !0, this.isDebugEnabled && e.Logger.debug(`IrqBasedCpuSampling: starting up ${this.verboseOptions()}`), this.ambientSamplingCurrentlyEnabled = this.ambientSamplingEnabled.value, this.autoSensorCurrentlyEnabled = this.autoSensorEnabled.value, f.SubPathContext.addContextStackListener(this.samplingOnServiceIndicator), e.Agent.nativeAgent.startSampling(this.autoSensorCurrentlyEnabled, this.ambientSamplingCurrentlyEnabled));
      } catch (g) {
        e.Logger.info(`IrqBasedCpuSampling: start failed ${g}`);
      }
    }
    stop() {
      try {
        this.isStarted && (this.isDebugEnabled && e.Logger.info("IrqBasedCpuSampling: stopping sampling..."), e.Agent.nativeAgent.stopSampling(), this.isStarted = !1, f.SubPathContext.removeContextStackListener(this.samplingOnServiceIndicator));
      } catch (g) {
        e.Logger.info(`IrqBasedCpuSampling: stop failed ${g}`);
      }
    }
    get startable() {
      return !e.Agent.active || this.featureDisabled.value ? !1 : this.autoSensorEnabled.value || this.ambientSamplingEnabled.value;
    }
  }
  a.IrqBasedCpuSampling = m;
});
S("src/lib/modules/CpuSampling", "require exports src/lib/Agent src/lib/modules/AmbientSampling src/lib/modules/AutoSensorModule src/lib/modules/IrqBasedCpuSampling src/lib/RunTimeProperty".split(" "), function(t, a, e, h, f, k, n) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class m {
    constructor() {
      this.name = "CpuSampling";
    }
    onInit() {
      e.Agent.isCim || ((new n.BooleanOption("UseIrqBasedCpuSampling", !0)).value ? e.Agent.register(new k.IrqBasedCpuSampling) : (e.Agent.register(new h.AmbientSampling), e.Agent.register(new f.AutoSensorModule)));
    }
  }
  a.CpuSampling = m;
});
S("src/lib/modules/MemMetrics", ["require", "exports", "src/lib/Agent"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class h {
    constructor() {
      this.name = "MemMetrics";
    }
    onInit() {
      this.timer = setInterval(h.onPeriodicTimer, 1E4);
      this.timer.unref();
    }
    onLifeCycleStateChanged() {
      e.Agent.lifeCycleState === e.LifeCycleState.ShuttingDown && this.timer && (clearInterval(this.timer), this.timer = void 0);
    }
    static onPeriodicTimer() {
      if (e.Agent.active && e.Agent.nativeAgent) {
        try {
          const a = process.memoryUsage();
          e.Agent.nativeAgent.onPeriodicMemMetrics(a.heapTotal, a.heapUsed, a.rss);
        } catch (f) {
          e.Logger.info(`Exception during capturing memory usage: ${f}`);
        }
      }
    }
  }
  a.MemMetricsModule = h;
});
S("src/lib/modules/PackageListReporter", ["require", "exports", "src/lib/Agent", "src/lib/PackageRegistry", "src/lib/DebugLoggingEntity"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class k extends f.default {
    constructor() {
      super("PackageListReporterModule");
      this.name = "PackageListReporterModule";
      this.addToDebugLogDomain("ModuleLoad");
    }
    onInit() {
      this.timer = setTimeout(k.onPeriodicTimer, 1E4, this, !0);
      this.timer.unref();
      this.interval = setInterval(k.onPeriodicTimer, 6E5, this, !1);
      this.interval.unref();
    }
    onLifeCycleStateChanged() {
      e.Agent.lifeCycleState === e.LifeCycleState.ShuttingDown && (null != this.timer && (clearTimeout(this.timer), this.timer = void 0), null != this.interval && (clearInterval(this.interval), this.interval = void 0));
    }
    static onPeriodicTimer(a, f) {
      f && (a.timer = void 0);
      if (e.Agent.active && null != e.Agent.nativeAgent) {
        try {
          a.isDebugEnabled && e.Logger.debug(`updating package list: ${h.PackageRegistry.packageList.join(",")}`), e.Agent.nativeAgent.reportPackageList(h.PackageRegistry.packageList);
        } catch (g) {
          e.Logger.info(`Exception while sending module information: ${g}`);
        }
      }
    }
  }
  a.PackageListReporterModule = k;
});
S("src/lib/AsyncHooksController", "require exports semver src/lib/Agent src/lib/Debug src/lib/DebugLoggingEntity src/lib/RunTimeProperty src/lib/SubPathContext src/lib/util/ErrorUtil".split(" "), function(t, a, e, h, f, k, n, m, g) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.cPromiseType = "PROMISE";
  a.cQueueMicrotaskType = "Microtask";
  class c extends k.default {
    constructor() {
      super("AsyncHooksController");
      this.disabledFlag = new n.BooleanProperty("AsyncHooksControllerDisabled");
      this.contextPassingEnabledFlag = new n.BooleanProperty("AsyncHooksControllerContextPassingEnabled");
      this.asyncIdMap = Object.create(null);
      this.asyncIdMapEntryCount = 0;
      f.assert(null == c.instance);
      c.instance = this;
      this.shallMonitorQueueMicrotask = e.satisfies(process.version, ">=11.0.0", {includePrerelease:!0});
    }
    get isActive() {
      return null != this.asyncHookHdl;
    }
    get isFeatureEnabled() {
      return !this.disabledFlag.value;
    }
    setup() {
      if (!this.isActive && this.isFeatureEnabled && !h.Agent.isCim) {
        try {
          const a = t("async_hooks");
          this.logDebug(`AsyncHooks.setup: contextPassing=${this.contextPassingEnabledFlag.value}`);
          this.asyncHookHdl = a.createHook({init:c.onAsyncInit, before:c.onAsyncBefore, after:c.onAsyncAfter, destroy:c.onAsyncDestroy});
          this.asyncHookHdl.enable();
        } catch (r) {
          this.asyncHookHdl = void 0, g.logAgentException(r);
        }
      }
    }
    static onAsyncInit(a, b, d) {
      const e = c.instance;
      if (c.shouldSaveContext(b)) {
        const c = m.SubPathContext.getActiveContext();
        null != c && (null != e.asyncIdMap[a] && h.Logger.warning(`onAsyncInit: asyncId ${a} is already set to ${e.asyncIdMap[a]} in asyncIdMap`), c.didInitiateAsyncOp = !0, e.asyncIdMap[a] = c, ++e.asyncIdMapEntryCount, e.isDebugEnabled && h.Logger.debug(`onAsyncInit: adding ${b}/${d}/[${a}]->${c} [${e.asyncIdMapEntryCount}]`));
      }
    }
    static onAsyncBefore(a) {
      const b = c.instance, d = b.asyncIdMap[a];
      null != d && (b.isDebugEnabled && h.Logger.debug(`onAsyncBefore: activating context [${a}]->${d}`), d.activate());
    }
    static onAsyncAfter(a) {
      const b = c.instance, d = b.asyncIdMap[a];
      null != d && (b.isDebugEnabled && h.Logger.debug(`onAsyncAfter: deactivating context [${a}]->${d}`), d.deactivate());
    }
    static onAsyncDestroy(a) {
      const b = c.instance;
      null != b.asyncIdMap[a] && (--b.asyncIdMapEntryCount, b.isDebugEnabled && h.Logger.debug(`onAsyncDestroy: removing [${a}]->${b.asyncIdMap[a]} [${b.asyncIdMapEntryCount}]`), delete b.asyncIdMap[a]);
    }
    static shouldSaveContext(e) {
      const b = c.instance;
      return b.contextPassingEnabledFlag.value || e === a.cPromiseType || b.shallMonitorQueueMicrotask && e === a.cQueueMicrotaskType;
    }
  }
  a.AsyncHooksController = c;
});
S("src/lib/Blacklist", ["require", "exports", "src/lib/Configuration", "src/lib/RunTimeProperty", "src/lib/Logger"], function(t, a, e, h, f) {
  Object.defineProperty(a, "__esModule", {value:!0});
  const k = ["grunt", "gulp", "node-gyp", "npm"], n = ["atom-package-manager", "forever", "localtunnel-server"];
  a.isBlacklisted = function() {
    var a = new h.StringOption("ScriptBlacklist"), g = new h.StringOption("AppBlacklist");
    const c = /\s*,\s*/;
    let r = k;
    "" !== a.value && (r = a.value.split(c), f.info(`Scripts blacklist: ${a.value}`));
    a = n;
    "" !== g.value && (a = g.value.split(c), f.info(`App blacklist: ${g.value}`));
    g = -1 !== r.indexOf(e.Configuration.scriptName);
    null != e.Configuration.appName && (g = g || -1 !== a.indexOf(e.Configuration.appName));
    return g;
  };
});
S("src/lib/Dispatcher", ["require", "exports", "src/lib/Debug", "src/lib/util/InvocationUtil"], function(t, a, e, h) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class f {
    constructor(a) {
      this.methodName = a;
      this.listeners = [];
    }
    addListener(a) {
      e.assert(a[this.methodName]);
      this.listeners.push(a);
    }
    doDispatch(a) {
      for (const e of this.listeners) {
        a(e);
      }
    }
    dispatch(...a) {
      for (const a of this.listeners) {
        h.doInvoke(a, a[this.methodName], arguments);
      }
    }
  }
  a.Dispatcher = f;
});
S("src/lib/NiLoader", "require exports fs path os src/lib/Logger".split(" "), function(t, a, e, h, f, k) {
  function n() {
    return "x64" === process.arch || "ppc64" === process.arch || "arm64" === process.arch;
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class m {
    constructor() {
      this.dsoFileName = "";
    }
    load(a) {
      var c = a.libcvendor ? a.libcvendor : "";
      !this.nativeInterface && (a = a.nativeLibsRootPath || process.env.DT_NODE_NATIVE_LIBS_ROOT) && (a = h.join(a, this.getNativeLibsFolderName(c), this.nativeModuleFileName), this.requireNativeLibrary(a));
      this.nativeInterface || (a = h.join(__dirname, this.oneAgentBaseDirRelative, this.getPlatformFolderName(c), this.nativeModuleFileName), this.requireNativeLibrary(a));
      this.nativeInterface || (a = h.join(__dirname, this.oneAgentBaseDirRelative, this.getPlatformFolderName(""), this.nativeModuleFileName), this.requireNativeLibrary(a));
      this.nativeInterface || (c = h.join(__dirname, this.oneAgentBaseDirRelative, this.getNativeLibsFolderName(c), this.nativeModuleFileName), this.requireNativeLibrary(c));
      this.nativeInterface || k.info("Unable to load native interface.");
      return this.nativeInterface;
    }
    requireNativeLibrary(a) {
      k.info(`try to load native library from ${a}`);
      if (e.existsSync(a)) {
        try {
          this.nativeInterface = t(a), this.dsoFileName = a, k.info(`loaded ${a}`);
        } catch (c) {
          k.info(`failed to load ${a} ': ${c}`);
        }
      }
    }
    get moduleFileName() {
      return this.dsoFileName;
    }
    getNativeLibsFolderName(a) {
      a = "musl" === a ? "libmusl" : "lib";
      return n() ? a + "64" : a;
    }
    get nativeModuleFileName() {
      return "oneagentnode_" + process.versions.modules + ".node";
    }
    get oneAgentBaseDirRelative() {
      return module.__DT_NODE_OBFUSCATED_AGENT__ ? "../.." : "../../..";
    }
    getPlatformFolderName(a) {
      let c;
      switch(process.platform) {
        case "win32":
          c = "windows-x86";
          break;
        case "linux":
          c = "linux";
          "ppc64" === process.arch ? c += "-ppc" + f.endianness().toLowerCase() : "arm64" === process.arch ? c += "-arm" : ("musl" === a && (c += "-musl"), c += "-x86");
          break;
        default:
          c = process.platform;
      }
      return c += n() ? "-64" : "-32";
    }
  }
  a.NiLoader = m;
});
S("src/lib/NiStub", ["require", "exports", "src/lib/util/CoreUtil"], function(t, a, e) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class h {
    constructor(a) {
      this.valid = !0;
      h.objectCounter[a] ? ++h.objectCounter[a] : h.objectCounter[a] = 1;
      this.id = h.objectCounter[a];
    }
    toString() {
      return `[${this.id}]`;
    }
    equals(a) {
      return this === a;
    }
  }
  h.objectCounter = {};
  class f extends h {
    constructor() {
      super("Attachment");
    }
    setFieldFloat() {
      return !0;
    }
    setFieldInteger() {
      return !0;
    }
    setFieldString() {
      return !0;
    }
    setFieldStringCached() {
      return !0;
    }
    setFieldStringUnavailable() {
      return !0;
    }
    setFieldKeyValue() {
      return !0;
    }
    setFieldKeyValueCached() {
      return !0;
    }
    setAutoSensorFrames() {
      return !0;
    }
    beginFastFieldAccess() {
    }
    endFastFieldAccess() {
    }
  }
  class k extends h {
    constructor() {
      super("PurePath");
    }
    endPath() {
      return !0;
    }
    getAttachment() {
      return new f;
    }
    methodEnter() {
      return !0;
    }
    methodEnterSuspended() {
      return !0;
    }
    methodExit() {
      return !0;
    }
    methodSuspend() {
      return !0;
    }
    methodResume() {
      return !0;
    }
    methodException() {
      return !0;
    }
    createLink() {
      return new n;
    }
    addLink() {
      return !0;
    }
    createAddSerializeLink() {
      return (new n).serialize();
    }
    createAddSerializeLinkToBlob() {
      return (new n).toBlob();
    }
    getExitTimeStamps() {
      return [[0, 1], [2, 3]];
    }
    createLocalLink() {
      return [0, 1];
    }
  }
  class n extends h {
    constructor() {
      super("Link");
    }
    serialize() {
      return {dtTag:`serialized(${this})`, traceParent:"", traceState:""};
    }
    toBlob() {
      return Buffer.from(this.serialize().dtTag || "");
    }
    duplicate() {
      return new n;
    }
    purge() {
    }
  }
  class m {
    constructor(a) {
      this.AgentConfiguration = a.AgentConfiguration;
      this.AttachmentFieldId = a.AttachmentFieldId;
      this.AttachmentId = a.AttachmentId;
      this.AttachmentTarget = a.AttachmentTarget;
      this.ChannelType = a.ChannelType;
      this.ConnectionPoolTopology = a.ConnectionPoolTopology;
      this.Creator = a.Creator;
      this.DbAggregationMechanism = a.DbAggregationMechanism;
      this.DbMethodType = a.DbMethodType;
      this.DbServiceType = a.DbServiceType;
      this.ExternalCallType = a.ExternalCallType;
      this.MethodCategory = a.MethodCategory;
      this.RemoteCallWireProtocol = a.RemoteCallWireProtocol;
      this.SensorId = a.SensorId;
      this.MessagingTopology = a.MessagingTopology;
      this.TransmissionType = a.TransmissionType;
      this.MessagingMessagetype = a.MessagingMessagetype;
      this.cInvalidPath = new k;
      this.cInvalidLink = new n;
      this.cInvalidAttachment = new f;
      this.cInvalidMethodId = a.cInvalidMethodId;
      this.TaggingMode = a.TaggingMode;
    }
    startPath() {
      return new k;
    }
    startLocalPath() {
      return new k;
    }
    deserializeLinkFromString() {
      return new n;
    }
    deserializeLinkFromBlob() {
      return new n;
    }
    setSqlResultSetData() {
      return !0;
    }
  }
  class g {
    constructor(a) {
      this.requestHeaders = a;
      this.isPathBlocked = !1;
    }
    release() {
    }
    isUemWebRequest() {
      return !1;
    }
    isInjecting() {
      return !0;
    }
    getServerId() {
      return 0;
    }
    getMobileTag() {
    }
    handleRequest() {
      return {isSpecialRequest:!1, postBodyNeeded:!1, maxPostBodySize:1024};
    }
    responseStarted(a) {
      this.responseHeaders = a;
      return !0;
    }
    getChangedRequestHeaders() {
      return this.requestHeaders;
    }
    getChangedResponseHeaders() {
      return this.responseHeaders;
    }
    injectJsAgentTag(a) {
      return a;
    }
    updateRequestBody() {
      return !0;
    }
    getResponseBody() {
    }
    getResponseStatus() {
      return 200;
    }
  }
  class c {
    configure() {
    }
    createUemSensorContext(a, b) {
      return new g(b);
    }
  }
  a.enable = function(a) {
    const b = a.niAgent;
    if (b) {
      const d = new c, f = new m(b.correlation), g = Object.create(null);
      for (const a in b) {
        if ("correlation" === a) {
          g.correlation = f;
        } else {
          if ("uemSensor" === a) {
            g.uemSensor = d;
          } else {
            const c = b[a];
            e.isFunction(c) ? g[a] = function() {
              return c.apply(b, arguments);
            } : g[a] = b[a];
          }
        }
      }
      a.niAgent = g;
    }
  };
});
S("src/lib/Agent", "require exports path src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/modules/CpuSampling src/lib/modules/MemMetrics src/lib/modules/PackageListReporter src/lib/modules/SensorManager src/lib/AsyncHooksController src/lib/Blacklist src/lib/Configuration src/lib/Dispatcher src/lib/Logger src/lib/NiLoader src/lib/RunTimeProperty src/lib/RuntimeSetting".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b, d, l, x, p, q) {
  Object.defineProperty(a, "__esModule", {value:!0});
  a.Configuration = b.Configuration;
  a.Logger = l;
  var v;
  (function(a) {
    a[a.PreInitial = 0] = "PreInitial";
    a[a.Initializing = 1] = "Initializing";
    a[a.Running = 2] = "Running";
    a[a.ShuttingDown = 3] = "ShuttingDown";
    a[a.PostMortem = 4] = "PostMortem";
    a[a.Undefined = 5] = "Undefined";
  })(v = a.LifeCycleState || (a.LifeCycleState = {}));
  class D {
    constructor() {
      this.active = !0;
      this.blacklisted = !1;
      this.managedAgentVersion = "not specified";
      this.createAgentResult = {};
      this.agentInitOptions = {};
      this.agentInitParams = {};
      this.onConfigUpdate = a => {
        try {
          const b = JSON.parse(a);
          null != b.agentActive && this.active !== b.agentActive && (this.active = b.agentActive, this.agentClassDebugFlag.value && l.debug(`agent active changed to '${this.active}'`));
          if (null != b.rtc) {
            if (null != b.rtc.booleanMap) {
              for (const a in b.rtc.booleanMap) {
                b.rtc.booleanMap[a] = "true" === String(b.rtc.booleanMap[a]);
              }
            }
            if (null != b.rtc.longMap) {
              for (const a in b.rtc.longMap) {
                b.rtc.longMap[a] = +b.rtc.longMap[a];
              }
            }
            l.info(`Updated runtime configuration to revision ${b.rtcRevision}`);
          }
          null != b.uemConfig && l.info(`Updated UEM configuration to revision ${b.uemConfigRevision}`);
          this.niConfig = b;
          this.configUpdateListeners.dispatch(b);
        } catch (u) {
          f.logAgentException(u);
        }
      };
      this.existsInModuleCache = a => {
        a = e.normalize(a);
        var b = a.charAt(0);
        const c = a.substring(1);
        b = null != t.cache[b.toUpperCase() + c] || null != t.cache[b.toLowerCase() + c];
        this.agentClassDebugFlag.value && l.debug(`handled upload request with token='${a}' returning=${b}`);
        return b;
      };
      this.agentClassDebugFlag = new p.BooleanProperty("AgentClass", !1);
      this.agentModules = [];
      this.theLifeCycleState = v.PreInitial;
      this.configUpdateListeners = new d.Dispatcher("onConfigUpdate");
      this.lifeCycleStateChangeListeners = new d.Dispatcher("onLifeCycleStateChanged");
      this.niConfig = {};
      this.asyncHooksController = new c.AsyncHooksController;
    }
    initialize(a, c) {
      let d = !1;
      this.agentInitOptions = a;
      this.agentInitParams = c || {habitat:"Unspecified"};
      try {
        this.moveToState(v.PreInitial);
        this.moveToState(v.Initializing);
        p.parseForRunTimeProperties(a);
        const d = new x.NiLoader;
        this.ni = d.load(a);
        if (!this.ni) {
          throw Error("failed to load native agent");
        }
        this.niAgent = new this.ni.NiAgent(this.stringifyOptions(a), e.basename(d.moduleFileName), this.onConfigUpdate, this.existsInModuleCache, c);
        b.Configuration.appName = this.niAgent.appName;
        try {
          this.managedAgentVersion = t(e.join(b.Configuration.rootFolder, "package.json")).agentversion;
        } catch (A) {
        }
        l.control.mode = l.Mode.NATIVE;
        this.niAgent.initialize({nodeVersion:process.version, managedAgentVersion:this.managedAgentVersion, scriptName:b.Configuration.scriptName, nodeAppName:b.Configuration.appName || "<undefined>", managedAgentRootPath:b.Configuration.rootFolder});
        this.blacklisted = r.isBlacklisted();
        this.blacklisted || (this.initAgentModules(), (new p.BooleanProperty("InstallNiStub", !1)).value && t("./NiStub").enable(this), g.default.getInstance().startModuleLoadIntercept(), this.asyncHooksController.setup());
      } catch (B) {
        d = !0, l.control.mode !== l.Mode.NATIVE && (l.control.mode = l.Mode.MANAGED), l.severe(`agent initialization failed: ${f.verboseExceptionObject(B)}`);
      } finally {
        this.logStartupInfo(), this.moveToState(d ? v.Undefined : v.Running);
      }
      return !d;
    }
    get lifeCycleState() {
      return this.theLifeCycleState;
    }
    get nativeAgent() {
      return this.niAgent;
    }
    get correlation() {
      return this.niAgent.correlation;
    }
    get metrics() {
      return this.ni.Metrics;
    }
    get uemSensor() {
      return this.niAgent.uemSensor;
    }
    get habitat() {
      return null != this.agentInitParams.habitat ? this.agentInitParams.habitat : "Unspecified";
    }
    register(a) {
      this.addListener(a);
      this.agentModules.push(a);
    }
    addListener(a) {
      a.onConfigUpdate && this.configUpdateListeners.addListener(a);
      a.onLifeCycleStateChanged && this.lifeCycleStateChangeListeners.addListener(a);
    }
    shutdown() {
      let a = !1;
      try {
        this.moveToState(v.ShuttingDown), this.niAgent && this.niAgent.shutdown();
      } catch (u) {
        a = !0, l.severe("exception during shutdown" + u);
      } finally {
        this.moveToState(a ? v.Undefined : v.PostMortem);
      }
    }
    get configuration() {
      return this.niConfig;
    }
    get isCim() {
      var a;
      const b = this.niAgent;
      return null != b ? b.monitoringMode === (null === (a = this.niAgent) || void 0 === a ? void 0 : a.AgentMonitoringMode.CLOUD_INFRASTRUCTURE_MONITORING) : !1;
    }
    logStartupInfo() {
      l.info(`Platform .................... ${process.platform}`);
      l.info(`Arch ........................ ${process.arch}`);
      l.info(`Node version ................ ${process.version}`);
      l.info(`Agent version ............... ${this.managedAgentVersion}`);
      l.info(`Script ...................... ${b.Configuration.scriptName}`);
      l.info(`AppName ..................... ${b.Configuration.appName || "<undefined>"}`);
      l.info(`Blacklisted ................. ${this.blacklisted}`);
      l.info(`MainModule .................. ${h.getOptionalPropertyValue(process.mainModule, "filename", "undefined")}`);
      l.info(`require.main................. ${h.getOptionalPropertyValue(t.main, "filename", "undefined")}`);
    }
    initAgentModules() {
      for (const a of this.agentModules) {
        a.onInit && (this.agentClassDebugFlag.value && l.debug(`initializing agent module '${a.name}'`), a.onInit());
      }
    }
    moveToState(a) {
      let b = !1;
      const c = this.lifeCycleState;
      if (c !== a) {
        switch(a) {
          case v.PreInitial:
            b = c === v.PreInitial;
            break;
          case v.Initializing:
            b = c === v.PreInitial;
            break;
          case v.Running:
            b = c === v.Initializing;
            break;
          case v.ShuttingDown:
            b = c === v.Running;
            break;
          case v.PostMortem:
            b = c === v.ShuttingDown;
            break;
          case v.Undefined:
            b = !0;
        }
        if (!b) {
          throw Error(`cannot transit from state ${v[c]} to ${v[a]}`);
        }
        this.agentClassDebugFlag.value && l.debug(`transit from ${v[c]} to ${v[a]}`);
        this.theLifeCycleState = a;
        this.lifeCycleStateChangeListeners.dispatch(c);
      }
    }
    stringifyOptions(a) {
      return Object.keys(a).map(b => {
        const c = a[b];
        switch(c) {
          case null:
          case void 0:
          case "":
            return l.info(`Ignoring empty option '${b}'`), "";
          default:
            return `${b}=${c}`;
        }
      }).join();
    }
  }
  a.NodeAgent = D;
  a.Agent = new D;
  a.Agent.addListener(new p.PropertyRtcUpdateListener);
  a.Agent.addListener(new q.RuntimeSettingsPool);
  a.Agent.register(new n.MemMetricsModule);
  a.Agent.register(new m.PackageListReporterModule);
  a.Agent.register(new g.default);
  a.Agent.register(new k.CpuSampling);
});
S("src/lib/UncaughtException", "require exports fs src/lib/ErrorObject src/lib/Logger src/lib/SupportAlertBuilder src/lib/util/RuntimeUtil".split(" "), function(t, a, e, h, f, k, n) {
  function m(a) {
    const b = 1 === process.listeners("uncaughtException").length && !m.listener;
    try {
      if (f.info(`Uncaught Exception - will exit: ${b}`), a && a instanceof Error) {
        var c;
        b && (c = h.getCallStack(a));
        f.info(a.stack || `Unknown uncaughtException ${a}`);
        k.SupportAlertBuilder.handleUncaughtException(a, b);
        if (b) {
          if (0 < c.length) {
            try {
              const a = c[0], b = a.getFileName();
              let d = a.getLineNumber();
              null == d && (d = -1);
              console.error(`${b}:${d}`);
              if (b) {
                const c = e.readFileSync(b, "utf8").split(/\r?\n/);
                console.error(c[0 < d ? d - 1 : d]);
                const f = a.getColumnNumber();
                null != f ? console.error(Array(f).join(" ") + "^") : console.error("");
              } else {
                console.error("");
              }
            } catch (x) {
              console.error("");
            }
            console.error(a.toString());
            for (const a of c) {
              const b = a.getFileName() || "";
              n.isAgentFile(b) || console.error(`    at ${a.toString()}`);
            }
          } else {
            console.error(a.stack || "Unknown uncaughtException");
          }
        }
      } else {
        f.info(`Unknown uncaughtException: error object is ${a}`), b && console.error(`Unknown uncaughtException: error object is ${a}`);
      }
    } finally {
      m.listener && m.listener(a), b && process.exit(1);
    }
  }
  function g() {
    var a = process.listeners("uncaughtException");
    if (0 < a.length && (f.info(`uncaughtException listeners installed: ${a.length}`), 1 === a.length)) {
      a = a[0];
      const b = a.listener;
      b ? f.info(`original listener <${a.name}> has already a listener attached: ${b.name}`) : (process.removeListener("uncaughtException", a), m.listener = a);
    }
    process.on("uncaughtException", m);
  }
  function c(a, c) {
    "uncaughtException" === a && f.info(`new uncaught exception listener: ${c.name}`);
  }
  function r(a, c) {
    "uncaughtException" === a && (f.info(`removed uncaughtException listener: ${c.name}`), c === m.listener && (delete m.listener, g()));
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  a.installListener = function() {
    g();
    process.on("newListener", c);
    process.on("removeListener", r);
  };
});
S("src/nodejsagent", "require exports util semver src/lib/Agent src/lib/UncaughtException src/lib/agentapi/AgentApi src/lib/util/RuntimeUtil".split(" "), function(t, a, e, h, f, k, n, m) {
  function g() {
    f.Configuration && (f.Logger && f.Logger.info("Application end"), process.removeListener("SIGINT", c), m.isWindows() ? process.removeListener("SIGBREAK", b) : process.removeListener("SIGTERM", r), f.Agent.shutdown());
  }
  function c() {
    1 === process.listeners("SIGINT").length ? process.exit(m.isWindows() ? 3221225786 : 130) : f.Logger.info("ignoring SIGINT as other listeners are present");
  }
  function r() {
    1 === process.listeners("SIGTERM").length ? process.exit(143) : f.Logger.info("ignoring SIGTERM as other listeners are present");
  }
  function b() {
    1 === process.listeners("SIGBREAK").length ? process.exit(3221225786) : f.Logger.info("ignoring SIGBREAK as other listeners are present");
  }
  return function(a, l) {
    if (global.__DT_AGENT_INJECTED__) {
      f.Logger.info("Agent already injected - exiting");
    } else {
      if (global.__DT_AGENT_INJECTED__ = {deployment:module.__DT_NODE_OBFUSCATED_AGENT__ ? 2 : 1, operational:!1}, a = a || {}, f.Logger.control.updateLoggingOptions(a), h.satisfies(process.version, "8 || 10 || 12 || 13")) {
        if (a = f.Configuration.processOptions(a), f.Agent.initialize(a, l)) {
          process.on("exit", g);
          process.on("SIGINT", c);
          if (m.isWindows()) {
            process.on("SIGBREAK", b);
          } else {
            process.on("SIGTERM", r);
          }
          f.Agent.blacklisted || (k.installListener(), n.isEnabled() && (global.__DT_GETAGENTAPI__ = n.getAgentApi));
          !m.isDebuggerActive() && f.Logger.isLoggable(f.Logger.Level.INFO) && (l = e.inspect(a).replace(/(\r\n|\n|\r)/gm, "").replace(/tenanttoken: '.*?'/gmi, "tenanttoken: '********'"), f.Logger.info(`Agent options: ${l}`));
          "AWS.Lambda" === f.Agent.habitat && (f.Logger.info("end of Lambda cold start - flushing message queues"), f.Agent.nativeAgent.onPotentialSuspension());
          f.Logger.info("Starting application");
          global.__DT_AGENT_INJECTED__.operational = !0;
          return f.Agent.createAgentResult;
        }
      } else {
        f.Logger.control.mode = f.Logger.Mode.MANAGED, f.Logger.info(`Node.js version ${process.version} is not supported. Agent disabled.`);
      }
    }
  };
});
S("src/lib/agentapi/IncomingWebRequest", "require exports url util src/lib/Agent src/lib/AttachmentBase src/lib/sensors/SensorConstants src/lib/agentapi/AgentApi src/lib/agentapi/Common src/lib/util/CoreUtil src/lib/util/ErrorUtil src/lib/util/HttpUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c, r, b) {
  function d(a, b, d, e) {
    return c.isObject(d) ? c.isString(d.applicationID) ? c.isString(d.contextRoot) ? c.isString(d.virtualHost) ? c.isObject(e) ? c.isString(e.requestMethod) ? c.isString(e.url) ? !0 : (a.logError(b, "IncomingWebRequest", "traceIncomingWebRequest: startData.url is invalid"), !1) : (a.logError(b, "IncomingWebRequest", "traceIncomingWebRequest: startData.requestMethod is invalid"), !1) : (a.logError(b, "IncomingWebRequest", "traceIncomingWebRequest: startData is not an object"), !1) : (a.logError(b, 
    "IncomingWebRequest", "traceIncomingWebRequest: webServerInfo.virtualHost is invalid"), !1) : (a.logError(b, "IncomingWebRequest", "traceIncomingWebRequest: webServerInfo.contextRoot is invalid"), !1) : (a.logError(b, "IncomingWebRequest", "traceIncomingWebRequest: webServerInfo.applicationID is invalid"), !1) : (a.logError(b, "IncomingWebRequest", "traceIncomingWebRequest: webServerInfo is not an object"), !1);
  }
  Object.defineProperty(a, "__esModule", {value:!0});
  class l extends g.DummyIncomingTracer {
    setResult() {
      return this;
    }
  }
  a.getApis = function(a) {
    return {create:function(b, c) {
      const e = {active:m.isActive(), entrypoint:!0, isDebugEnabled:m.isDebug()};
      if (!e.active) {
        return a.logWarn(e.isDebugEnabled, "IncomingWebRequest", "traceIncomingWebRequest: no trace created as SDK is inactive"), new l;
      }
      if (!d(a, e.isDebugEnabled, b, c)) {
        return new l;
      }
      e.isDebugEnabled && f.Logger.debug(`${"IncomingWebRequest"}: start() info: ${h.inspect(b)}, data: ${h.inspect(c)}`);
      return new x(e, a, b, c);
    }};
  };
  class x extends g.IncomingTaggableTracer {
    constructor(a, b, c, d) {
      super(a, b, "IncomingWebRequest");
      this.webServerInfo = c;
      this.startData = d;
    }
    setResult(a) {
      const b = this.controlParams.isDebugEnabled;
      b && f.Logger.debug(`${this}: setResult: ${h.inspect(a)}`);
      this.state !== g.TracerState.STARTED && this.sdkContext.logWarn(this.isDebugEnabled, this.moduleName, "setResult() shall be called on started tracer");
      null != this.attachmentCreator ? this.attachmentCreator.fillExitData(a) : b && f.Logger.debug(`${this}: attachmentCreator is not defined`);
      return this;
    }
    startAsyncPath(a) {
      var c = this.startData.dynatraceTag;
      if (null != this.startData.requestHeaders) {
        var d = b.normalizeHeaders(this.startData.requestHeaders);
        null == c && (c = d[n.cHttpTaggingHeader]);
      }
      c = this.getLink(c);
      d = new q(this.webServerInfo, this.startData, d, this.sdkContext, this.controlParams.isDebugEnabled);
      return this.tryStartIncomingAsyncSubPath({functionId:a, link:c, attachmentCreator:d, creator:f.Agent.correlation.Creator.ONEAGENT_SDK});
    }
  }
  class p extends k.AttachmentBase {
    constructor(a, b) {
      super(a, f.Agent.correlation.AttachmentId.ATTACHMENT_WEBREQUEST_ID, 0);
      this.debug = b;
    }
    fillEntryData(a, d, g, h) {
      this.setMultipleFields(k => {
        const l = f.Agent.correlation.AttachmentFieldId;
        k.stringCached(l.WEBREQUEST_SERVERNAME, a.virtualHost);
        k.stringCached(l.WEBREQUEST_APPLICATION_ID, a.applicationID);
        k.stringCached(l.WEBREQUEST_CONTEXTROOT, a.contextRoot);
        k.stringCached(l.WEBREQUEST_REQUEST_METHOD, d.requestMethod);
        c.isString(d.remoteAddress) ? k.string(l.WEBREQUEST_REMOTE_ADRESS, d.remoteAddress) : null != d.remoteAddress && h.logWarn(this.debug, "IncomingWebRequest", "traceIncomingWebRequest: ignoring invalid startData.remoteAddress");
        if (null != g) {
          k.map(l.WEBREQUEST_REQUEST_HEADERS, d.requestHeaders);
          var m = g.forwarded || g["x-forwarded-for"];
          null != m && k.string(l.WEBREQUEST_FORWARDED_FOR, m);
          m = b.getClientIp(g, b.getClientIPDetectionHeaders());
          null == m && (m = d.remoteAddress);
          k.string(l.WEBREQUEST_CLIENT_IP, m || "");
          k.stringCached(l.WEBREQUEST_REQUESTED_HOSTNAME, b.getHostname(g, b.getHostDetectionHeaders()));
        } else {
          k.stringCached(l.WEBREQUEST_REQUESTED_HOSTNAME, "");
        }
        m = e.parse(d.url);
        c.isString(m.query) && k.stringCached(l.WEBREQUEST_QUERY_STRING, m.query);
        null != m.pathname && k.stringCached(l.WEBREQUEST_URI, m.pathname);
      });
    }
    fillExitData(a, b) {
      this.setMultipleFields(d => {
        const e = f.Agent.correlation.AttachmentFieldId;
        c.isNumber(a.responseCode) ? d.integer(e.WEBREQUEST_RESPONSE_STATUS, a.responseCode) : null != a.responseCode && b.logWarn(this.debug, "IncomingWebRequest", "traceIncomingWebRequest: ignoring invalid exitData.responseCode");
        null != a.responseHeaders && d.map(e.WEBREQUEST_RESPONSE_HEADERS, a.responseHeaders);
        null != a.parameters && d.map(e.WEBREQUEST_REQUEST_PARAMETERS, a.parameters);
      });
    }
  }
  class q {
    constructor(a, b, c, d, e) {
      this.webServerInfo = a;
      this.entryData = b;
      this.reqHeaders = c;
      this.sdkContext = d;
      this.debug = e;
    }
    createAttachments(a) {
      a = new p(a, this.debug);
      if (a.valid) {
        this.webRequestAttachment = a;
        try {
          a.fillEntryData(this.webServerInfo, this.entryData, this.reqHeaders, this.sdkContext);
        } catch (D) {
          r.logAgentException(D);
        }
      }
    }
    fillExitData(a) {
      if (null != this.webRequestAttachment && this.webRequestAttachment.valid) {
        try {
          this.webRequestAttachment.fillExitData(a, this.sdkContext);
        } catch (D) {
          r.logAgentException(D);
        }
      } else {
        this.debug && f.Logger.debug("IncomingWebRequest: no valid WebRequestAttachment in fillExitData()");
      }
    }
  }
});
S("src/lib/transformer/AsyncAggregateTransformer", "require exports src/lib/transformer/AsyncTransformerBase src/lib/AsyncContextPassingTracker src/lib/CallbackWrappingHelper src/lib/FunctionId src/lib/SubPathContext src/lib/modules/AutoSensorModule src/lib/util/ErrorUtil src/lib/util/InvocationUtil".split(" "), function(t, a, e, h, f, k, n, m, g, c) {
  Object.defineProperty(a, "__esModule", {value:!0});
  class r extends h.default {
    constructor(a, b, c, e) {
      super(a, b, c);
      this.localLink = e;
    }
  }
  class b extends e.AsyncTransformerBase {
    constructor(a) {
      super(a);
    }
    generateSubstitute(a) {
      const b = this, d = new k.FunctionId(a);
      return function() {
        if (!b.controlParams.active) {
          return c.doInvoke(this, a.origFn, arguments);
        }
        let e;
        var f = arguments;
        try {
          const c = n.SubPathContext.getActiveContext();
          if (null != c) {
            const d = c.getAsyncAggregateableLink();
            null != d && (e = new r(b, c, a, d), f = e.manipulateArguments(arguments));
          }
        } catch (v) {
          g.logAgentException(v);
        }
        f = c.safeInvoke(this, a.origFn, f);
        try {
          m.addSample(d), null != e && e.manipulateReturnValue(f);
        } catch (v) {
          g.logAgentException(v);
        }
        return f.rethrow();
      };
    }
    wrapCallback(a) {
      return f.CallbackWrappingHelper.wrapCallbackAsyncSubpath(a);
    }
    wrapReturnValue() {
    }
  }
  a.AsyncAggregateTransformer = b;
});

})();


//# sourceMappingURL=nodejsagent.js.map

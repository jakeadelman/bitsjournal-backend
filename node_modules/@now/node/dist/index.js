"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const glob = require("@now/build-utils/fs/glob.js");
const download = require("@now/build-utils/fs/download.js");
const FileBlob = require("@now/build-utils/file-blob.js");
const FileFsRef = require("@now/build-utils/file-fs-ref.js");
const lambda_js_1 = require("@now/build-utils/lambda.js");
const run_user_scripts_js_1 = require("@now/build-utils/fs/run-user-scripts.js");
/** @typedef { import('@now/build-utils/file-ref') } FileRef */
/** @typedef {{[filePath: string]: FileRef}} Files */
/**
 * @typedef {Object} BuildParamsType
 * @property {Files} files - Files object
 * @property {string} entrypoint - Entrypoint specified for the builder
 * @property {string} workPath - Working directory for this build
 */
/**
 * @param {BuildParamsType} buildParams
 * @param {Object} [options]
 * @param {string[]} [options.npmArguments]
 */
function downloadInstallAndBundle({ files, entrypoint, workPath }, { npmArguments = [] } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const userPath = path_1.join(workPath, 'user');
        const nccPath = path_1.join(workPath, 'ncc');
        console.log('downloading user files...');
        const downloadedFiles = yield download(files, userPath);
        console.log("installing dependencies for user's code...");
        const entrypointFsDirname = path_1.join(userPath, path_1.dirname(entrypoint));
        yield run_user_scripts_js_1.runNpmInstall(entrypointFsDirname, npmArguments);
        console.log('writing ncc package.json...');
        yield download({
            'package.json': new FileBlob({
                data: JSON.stringify({
                    license: 'UNLICENSED',
                    dependencies: {
                        '@zeit/ncc': '0.15.2',
                    }
                })
            })
        }, nccPath);
        console.log('installing dependencies for ncc...');
        yield run_user_scripts_js_1.runNpmInstall(nccPath, npmArguments);
        return [downloadedFiles, nccPath, entrypointFsDirname];
    });
}
function compile(workNccPath, downloadedFiles, entrypoint) {
    return __awaiter(this, void 0, void 0, function* () {
        const input = downloadedFiles[entrypoint].fsPath;
        const ncc = require(path_1.join(workNccPath, 'node_modules/@zeit/ncc'));
        const { code, assets } = yield ncc(input);
        const preparedFiles = {};
        const blob = new FileBlob({ data: code });
        // move all user code to 'user' subdirectory
        preparedFiles[path_1.join('user', entrypoint)] = blob;
        // eslint-disable-next-line no-restricted-syntax
        for (const assetName of Object.keys(assets)) {
            const { source: data, permissions: mode } = assets[assetName];
            const blob2 = new FileBlob({ data, mode });
            preparedFiles[path_1.join('user', path_1.dirname(entrypoint), assetName)] = blob2;
        }
        return preparedFiles;
    });
}
exports.config = {
    maxLambdaSize: '5mb'
};
/**
 * @param {BuildParamsType} buildParams
 * @returns {Promise<Files>}
 */
function build({ files, entrypoint, workPath }) {
    return __awaiter(this, void 0, void 0, function* () {
        const [downloadedFiles, workNccPath, entrypointFsDirname] = yield downloadInstallAndBundle({ files, entrypoint, workPath }, { npmArguments: ['--prefer-offline'] });
        console.log('running user script...');
        yield run_user_scripts_js_1.runPackageJsonScript(entrypointFsDirname, 'now-build');
        console.log('compiling entrypoint with ncc...');
        const preparedFiles = yield compile(workNccPath, downloadedFiles, entrypoint);
        const launcherPath = path_1.join(__dirname, 'launcher.js');
        let launcherData = yield fs_extra_1.readFile(launcherPath, 'utf8');
        launcherData = launcherData.replace('// PLACEHOLDER', [
            'process.chdir("./user");',
            `listener = require("./${path_1.join('user', entrypoint)}");`,
            'if (listener.default) listener = listener.default;'
        ].join(' '));
        const launcherFiles = {
            'launcher.js': new FileBlob({ data: launcherData }),
            'bridge.js': new FileFsRef({ fsPath: require('@now/node-bridge') })
        };
        const lambda = yield lambda_js_1.createLambda({
            files: Object.assign({}, preparedFiles, launcherFiles),
            handler: 'launcher.launcher',
            runtime: 'nodejs8.10'
        });
        return { [entrypoint]: lambda };
    });
}
exports.build = build;
function prepareCache({ files, entrypoint, workPath, cachePath }) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fs_extra_1.remove(workPath);
        yield downloadInstallAndBundle({ files, entrypoint, workPath: cachePath });
        return Object.assign({}, (yield glob('user/node_modules/**', cachePath)), (yield glob('user/package-lock.json', cachePath)), (yield glob('user/yarn.lock', cachePath)), (yield glob('ncc/node_modules/**', cachePath)), (yield glob('ncc/package-lock.json', cachePath)), (yield glob('ncc/yarn.lock', cachePath)));
    });
}
exports.prepareCache = prepareCache;
